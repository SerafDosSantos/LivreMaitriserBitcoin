[[ch06]]
[[transactions]]
== Opérations

[[ch06_intro]]
=== Présentation

(((&quot;transactions&quot;, &quot;défini&quot;)))(((&quot;avertissements et mises en garde&quot;, see=&quot;aussi la sécurité&quot;)))Les transactions sont la partie la plus importante du système Bitcoin. Tout le reste dans le bitcoin est conçu pour garantir que les transactions peuvent être créées, propagées sur le réseau, validées et finalement ajoutées au grand livre mondial des transactions (la chaîne de blocs). Les transactions sont des structures de données qui encodent le transfert de valeur entre les participants au système Bitcoin. Chaque transaction est une entrée publique dans la chaîne de blocs de bitcoin, le grand livre comptable mondial en partie double.

Dans ce chapitre, nous examinerons toutes les différentes formes de transactions, ce qu&#39;elles contiennent, comment les créer, comment elles sont vérifiées et comment elles deviennent partie intégrante de l&#39;enregistrement permanent de toutes les transactions. Lorsque nous utilisons le terme &quot;portefeuille&quot; dans ce chapitre, nous faisons référence au logiciel qui construit les transactions, et pas seulement à la base de données des clés.

[[tx_structure]]
=== Transactions en détail

(((&quot;cas d&#39;utilisation&quot;, &quot;acheter du café&quot;, id=&quot;alicesix&quot;)))Dans &lt;<ch02_bitcoin_overview>&gt;, nous avons examiné la transaction utilisée par Alice pour payer un café au comptoir à café de Bob à l&#39;aide d&#39;un explorateur de blocs (&lt;<alices_transactions_to_bobs_cafe>&gt;).

L&#39;application de l&#39;explorateur de blocs montre une transaction de &quot;l&#39;adresse&quot; d&#39;Alice à &quot;l&#39;adresse&quot; de Bob. Il s&#39;agit d&#39;une vue très simplifiée de ce qui est contenu dans une transaction. En fait, comme nous le verrons dans ce chapitre, une grande partie des informations affichées sont construites par l&#39;explorateur de blocs et ne se trouvent pas réellement dans la transaction.

[[alices_transactions_to_bobs_cafe]]
.Transaction d&#39;Alice au Bob&#39;s Café
image::images/mbc2_0208.png["Alice Coffee Transaction"]

[[transactions_behind_the_scenes]]
==== Transactions: Dans les coulisses

(((&quot;transactions&quot;, &quot;détails des coulisses de&quot;))) Dans les coulisses, une transaction réelle est très différente d&#39;une transaction fournie par un explorateur de blocs typique. En fait, la plupart des constructions de haut niveau que nous voyons dans les différentes interfaces utilisateur des applications bitcoin _n&#39;existent pas réellement_ dans le système Bitcoin.

Nous pouvons utiliser l&#39;interface de ligne de commande de Bitcoin Core (+getrawtransaction+ et +decoderawtransaction+) pour récupérer la transaction &quot;brute&quot; d&#39;Alice, la décoder et voir ce qu&#39;elle contient. Le résultat ressemble à ceci :

[[alice_tx]]
.La transaction d'Alice décodée
[source,json]
----
{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}
----

Vous remarquerez peut-être certaines choses à propos de cette transaction, principalement les choses qui manquent ! Où est l&#39;adresse d&#39;Alice ? Où est l&#39;adresse de Bob ? Où est l&#39;entrée 0.1 &quot;envoyée&quot; par Alice ? En bitcoin, il n&#39;y a pas de pièces, pas d&#39;expéditeurs, pas de destinataires, pas de soldes, pas de comptes et pas d&#39;adresses. Toutes ces choses sont construites à un niveau supérieur pour le bénéfice de l&#39;utilisateur, pour rendre les choses plus faciles à comprendre.

Vous pouvez également remarquer de nombreux champs étranges et indéchiffrables et des chaînes hexadécimales. Ne vous inquiétez pas, nous expliquerons en détail chaque champ affiché ici dans ce chapitre.

[[tx_inputs_outputs]]
=== Sorties et entrées de transaction

(((&quot;transactions&quot;, &quot;sorties et entrées&quot;, id=&quot;Tout06&quot;)))(((&quot;sorties et entrées&quot;, &quot;sorties définies&quot;)))(((&quot;sorties de transaction non dépensées (UTXO)&quot;)) )(((&quot;Ensembles UTXO&quot;)))(((&quot;transactions&quot;, &quot;sorties et entrées&quot;, &quot;caractéristiques de sortie&quot;)))(((&quot;sorties et entrées&quot;, &quot;caractéristiques de sortie&quot;)))La base fondamentale d&#39;une transaction bitcoin est une _sortie de transaction_. Les sorties de transaction sont des morceaux indivisibles de monnaie bitcoin, enregistrés sur la chaîne de blocs et reconnus comme valides par l&#39;ensemble du réseau. Les nœuds complets Bitcoin suivent toutes les sorties disponibles et utilisables, appelées _sorties de transaction non dépensées_, ou _UTXO_. La collection de tous les UTXO est connue sous le nom d'_ensemble UTXO_ et compte actuellement des millions d&#39;UTXO. L&#39;ensemble UTXO augmente à mesure que de nouveaux UTXO sont créés et diminue lorsque UTXO est consommé. Chaque transaction représente un changement (transition d&#39;état) dans l&#39;ensemble UTXO.

(((&quot;soldes&quot;)))Lorsque nous disons que le portefeuille d&#39;un utilisateur a &quot;reçu&quot; du bitcoin, nous voulons dire que le portefeuille a détecté sur la chaîne de blocs un UTXO pouvant être dépensé avec l&#39;une des clés contrôlées par ce portefeuille. Ainsi, le &quot;solde&quot; de bitcoins d&#39;un utilisateur est la somme de tous les UTXO que le portefeuille de l&#39;utilisateur peut dépenser et qui peuvent être dispersés parmi des centaines de transactions et des centaines de blocs. Le concept de solde est créé par l&#39;application de portefeuille. Le portefeuille calcule le solde de l&#39;utilisateur en scannant la chaîne de blocs et en agrégeant la valeur de tout UTXO que le portefeuille peut dépenser avec les clés qu&#39;il contrôle. La plupart des portefeuilles maintiennent une base de données ou utilisent un service de base de données pour stocker un ensemble de référence rapide de tous les UTXO qu&#39;ils peuvent dépenser avec les clés qu&#39;ils contrôlent.

(((&quot;sorties de transaction dépensées (STXO)&quot;)))&lt;<utxo-stxo>&gt; affiche la chaîne de blocs à trois moments différents, alors que la chaîne de transaction de Joe à Gopesh est en cours de construction. Remarquez comment chaque transaction dépense un UTXO qui a été créé dans une transaction précédente, le transformant en une _sortie de transaction dépensée_, ou _STXO_. Puisque la transaction #1 (de Joe à Alice) dépense un seul UTXO (de Joe) et crée un seul UTXO (à Alice), elle ne modifie pas la taille de l&#39;ensemble UTXO. D&#39;autre part, les transactions #2 et #3 créent toutes deux des sorties de change à l&#39;expéditeur, dépensant un seul UTXO et créant deux UTXO (le paiement et la sortie de change). Par conséquent, chacun d&#39;eux augmente la taille de l&#39;ensemble UTXO de 1.

[[utxo-stxo]]
.Chaîne de transaction de Joe à Gopesh en cours de construction sur la chaîne de blocs
image::images/mbc2_0609.png[&quot;Chaîne de transaction de Joe à Gopesh en cours de construction sur la blockchain&quot;]

(((&quot;satoshis&quot;)))Une sortie de transaction peut avoir une valeur arbitraire (entière) libellée comme un multiple de satoshis. Tout comme les dollars peuvent être divisés jusqu&#39;à deux décimales sous forme de cents, le bitcoin peut être divisé jusqu&#39;à huit décimales sous forme de satoshis. Bien qu&#39;une sortie puisse avoir n&#39;importe quelle valeur arbitraire, une fois créée, elle est indivisible. Il s&#39;agit d&#39;une caractéristique importante des sorties qui doit être soulignée : les sorties sont des unités de valeur _discrètes_ et _indivisibles_, libellées en satoshis entiers. Une production non dépensée ne peut être consommée dans son intégralité que par une transaction.

(((&quot;change, faire&quot;)))Si un UTXO est supérieur à la valeur souhaitée d&#39;une transaction, il doit toujours être consommé dans son intégralité et le changement doit être généré dans la transaction. En d&#39;autres termes, si vous avez un UTXO d&#39;une valeur de 20 bitcoins et que vous souhaitez payer seulement 1 bitcoin, votre transaction doit consommer l&#39;intégralité de l&#39;UTXO de 20 bitcoins et produire deux sorties : une payant 1 bitcoin au destinataire souhaité et une autre payant 19 bitcoin en échange. retour dans votre portefeuille. En raison de la nature indivisible des sorties de transaction, la plupart des transactions bitcoin devront générer du change.

Imaginez une cliente qui achète une boisson à 1,50 $, puise dans son portefeuille et essaie de trouver une combinaison de pièces et de billets de banque pour couvrir le coût de 1,50 $. L&#39;acheteur choisira la monnaie exacte si disponible, par exemple un billet d&#39;un dollar et deux quarts (un quart vaut 0,25 $), ou une combinaison de coupures plus petites (six quarts), ou si nécessaire, une unité plus grande comme un billet de 5 $. Si elle remet trop d&#39;argent, disons 5 $, au propriétaire du magasin, elle s&#39;attendra à 3,50 $ de monnaie, qu&#39;elle remettra dans son portefeuille et qu&#39;elle disposera pour de futures transactions.

De même, une transaction bitcoin doit être créée à partir de l&#39;UTXO d&#39;un utilisateur dans toutes les dénominations disponibles pour cet utilisateur. Les utilisateurs ne peuvent pas couper un UTXO en deux, pas plus qu&#39;ils ne peuvent couper un billet d&#39;un dollar en deux et l&#39;utiliser comme monnaie. L&#39;application de portefeuille de l&#39;utilisateur sélectionne généralement à partir de l&#39;UTXO disponible de l&#39;utilisateur pour composer un montant supérieur ou égal au montant de transaction souhaité.

Comme dans la vraie vie, l&#39;application bitcoin peut utiliser plusieurs stratégies pour satisfaire le montant de l&#39;achat : combiner plusieurs unités plus petites, trouver la monnaie exacte ou utiliser une seule unité supérieure à la valeur de la transaction et rendre la monnaie. Tout cet assemblage complexe d&#39;UTXO dépensables est effectué automatiquement par le portefeuille de l&#39;utilisateur et est invisible pour les utilisateurs. Cela n&#39;est pertinent que si vous construisez par programme des transactions brutes à partir d&#39;UTXO.

Une transaction consomme des sorties de transaction non dépensées précédemment enregistrées et crée de nouvelles sorties de transaction qui peuvent être consommées par une transaction future. De cette façon, des morceaux de valeur bitcoin passent d&#39;un propriétaire à l&#39;autre dans une chaîne de transactions consommant et créant des UTXO.

(((&quot;transactions&quot;, &quot;transactions coinbase&quot;)))(((&quot;transactions coinbase&quot;)))(((&quot;minage et consensus&quot;, &quot;transactions coinbase&quot;)))L&#39;exception à la chaîne de sortie et d&#39;entrée est une type spécial de transaction appelé transaction _coinbase_, qui est la première transaction de chaque bloc. Cette transaction y est placée par le mineur &quot;gagnant&quot; et crée un tout nouveau bitcoin payable à ce mineur en récompense de l&#39;exploitation minière. Cette transaction coinbase spéciale ne consomme pas d&#39;UTXO ; à la place, il a un type spécial d&#39;entrée appelé &quot;coinbase&quot;. C&#39;est ainsi que la masse monétaire du bitcoin est créée pendant le processus de minage, comme nous le verrons dans &lt;<mining>&gt;.

[TIP]
====
Qu&#39;est-ce qui vient en premier ? Entrées ou sorties, la poule ou l&#39;œuf ? Strictement parlant, les sorties viennent en premier parce que les transactions coinbase, qui génèrent de nouveaux bitcoins, n&#39;ont pas d&#39;entrées et créent des sorties à partir de rien.
====

[[tx_outs]]
==== Sorties des transactions

(((&quot;transactions&quot;, &quot;sorties et entrées&quot;, &quot;composants de sortie&quot;)))(((&quot;sorties et entrées&quot;, &quot;parties de sortie&quot;)))Chaque transaction bitcoin crée des sorties, qui sont enregistrées sur le grand livre bitcoin. Presque toutes ces sorties, à une exception près (voir &lt;<op_return>&gt;) créent des morceaux de bitcoin utilisables appelés UTXO, qui sont ensuite reconnus par l&#39;ensemble du réseau et disponibles pour que le propriétaire les dépense lors d&#39;une future transaction.

Les UTXO sont suivis par chaque client Bitcoin à nœud complet dans l&#39;ensemble UTXO. Les nouvelles transactions consomment (dépensent) une ou plusieurs de ces sorties de l&#39;ensemble UTXO.

Les sorties de transaction se composent de deux parties :

* Un montant de bitcoin, libellé en _satoshis_, la plus petite unité de bitcoin
* Un puzzle cryptographique qui détermine les conditions requises pour passer la sortie

(((&quot;scripts de verrouillage&quot;)))(((&quot;script&quot;, &quot;scripts de verrouillage&quot;)))(((&quot;témoins&quot;)))(((&quot;scriptPubKey&quot;)))Le puzzle cryptographique est également connu sous le nom de _script de verrouillage_, un _script de témoin_ ou un +scriptPubKey+.

Le langage de script de transaction, utilisé dans le script de verrouillage mentionné précédemment, est décrit en détail dans &lt;<tx_script>&gt;.

Maintenant, regardons la transaction d&#39;Alice (montrée précédemment dans &lt;<transactions_behind_the_scenes>&gt;) et voir si nous pouvons identifier les sorties. Dans l&#39;encodage JSON, les sorties sont dans un tableau (liste) nommé +vout+ :

[source,json]
----
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY
    OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
  }
]
----

Comme vous pouvez le voir, la transaction contient deux sorties. Chaque sortie est définie par une valeur et un puzzle cryptographique. Dans l&#39;encodage indiqué par Bitcoin Core, la valeur est indiquée en bitcoin, mais dans la transaction elle-même, elle est enregistrée sous la forme d&#39;un entier libellé en satoshis. La deuxième partie de chaque sortie est le puzzle cryptographique qui fixe les conditions de dépenses. Bitcoin Core le montre comme +scriptPubKey+ et nous montre une représentation lisible par l&#39;homme du script.

Le sujet du verrouillage et du déverrouillage de l&#39;UTXO sera abordé plus tard, dans &lt;<tx_lock_unlock>&gt;. Le langage de script utilisé pour le script dans +scriptPubKey+ est décrit dans &lt;<tx_script>&gt;. Mais avant d&#39;approfondir ces sujets, nous devons comprendre la structure globale des entrées et sorties des transactions.

===== Sérialisation des transactions: sorties

(((&quot;transactions&quot;, &quot;sorties et entrées&quot;, &quot;structure de&quot;)))(((&quot;sorties et entrées&quot;, &quot;structure de&quot;)))(((&quot;sérialisation&quot;, &quot;sorties&quot;)))Lorsque les transactions sont transmises sur le réseau ou échangées entre applications, elles sont _sérialisées_. La sérialisation est le processus de conversion de la représentation interne d&#39;une structure de données dans un format qui peut être transmis un octet à la fois, également appelé flux d&#39;octets. La sérialisation est le plus souvent utilisée pour coder des structures de données à transmettre sur un réseau ou à stocker dans un fichier. Le format de sérialisation d&#39;une sortie de transaction est affiché dans &lt;<tx_out_structure>&gt;.

[[tx_out_structure]]
.Sérialisation des sorties de transaction
[options="header"]
|=======
|Taille| Champ | Description
| 8 octets (petit-boutiste) | Montant | Valeur du bitcoin en satoshis (10^-8^ bitcoin)
| 1–9 octets (VarInt) | Taille du script de verrouillage | Longueur du script de verrouillage en octets, à suivre
| Variable | Script de verrouillage | Un script définissant les conditions nécessaires pour dépenser la sortie
|=======

La plupart des bibliothèques et frameworks bitcoin ne stockent pas les transactions en interne sous forme de flux d&#39;octets, car cela nécessiterait une analyse complexe chaque fois que vous auriez besoin d&#39;accéder à un seul champ. Pour plus de commodité et de lisibilité, les bibliothèques bitcoin stockent les transactions en interne dans des structures de données (généralement des structures orientées objet).

(((&quot;désérialisation&quot;)))(((&quot;analyse&quot;)))(((&quot;transactions&quot;, &quot;analyse&quot;)))Le processus de conversion de la représentation de flux d&#39;octets d&#39;une transaction en données de représentation interne d&#39;une bibliothèque est appelée _désérialisation_ ou _analyse des transactions_. Le processus de reconversion en un flux d&#39;octets pour la transmission sur le réseau, pour le hachage ou pour le stockage sur disque est appelé _sérialisation_. La plupart des bibliothèques bitcoin ont des fonctions intégrées pour la sérialisation et la désérialisation des transactions.

Voyez si vous pouvez décoder manuellement la transaction d&#39;Alice à partir de la forme hexadécimale sérialisée, en trouvant certains des éléments que nous avons vus précédemment. La section contenant les deux sorties est mise en surbrillance dans &lt;<example_6_1>&gt; pour vous aider :

[[example_6_1]]
.Transaction d&#39;Alice, sérialisée et présentée en notation hexadécimale
====
+0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+
+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+
+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+
+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+
+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+
+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+
+7b4a10fa336a8d752adfffffffff02+*+60e31600000000001976a914ab6+*
*+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+*
*+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac+*
+00000000+
====

Voici quelques conseils :

* Il y a deux sorties dans la section en surbrillance, chacune sérialisée comme indiqué dans &lt;<tx_out_structure>&gt;.
* La valeur de 0,015 bitcoin est de 1 500 000 satoshis. C&#39;est +16 e3 60+ en hexadécimal.
* Dans la transaction sérialisée, la valeur +16 e3 60+ est encodée dans l&#39;ordre d'octets petit-boutiste (octet le moins significatif en premier), elle ressemble donc à +60 e3 16+.
* La longueur de +scriptPubKey+ est de 25 octets, soit +19+ en hexadécimal.

[[tx_inputs]]
==== Entrées de transactions

(((&quot;transactions&quot;, &quot;sorties et entrées&quot;, &quot;composantes d&#39;entrée&quot;)))(((&quot;sorties et entrées&quot;, &quot;composantes d&#39;entrée&quot;)))(((&quot;sorties de transactions non dépensées (UTXO)&quot;))) (((&quot;Ensembles UTXO&quot;)))Les entrées de transaction identifient (par référence) quel UTXO sera consommé et fournissent une preuve de propriété via un script de déverrouillage.

Pour construire une transaction, un portefeuille sélectionne parmi l&#39;UTXO qu&#39;il contrôle, l&#39;UTXO avec une valeur suffisante pour effectuer le paiement demandé. Parfois un UTXO suffit, d&#39;autres fois plus d&#39;un est nécessaire. Pour chaque UTXO qui sera consommé pour effectuer ce paiement, le portefeuille crée une entrée pointant vers l&#39;UTXO et le déverrouille avec un script de déverrouillage.

Examinons plus en détail les composants d&#39;une entrée. La première partie d&#39;une entrée est un pointeur vers un UTXO par référence au hachage de transaction et à un index de sortie, qui identifie l&#39;UTXO spécifique dans cette transaction. La deuxième partie est un script de déverrouillage, que le portefeuille construit afin de satisfaire aux conditions de dépenses définies dans l&#39;UTXO. Le plus souvent, le script de déverrouillage est une signature numérique et une clé publique prouvant la propriété du bitcoin. Cependant, ce ne sont pas tous les scripts de déverrouillage qui contiennent une signature. La troisième partie est un numéro de séquence, qui sera discuté plus tard.

Considérez notre exemple dans &lt;<transactions_behind_the_scenes>&gt;. Les entrées de transaction sont un tableau (liste) appelé +vin+ :

[[vin]]
.Les entrées de transaction dans la transaction d&#39;Alice
[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
]
----

Comme vous pouvez le voir, il n&#39;y a qu&#39;une seule entrée dans la liste (car un UTXO contenait une valeur suffisante pour effectuer ce paiement). L&#39;entrée contient quatre éléments :

* Un (((&quot;ID de transaction (txd)&quot;)))ID de transaction, faisant référence à la transaction qui contient l&#39;UTXO dépensé
* Un index de sortie (+vout+), identifiant quel UTXO de cette transaction est référencé (le premier est zéro)
* Un +scriptSig+, qui satisfait aux conditions imposées à l&#39;UTXO, le déverrouillant pour les dépenses
* Un numéro de séquence (à discuter plus tard)

Dans la transaction d&#39;Alice, l&#39;entrée pointe vers l&#39;ID de transaction :

----
7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18
----

et l&#39;indice de sortie +0+ (c&#39;est-à-dire le premier UTXO créé par cette transaction). Le script de déverrouillage est construit par le portefeuille d&#39;Alice en récupérant d&#39;abord l&#39;UTXO référencé, en examinant son script de verrouillage, puis en l&#39;utilisant pour créer le script de déverrouillage nécessaire pour le satisfaire.

En regardant simplement l&#39;entrée, vous avez peut-être remarqué que nous ne savons rien de cet UTXO, à part une référence à la transaction parent qui le contient. Nous ne connaissons pas sa valeur (montant en satoshi), et nous ne connaissons pas le script de verrouillage qui fixe les conditions pour le dépenser. Pour retrouver ces informations, il faut récupérer l&#39;UTXO référencé en récupérant la transaction mère qui le contient. Notez que parce que la valeur de l&#39;entrée n&#39;est pas explicitement indiquée, nous devons également utiliser l&#39;UTXO référencé afin de calculer les frais qui seront payés dans cette transaction (voir &lt;<tx_fees>&gt;).

Ce n&#39;est pas seulement le portefeuille d&#39;Alice qui doit récupérer l&#39;UTXO référencé dans les entrées. Une fois cette transaction diffusée sur le réseau, chaque nœud de validation devra également récupérer l&#39;UTXO référencé dans les entrées de transaction afin de valider la transaction.

Les transactions en elles-mêmes semblent incomplètes car elles manquent de contexte. Elles référencent l'UTXO dans leurs entrées mais sans récupérer cet UTXO on ne peut pas connaître la valeur des entrées ni leurs conditions de verrouillage. Lors de l&#39;écriture d&#39;un logiciel bitcoin, chaque fois que vous décodez une transaction dans le but de la valider ou de compter les frais ou de vérifier le script de déverrouillage, votre code devra d&#39;abord récupérer l&#39;UTXO référencé de la blockchain afin de construire le contexte implicite mais non présent dans les références UTXO des entrées. Par exemple, pour calculer le montant payé en frais, vous devez connaître la somme des valeurs des entrées et des sorties. Mais sans récupérer les UTXO référencés dans les entrées, vous ne connaissez pas leur valeur. Ainsi, une opération apparemment simple comme le comptage des frais dans une seule transaction implique en fait plusieurs étapes et des données provenant de plusieurs transactions.

Nous pouvons utiliser la même séquence de commandes avec Bitcoin Core que celle que nous avons utilisée lors de la récupération de la transaction d&#39;Alice (+getrawtransaction+ et +decoderawtransaction+). Avec cela, nous pouvons obtenir l&#39;UTXO référencé dans l&#39;entrée de la transaction d&#39;Alice et jeter un œil :

[[alice_input_tx]]
.UTXO de la transaction précédente, référencé dans l&#39;entrée de la transaction d&#39;Alice
[source,json]
----
"vout": [
   {
     "value": 0.10000000,
     "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
   }
 ]
----

On voit que cet UTXO a une valeur de 0.1 BTC et qu&#39;il a un script de verrouillage (+scriptPubKey+) qui contient &quot;OP_DUP OP_HASH160...&quot;.

[TIP]
====
Pour bien comprendre la transaction d&#39;Alice, nous avons dû récupérer la transaction précédente référencée en entrée. Une fonction qui récupère les transactions précédentes et les sorties de transaction non dépensées est très courante et existe dans presque toutes les bibliothèques et API Bitcoin.
====

===== Sérialisation des transactions: entrées

(((&quot;sérialisation&quot;, &quot;entrées&quot;)))(((&quot;transactions&quot;, &quot;sorties et entrées&quot;, &quot;sérialisation des entrées&quot;)))(((&quot;sorties et entrées&quot;, &quot;sérialisation des entrées&quot;)))Lorsque les transactions sont sérialisées pour être transmises sur le réseau, leurs entrées sont codées dans un flux d&#39;octets comme indiqué dans &lt;<tx_in_structure>&gt;.

[[tx_in_structure]]
.Sérialisation des entrées de transaction
[options="header"]
|=======
|Taille| Champ | Description
| 32 octets | Hachage de transaction | Pointeur vers la transaction contenant l&#39;UTXO à dépenser
| 4 octets | Indice de sortie | Le numéro d&#39;index de l&#39;UTXO à dépenser ; le premier est 0
| 1–9 octets (VarInt) | Taille du script de déverrouillage | Longueur du script de déverrouillage en octets à suivre
| variables | Déverrouillage-Script | Un script remplissant les conditions du script de verrouillage UTXO
| 4 octets | Numéro de séquence | Utilisé pour le temps de verrouillage ou désactivé (0xFFFFFFFF)
|=======

Comme pour les sorties, voyons si nous pouvons trouver les entrées de la transaction d&#39;Alice au format sérialisé. Tout d&#39;abord, les entrées décodées :

[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
],
----

Voyons maintenant si nous pouvons identifier ces champs dans le codage hexadécimal sérialisé dans &lt;<example_6_2>&gt; :

[[example_6_2]]
.Transaction d&#39;Alice, sérialisée et présentée en notation hexadécimale
====
+0100000001+*+186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+*
*+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+*
*+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+*
*+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+*
*+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+*
*+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+*
*+7b4a10fa336a8d752adfffffffff+*+0260e31600000000001976a914ab6+
+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+
+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000+
+000+
====

Astuces:

* L&#39;ID de transaction est sérialisé dans l&#39;ordre inverse des octets, il commence donc par (hex) +18+ et se termine par +79+
* L&#39;index de sortie est un groupe de zéros de 4 octets, facile à identifier
* La longueur du +scriptSig+ est de 139 octets, soit +8b+ en hexadécimal
* Le numéro de séquence est défini sur +FFFFFFFF+, encore une fois facile à identifier(((&quot;&quot;, startref=&quot;alicesix&quot;)))

ScriptSig est un type spécifique de script de déverrouillage qui, lorsqu&#39;il est sérialisé pour être transmis sur le réseau, les entrées sont codées dans un flux d&#39;octets, comme indiqué dans &lt;<scriptsig_in_structure>&gt;. La sérialisation du champ signature est détaillée dans &lt;<seralization_of_signatures_der>&gt;. Le champ de signature comprend également un type de hachage de signature (SIGHASH), qui est détaillé dans &lt;<sighash_types>&gt;.

[[scriptsig_in_structure]]
.Sérialisation des entrées ScriptSig
[options="header"]
|=======
|Taille| Champ | Description
| 1–9 octets (VarInt) | Taille signature | Longueur de la signature en octets à suivre
| variables | signature | Une signature produite par le portefeuille de l&#39;utilisateur à partir de sa clé privée, qui comprend un SIGHASH
| 1–9 octets (VarInt) | Taille de la clé publique | Longueur de la clé publique en octets à suivre
| variables | Clé publique | La clé publique, non hachée
|=======

[[tx_fees]]
==== Frais de transaction

(((&quot;transactions&quot;, &quot;extrants et intrants&quot;, &quot;frais de transaction&quot;)))(((&quot;frais&quot;, &quot;frais de transaction&quot;)))(((&quot;minage et consensus&quot;, &quot;récompenses et frais&quot;)))La plupart des transactions incluent des frais de transaction, qui rémunèrent les mineurs de bitcoins pour la sécurisation du réseau. Les frais servent également de mécanisme de sécurité eux-mêmes, en rendant économiquement impossible pour les attaquants d&#39;inonder le réseau de transactions. L&#39;exploitation minière et les frais et récompenses perçus par les mineurs sont discutés plus en détail dans &lt;<mining>&gt;.

Cette section examine comment les frais de transaction sont inclus dans une transaction typique. La plupart des portefeuilles calculent et incluent automatiquement les frais de transaction. Toutefois, si vous créez des transactions par programmation ou à l&#39;aide d&#39;une interface de ligne de commande, vous devez comptabiliser et inclure manuellement ces frais.

Les frais de transaction servent d&#39;incitation à inclure (exploiter) une transaction dans le bloc suivant et également de dissuasion contre les abus du système en imposant un petit coût sur chaque transaction. Les frais de transaction sont perçus par le mineur qui exploite le bloc qui enregistre la transaction sur la chaîne de blocs.

Les frais de transaction sont calculés en fonction de la taille de la transaction en kilo-octets, et non de la valeur de la transaction en bitcoin. Dans l&#39;ensemble, les frais de transaction sont fixés en fonction des forces du marché au sein du réseau Bitcoin. Les mineurs hiérarchisent les transactions en fonction de nombreux critères différents, y compris les frais, et peuvent même traiter les transactions gratuitement dans certaines circonstances. Les frais de transaction affectent la priorité de traitement, ce qui signifie qu&#39;une transaction avec des frais suffisants est susceptible d&#39;être incluse dans le prochain bloc miné, alors qu&#39;une transaction avec des frais insuffisants ou nuls peut être retardée, traitée au mieux après quelques blocs, ou pas traité du tout. Les frais de transaction ne sont pas obligatoires et les transactions sans frais peuvent éventuellement être traitées ; cependant, l&#39;inclusion des frais de transaction encourage le traitement prioritaire.

Au fil du temps, la façon dont les frais de transaction sont calculés et leur effet sur la hiérarchisation des transactions ont évolué. Au départ, les frais de transaction étaient fixes et constants sur l&#39;ensemble du réseau. Progressivement, la structure tarifaire s&#39;est assouplie et peut être influencée par les forces du marché, en fonction de la capacité du réseau et du volume des transactions. Depuis au moins le début de 2016, les limites de capacité en bitcoin ont créé une concurrence entre les transactions, entraînant des frais plus élevés et faisant des transactions gratuites une chose du passé. Les transactions sans frais ou à très faibles frais sont rarement minées et parfois ne seront même pas propagées sur le réseau.

(((&quot;frais&quot;, &quot;politiques de relais des frais&quot;)))(((&quot;option minrelaytxfee&quot;)))Dans Bitcoin Core, les politiques de relais des frais sont définies par l&#39;option +minrelaytxfee+. Le +minrelaytxfee+ par défaut actuel est de 0,00001 bitcoin ou un centième de millibitcoin par kilooctet. Par conséquent, par défaut, les transactions dont les frais sont inférieurs à 0,00001 bitcoin sont traitées comme gratuites et ne sont relayées que s&#39;il y a de la place dans le mempool ; sinon, ils sont supprimés. Les nœuds Bitcoin peuvent remplacer la politique de relais de frais par défaut en ajustant la valeur de +minrelaytxfee+.

(((&quot;frais dynamiques&quot;)))(((&quot;frais&quot;, &quot;frais dynamiques&quot;)))Tout service bitcoin qui crée des transactions, y compris les portefeuilles, les échanges, les applications de vente au détail, etc., _doit_ implémenter des frais dynamiques. Les frais dynamiques peuvent être mis en œuvre via un service tiers d&#39;estimation des frais ou avec un algorithme d&#39;estimation des frais intégré. Si vous n&#39;êtes pas sûr, commencez par un service tiers et, à mesure que vous acquérez de l&#39;expérience, concevez et implémentez votre propre algorithme si vous souhaitez supprimer la dépendance tierce.

Les algorithmes d&#39;estimation des frais calculent les frais appropriés, en fonction de la capacité et des frais offerts par les transactions « concurrentes ». Ces algorithmes vont du simple (frais moyens ou médians dans le dernier bloc) au sophistiqué (analyse statistique). Ils estiment les frais nécessaires (en satoshis par octet) qui donneront à une transaction une forte probabilité d&#39;être sélectionnée et incluse dans un certain nombre de blocs. La plupart des services offrent aux utilisateurs la possibilité de choisir des frais de priorité élevés, moyens ou faibles. Une priorité élevée signifie que les utilisateurs paient des frais plus élevés, mais la transaction est susceptible d&#39;être incluse dans le bloc suivant. Une priorité moyenne et faible signifie que les utilisateurs paient des frais de transaction moins élevés, mais que la confirmation des transactions peut prendre beaucoup plus de temps.

(((&quot;bitcoinfees (service tiers)&quot;))) De nombreuses applications de portefeuille utilisent des services tiers pour le calcul des frais. Un service populaire est https://bitcoinfees.earn.com/[_https://bitcoinfees.earn.com/_], qui fournit une API et un graphique visuel montrant les frais en satoshi/octet pour différentes priorités.

[TIP]
====
(((&quot;frais statiques&quot;)))(((&quot;frais&quot;, &quot;frais statiques&quot;)))Les frais statiques ne sont plus viables sur le réseau Bitcoin. Les portefeuilles qui fixent des frais statiques produiront une mauvaise expérience utilisateur car les transactions seront souvent &quot;bloquées&quot; et resteront non confirmées. Les utilisateurs qui ne comprennent pas les transactions et les frais en bitcoins sont consternés par les transactions &quot;bloquées&quot; car ils pensent avoir perdu leur argent.
====

Le graphique en &lt;<bitcoinfeesearncom>&gt; affiche l&#39;estimation en temps réel des frais par incréments de 10 satoshi/octet et le temps de confirmation attendu (en minutes et en nombre de blocs) pour les transactions avec des frais dans chaque plage. Pour chaque fourchette de frais (par exemple, 61 à 70 satoshi/octet), deux barres horizontales indiquent le nombre de transactions non confirmées (1 405) et le nombre total de transactions au cours des dernières 24 heures (102 975), avec des frais compris dans cette fourchette. Sur la base du graphique, les frais de haute priorité recommandés à ce moment étaient de 80 satoshi/octet, des frais susceptibles d&#39;entraîner l&#39;inclusion de la transaction dans le bloc suivant (délai de bloc nul). Pour la perspective, la taille médiane des transactions est de 226 octets, donc les frais recommandés pour cette taille de transaction seraient de 18 080 satoshis (0,00018080 BTC).

Les données d&#39;estimation des frais peuvent être récupérées via une simple API HTTP REST, à l&#39;adresse https://bitcoinfees.earn.com/api/v1/fees/recommended[https://bitcoinfees.earn.com/api/v1/fees/recommended ]. Par exemple, sur la ligne de commande en utilisant la commande +curl+ :

.Utilisation de l&#39;API d&#39;estimation des frais
----
$ curl https://bitcoinfees.earn.com/api/v1/fees/recommended

{"fastestFee":80,"halfHourFee":80,"hourFee":60}
----

L&#39;API renvoie un objet JSON avec l&#39;estimation actuelle des frais pour la confirmation la plus rapide (+fastestFee+), la confirmation dans les trois blocs (+halfHourFee+) et six blocs (+hourFee+), en satoshi par octet.

[[bitcoinfeesearncom]]
.Service d&#39;estimation des frais bitcoinfees.earn.com
image::images/mbc2_0602.png[Service d&#39;estimation des frais bitcoinfees.earn.com]

==== Ajout de frais aux transactions

La structure de données des transactions n&#39;a pas de champ pour les frais. Au lieu de cela, les frais sont implicites comme la différence entre la somme des entrées et la somme des sorties. Tout montant excédentaire qui reste après que toutes les sorties ont été déduites de toutes les entrées est la redevance perçue par les mineurs :

[[tx_fee_equation]]
.Les frais de transaction sont implicites, comme l&#39;excédent des intrants moins les extrants :
----
Frais = Somme(intrants) - Somme(extrants)
----

Il s&#39;agit d&#39;un élément quelque peu déroutant des transactions et d&#39;un point important à comprendre, car si vous construisez vos propres transactions, vous devez vous assurer de ne pas inclure par inadvertance des frais très importants en sous-dépensant les intrants. Cela signifie que vous devez comptabiliser toutes les entrées, si nécessaire en créant du change, ou vous finirez par donner un très gros pourboire aux mineurs !

Par exemple, si vous consommez un UTXO de 20 bitcoins pour effectuer un paiement de 1 bitcoin, vous devez inclure une sortie de modification de 19 bitcoins dans votre portefeuille. Sinon, le &quot;reste&quot; de 19 bitcoins sera compté comme des frais de transaction et sera collecté par le mineur qui exploite votre transaction dans un bloc. Bien que vous receviez un traitement prioritaire et rendiez un mineur très heureux, ce n&#39;est probablement pas ce que vous vouliez.

[WARNING]
====
(((&quot;avertissements et mises en garde&quot;, &quot;modifier les sorties&quot;))) Si vous oubliez d&#39;ajouter une sortie de modification dans une transaction construite manuellement, vous paierez la modification en tant que frais de transaction. Dire &quot;Gardez la monnaie !&quot; au mineur n&#39;est peut-être pas ce que vous vouliez vraiment.
====

(((&quot;cas d&#39;utilisation&quot;, &quot;achat de café&quot;))) Voyons comment cela fonctionne en pratique, en examinant à nouveau l&#39;achat de café d&#39;Alice. Alice veut dépenser 0,015 bitcoin pour payer son café. Pour s&#39;assurer que cette transaction est traitée rapidement, elle voudra inclure des frais de transaction, disons 0,0005. Cela signifie que le coût total de la transaction sera de 0,0155. Son portefeuille doit donc se procurer un ensemble d&#39;UTXO qui totalise 0,0155 bitcoin ou plus et, si nécessaire, créer de la monnaie. Disons que son portefeuille dispose d&#39;un UTXO de 0,1 bitcoin. Elle devra donc consommer cet UTXO, créer une sortie pour le comptoir à café de Bob pour 0,015, et une seconde sortie avec 0,0845 bitcoin en retour vers son propre portefeuille, laissant 0,0005 bitcoin non alloué, comme frais implicites pour la transaction.

(((&quot;cas d&#39;utilisation&quot;, &quot;dons caritatifs&quot;)))(((&quot;dons caritatifs&quot;)))Regardons maintenant un scénario différent. Eugenia, directrice de notre association caritative pour enfants aux Philippines, a organisé une collecte de fonds pour acheter des manuels scolaires pour les enfants. Elle a reçu plusieurs milliers de petits dons de personnes du monde entier, totalisant 50 bitcoins, donc son portefeuille est plein de très petits paiements (UTXO). Maintenant, elle veut acheter des centaines de manuels scolaires auprès d&#39;un éditeur local, en payant en bitcoins.

Alors que l&#39;application de portefeuille d&#39;Eugenia tente de construire une seule transaction de paiement plus importante, elle doit s&#39;approvisionner à partir de l&#39;ensemble UTXO disponible, qui est composé de nombreux montants plus petits. Cela signifie que la transaction résultante proviendra de plus d&#39;une centaine d&#39;UTXO de petite valeur en tant qu&#39;entrées et d&#39;une seule sortie, payant l&#39;éditeur du livre. Une transaction avec autant d&#39;entrées sera supérieure à un kilo-octet, peut-être plusieurs kilo-octets. En conséquence, cela nécessitera des frais beaucoup plus élevés que la transaction de taille médiane.

L&#39;application de portefeuille d&#39;Eugenia calculera les frais appropriés en mesurant la taille de la transaction et en la multipliant par les frais par kilo-octet. De nombreux portefeuilles surpayeront les frais pour les transactions plus importantes afin de s&#39;assurer que la transaction est traitée rapidement. Les frais plus élevés ne sont pas dus au fait qu&#39;Eugenia dépense plus d&#39;argent, mais au fait que sa transaction est plus complexe et plus volumineuse - les frais sont indépendants de la valeur en bitcoins de la transaction.(((&quot;&quot;, startref=&quot;Tout06&quot;)))

[[tx_script]]
[role="pagebreak-before less_space_h1"]
=== Scripts de transaction et langage de script

(((&quot;transactions&quot;, &quot;scripts et langage de script&quot;, id=&quot;Tsript06&quot;)))(((&quot;scriptage&quot;, &quot;transactions et&quot;, id=&quot;Stransact06&quot;)))Le langage de script de transaction bitcoin, appelé _Script_ , est un langage d&#39;exécution basé sur une pile de notation polonaise inversée (RPN) de type Forth. Si cela ressemble à du charabia, vous n&#39;avez probablement pas étudié les langages de programmation des années 1960, mais ce n&#39;est pas grave, nous vous expliquerons tout dans ce chapitre. Le script de verrouillage placé sur un UTXO et le script de déverrouillage sont écrits dans ce langage de script. Lorsqu&#39;une transaction est validée, le script de déverrouillage de chaque entrée est exécuté parallèlement au script de verrouillage correspondant pour voir s&#39;il satisfait à la condition de dépense.

Script est un langage très simple qui a été conçu pour être limité dans sa portée et être exécutable sur une gamme de matériel et peut être aussi simple qu&#39;un périphérique intégré. Il nécessite un traitement minimal et ne peut pas faire la plupart des choses fantaisistes que les langages de programmation modernes peuvent faire. Pour son utilisation dans la validation de monnaie programmable, il s&#39;agit d&#39;une fonction de sécurité délibérée.

(((&quot;Pay-to-Public-Key-Hash (P2PKH)&quot;)))Aujourd&#39;hui, la plupart des transactions traitées via le réseau Bitcoin ont la forme &quot;Paiement à l&#39;adresse Bitcoin de Bob&quot; et sont basées sur un script appelé Pay-to-Script Public-Key-Hash. Cependant, les transactions bitcoin ne se limitent pas au script &quot;Paiement à l&#39;adresse Bitcoin de Bob&quot;. En fait, les scripts de verrouillage peuvent être écrits pour exprimer une grande variété de conditions complexes. Afin de comprendre ces scripts plus complexes, nous devons d&#39;abord comprendre les bases des scripts de transaction et du langage de script.

Dans cette section, nous démontrerons les composants de base du langage de script de transaction bitcoin et montrerons comment il peut être utilisé pour exprimer des conditions simples de dépenses et comment ces conditions peuvent être satisfaites en déverrouillant des scripts.

[TIP]
====
(((&quot;argent programmable&quot;)))La validation des transactions Bitcoin n&#39;est pas basée sur un modèle statique, mais est plutôt obtenue grâce à l&#39;exécution d&#39;un langage de script. Ce langage permet d&#39;exprimer une variété presque infinie de conditions. C&#39;est ainsi que le bitcoin obtient le pouvoir de &quot;l&#39;argent programmable&quot;.
====


==== Incomplétude de Turing

(((&quot;Turing incomplétude&quot;)))Le langage de script de transaction bitcoin contient de nombreux opérateurs, mais est délibérément limité d&#39;une manière importante : il n&#39;y a pas de boucles ou de capacités de contrôle de flux complexes autres que le contrôle de flux conditionnel. Cela garantit que le langage n&#39;est pas _Turing complet_, ce qui signifie que les scripts ont une complexité limitée et des temps d&#39;exécution prévisibles. Le script n&#39;est pas un langage universel. (((&quot;attaques par déni de service&quot;)))(((&quot;attaques par déni de service&quot;, see=&quot;aussi sécurité&quot;)))(((&quot;sécurité&quot;, &quot;attaques par déni de service&quot; )))Ces limitations garantissent que le langage ne peut pas être utilisé pour créer une boucle infinie ou une autre forme de &quot;bombe logique&quot; qui pourrait être intégrée dans une transaction de manière à provoquer une attaque par déni de service contre le réseau Bitcoin. N&#39;oubliez pas que chaque transaction est validée par chaque nœud complet du réseau Bitcoin. Un langage limité empêche le mécanisme de validation des transactions d&#39;être utilisé comme une vulnérabilité.

==== Vérification sans état

(((&quot;vérification sans état&quot;)))Le langage de script de transaction bitcoin est sans état, en ce sens qu&#39;il n&#39;y a pas d&#39;état avant l&#39;exécution du script, ou d&#39;état enregistré après l&#39;exécution du script. Par conséquent, toutes les informations nécessaires à l&#39;exécution d&#39;un script sont contenues dans le script. Un script s&#39;exécutera de manière prévisible de la même manière sur n&#39;importe quel système. Si votre système vérifie un script, vous pouvez être sûr que tous les autres systèmes du réseau Bitcoin vérifieront également le script, ce qui signifie qu&#39;une transaction valide est valide pour tout le monde et tout le monde le sait. Cette prévisibilité des résultats est un avantage essentiel du système Bitcoin.

[[tx_lock_unlock]]
==== Construction du script (Verrouiller + Déverrouiller)

Le moteur de validation des transactions de Bitcoin s&#39;appuie sur deux types de scripts pour valider les transactions : un script de verrouillage et un script de déverrouillage.

(((&quot;scripts de verouillage&quot;)))(((&quot;scripts de déverouillage&quot;)))(((&quot;scriptage&quot;, &quot;scripts de déverouillage&quot;)))Un script de verrouillage est une condition de dépense placée sur une sortie : il spécifie les conditions qui doivent être remplies pour dépenser la production à l&#39;avenir. (((&quot;scriptPubKey&quot;)))Historiquement, le script de verrouillage était appelé _scriptPubKey_, car il contenait généralement une clé publique ou une adresse Bitcoin (hachage de clé publique). Dans ce livre, nous l&#39;appelons un &quot;script de verrouillage&quot; pour reconnaître l&#39;éventail de possibilités beaucoup plus large de cette technologie de script. Dans la plupart des applications bitcoin, ce que nous appelons un script de verrouillage apparaîtra dans le code source sous la forme +scriptPubKey+. (((&quot;témoins&quot;)))(((&quot;énigmes cryptographiques&quot;)))Vous verrez également le script de verrouillage appelé _script de témoin_ (voir &lt;<segwit>&gt;) ou plus généralement comme un _casse-tête cryptographique_. Ces termes signifient tous la même chose, à différents niveaux d&#39;abstraction.

Un script de déverrouillage est un script qui « résout », ou satisfait, les conditions placées sur une sortie par un script de verrouillage et permet à la sortie d&#39;être dépensée. Les scripts de déverrouillage font partie de chaque entrée de transaction. Ils contiennent la plupart du temps une signature numérique produite par le portefeuille de l&#39;utilisateur à partir de sa clé privée. (((&quot;scriptSig&quot;)))Historiquement, le script de déverrouillage s&#39;appelait _scriptSig_, car il contenait généralement une signature numérique. Dans la plupart des applications bitcoin, le code source fait référence au script de déverrouillage sous la forme +scriptSig+. Vous verrez également le script de déverrouillage appelé _témoin_ (voir &lt;<segwit>&gt;). Dans ce livre, nous l&#39;appelons un &quot;script de déverrouillage&quot; pour reconnaître la gamme beaucoup plus large d&#39;exigences de script de verrouillage, car ce n'est pas tous les scripts de déverrouillage qui doivent contenir des signatures.

Chaque nœud de validation Bitcoin validera les transactions en exécutant les scripts de verrouillage et de déverrouillage ensemble. Chaque entrée contient un script de déverrouillage et fait référence à un UTXO existant précédemment. Le logiciel de validation copiera le script de déverrouillage, récupérera l&#39;UTXO référencé par l&#39;entrée et copiera le script de verrouillage à partir de cet UTXO. Les scripts de déverrouillage et de verrouillage sont ensuite exécutés en séquence. L&#39;entrée est valide si le script de déverrouillage satisfait les conditions du script de verrouillage (voir &lt;<script_exec>&gt;). Toutes les entrées sont validées indépendamment, dans le cadre de la validation globale de la transaction.

Notez que l&#39;UTXO est enregistré en permanence dans la blockchain, et est donc invariable et n&#39;est pas affecté par les tentatives infructueuses de le dépenser par référence dans une nouvelle transaction. Seule une transaction valide qui satisfait correctement les conditions de la sortie entraîne que la sortie est considérée comme &quot;dépensée&quot; et retirée de l&#39;ensemble des sorties de transaction non dépensées (ensemble UTXO).

&lt;<scriptSig_and_scriptPubKey>&gt; est un exemple des scripts de déverrouillage et de verrouillage pour le type de transaction bitcoin le plus courant (un paiement à un hachage de clé publique), montrant le script combiné résultant de la concaténation des scripts de déverrouillage et de verrouillage avant la validation du script.

[[scriptSig_and_scriptPubKey]]
.Combiner scriptSig et scriptPubKey pour évaluer un script de transaction
image::images/mbc2_0603.png[&quot;scriptSig_and_scriptPubKey&quot;]

===== La pile d&#39;exécution de script

Le langage de script de Bitcoin est appelé un langage basé sur la pile car il utilise une structure de données appelée _pile_. Une pile est une structure de données très simple qui peut être visualisée comme une pile de cartes. Une pile permet deux opérations : push et pop. Push ajoute un élément au sommet de la pile. Pop supprime l&#39;élément du haut de la pile. Les opérations sur une pile ne peuvent agir que sur l&#39;élément le plus haut de la pile. Une structure de données de pile est également appelée file d&#39;attente Last-In-First-Out (dernier entré, premier sorti), ou &quot;LIFO&quot;.

Le langage de script exécute le script en traitant chaque élément de gauche à droite. Les nombres (constantes de données) sont poussés sur la pile. Les opérateurs poussent ou sortent un ou plusieurs paramètres de la pile, agissent sur eux et peuvent pousser un résultat sur la pile. Par exemple, +OP_ADD+ fera sortir deux éléments de la pile, les ajoutera et poussera la somme résultante sur la pile.

Les opérateurs conditionnels évaluent une condition, produisant un résultat booléen VRAI (TRUE) ou FAUX (FALSE). Par exemple, +OP_EQUAL+ dépile deux éléments de la pile et pousse TRUE (TRUE est représenté par le nombre 1) s&#39;ils sont égaux ou FALSE (représenté par zéro) s&#39;ils ne sont pas égaux. Les scripts de transaction Bitcoin contiennent généralement un opérateur conditionnel, afin qu&#39;ils puissent produire le résultat VRAI qui signifie une transaction valide.

===== Un script simple

Appliquons maintenant ce que nous avons appris sur les scripts et les piles à quelques exemples simples.

Dans &lt;<simplemath_script>&gt;, le script +2 3 OP_ADD 5 OP_EQUAL+ démontre l&#39;opérateur d&#39;addition arithmétique +OP_ADD+, additionnant deux nombres et mettant le résultat sur la pile, suivi de l&#39;opérateur conditionnel +OP_EQUAL+, qui vérifie que la somme résultante est égale à +5+. Par souci de brièveté, le préfixe +OP_+ est omis dans l&#39;exemple étape par étape. Pour plus de détails sur les opérateurs de script et les fonctions disponibles, voir &lt;<tx_script_ops>&gt;.

Bien que la plupart des scripts de verrouillage se réfèrent à un hachage de clé publique (essentiellement, une adresse Bitcoin), nécessitant ainsi une preuve de propriété pour dépenser les fonds, le script n&#39;a pas besoin d&#39;être aussi complexe. Toute combinaison de scripts de verrouillage et de déverrouillage donnant une valeur TRUE est valide. L&#39;arithmétique simple que nous avons utilisée comme exemple de langage de script est également un script de verrouillage valide qui peut être utilisé pour verrouiller une sortie de transaction.

Utilisez une partie de l&#39;exemple de script arithmétique comme script de verrouillage :

----
3 OP_ADD 5 OP_EQUAL
----

qui peut être satisfaite par une transaction contenant une entrée avec le script de déverrouillage :

----
2
----

Le logiciel de validation combine les scripts de verrouillage et de déverrouillage et le script résultant est :

----
2 3 OP_ADD 5 OP_EQUAL
----

Comme nous l&#39;avons vu dans l&#39;exemple étape par étape dans &lt;<simplemath_script>&gt;, lorsque ce script est exécuté, le résultat est +OP_TRUE+, rendant la transaction valide. Non seulement il s&#39;agit d&#39;un script de verrouillage de sortie de transaction valide, mais l&#39;UTXO résultant pourrait être dépensé par toute personne ayant les compétences en arithmétique pour savoir que le nombre 2 satisfait le script.

[TIP]
====
(((&quot;transactions&quot;, &quot;valide et invalide&quot;)))Les transactions sont valides si le premier résultat de la pile est +TRUE+ (noté ++{0x01}++), toute autre valeur différente de zéro, autre que +OP_0+, ou si la pile est vide après l&#39;exécution du script. Les transactions ne sont pas valides si la valeur supérieure de la pile est +FALSE+ (une valeur vide de longueur nulle, notée ++{}++) ou si l&#39;exécution du script est arrêtée explicitement par un opérateur, tel que +OP_VERIFY+, +OP_RETURN+ ou un terminateur conditionnel tel que +OP_ENDIF+. Voir &lt;<tx_script_ops>&gt; pour plus de détails.
====

[[simplemath_script]]
.La validation du script Bitcoin en calculs simples
image::images/mbc2_0604.png[&quot;TxScriptSimpleMathExample&quot;]

[role="pagebreak-before"]
Ce qui suit est un script légèrement plus complexe, qui calcule ++2 + 7 - 3 + 1++. Notez que lorsque le script contient plusieurs opérateurs à la suite, la pile permet aux résultats d&#39;un opérateur d&#39;être appliqués par l&#39;opérateur suivant :

----
2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL
----

Essayez de valider vous-même le script précédent à l&#39;aide d&#39;un crayon et de papier. Lorsque l&#39;exécution du script se termine, vous devriez vous retrouver avec la valeur +TRUE+ sur la pile.

[[script_exec]]
===== Exécution séparée des scripts de déverrouillage et de verrouillage

(((&quot;sécurité&quot;, &quot;scripts de verrouillage et de déverrouillage&quot;)))Dans le client Bitcoin d&#39;origine, les scripts de déverrouillage et de verrouillage étaient concaténés et exécutés en séquence. Pour des raisons de sécurité, cela a été modifié en 2010, en raison d&#39;une vulnérabilité qui permettait à un script de déverrouillage malformé de pousser des données sur la pile et de corrompre le script de verrouillage. Dans l&#39;implémentation actuelle, les scripts sont exécutés séparément avec la pile transférée entre les deux exécutions, comme décrit ci-après.

Tout d&#39;abord, le script de déverrouillage est exécuté à l&#39;aide du moteur d&#39;exécution de la pile. Si le script de déverrouillage est exécuté sans erreur (par exemple, s&#39;il ne reste plus de pointeurs &quot; pendants&quot;), la pile principale est copiée et le script de verrouillage est exécuté. Si le résultat de l&#39;exécution du script de verrouillage avec les données de la pile copiées à partir du script de déverrouillage est &quot;TRUE&quot;, le script de déverrouillage a réussi à résoudre les conditions imposées par le script de verrouillage et, par conséquent, l&#39;entrée est une autorisation valide de dépenser l&#39;UTXO. S&#39;il reste un résultat autre que &quot;TRUE&quot; après l&#39;exécution du script combiné, l&#39;entrée est invalide car elle n&#39;a pas satisfait aux conditions de dépenses placées sur l&#39;UTXO.


[[p2pkh]]
==== Pay-to-Public-Key-Hash (P2PKH)

(((&quot;Pay-to-Public-Key-Hash (P2PKH)&quot;)))La grande majorité des transactions traitées sur le réseau Bitcoin dépensent des sorties verrouillées avec un script Pay-to-Public-Key-Hash ou &quot;P2PKH&quot;. Ces sorties contiennent un script de verrouillage qui verrouille la sortie sur un hachage de clé publique, plus communément appelé adresse Bitcoin. Une sortie verrouillée par un script P2PKH peut être déverrouillée (passée) en présentant une clé publique et une signature numérique créée par la clé privée correspondante (voir &lt;<digital_sigs>&gt;).

(((&quot;cas d&#39;utilisation&quot;, &quot;acheter du café&quot;)))Par exemple, regardons à nouveau le paiement d&#39;Alice au comptoir à café de Bob. Alice a effectué un paiement de 0,015 bitcoin à l&#39;adresse Bitcoin du comptoir. Cette sortie de transaction aurait un script de verrouillage de la forme :

----
OP_DUP OP_HASH160 <Cafe Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
----

Le +Cafe Public Key Hash+ équivaut à l&#39;adresse Bitcoin du café, sans l&#39;encodage Base58Check. La plupart des applications afficheraient le _hachage de la clé publique_ en codage hexadécimal et non le format familier de l&#39;adresse Bitcoin Base58Check qui commence par un &quot;1&quot;.

Le script de verrouillage précédent peut se contenter d&#39;un script de déverrouillage de la forme :

----
<Cafe Signature> <Cafe Public Key>
----

Les deux scripts ensemble formeraient le script de validation combiné suivant :

----
<Cafe Signature> <Cafe Public Key> OP_DUP OP_HASH160
<Cafe Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
----

Lorsqu&#39;il est exécuté, ce script combiné sera évalué à TRUE si, et seulement si, le script de déverrouillage correspond aux conditions définies par le script de verrouillage. En d&#39;autres termes, le résultat sera VRAI si le script de déverrouillage a une signature valide de la clé privée du comptoir qui correspond au hachage de la clé publique défini comme encombrement.

Les figures pass:[<a data-type="xref" href="#P2PubKHash1" data-xrefstyle="select: labelnumber">#P2PubKHash1</a>] et pass:[<a data-type="xref" href="#P2PubKHash2" data-xrefstyle="select: labelnumber">#P2PubKHash2</a>] montrent (en deux parties) une exécution pas à pas du script combiné, qui prouvera qu&#39;il s&#39;agit d&#39;une transaction valide.(((&quot;&quot;, startref=&quot; Tsript06&quot;)))(((&quot;&quot;, startref=&quot;Stransact06&quot;)))

[[P2PubKHash1]]
.Évaluer un script pour une transaction P2PKH (partie 1 sur 2)
image::images/mbc2_0605.png["Tx_Script_P2PubKeyHash_1"]

[[P2PubKHash2]]
.Évaluer un script pour une transaction P2PKH (partie 2 sur 2)
image::images/mbc2_0606.png["Tx_Script_P2PubKeyHash_2"]

[[digital_sigs]]
=== Signatures numériques (ECDSA)

(((&quot;transactions&quot;, &quot;signatures numériques et&quot;, id=&quot;Tdigsig06&quot;)))Jusqu&#39;à présent, nous n&#39;avons approfondi aucun détail sur les &quot;signatures numériques&quot;. Dans cette section, nous examinons le fonctionnement des signatures numériques et comment elles peuvent présenter la preuve de la propriété d&#39;une clé privée sans révéler cette clé privée.

(((&quot;signatures numériques&quot;, &quot;algorithme utilisés&quot;)))(((&quot;Elliptic Curve Digital Signature Algorithm (ECDSA)&quot;)))L&#39;algorithme de signature numérique utilisé dans le bitcoin est l&#39;_Elliptic Curve Digital Signature Algorithm_, ou _ECDSA_. ECDSA est l&#39;algorithme utilisé pour les signatures numériques basées sur des paires de clés privées/publiques à courbe elliptique, comme décrit dans &lt;<elliptic_curve>&gt;. ECDSA est utilisé par les fonctions de script +OP_CHECKSIG+, +OP_CHECKSIGVERIFY+, +OP_CHECKMULTISIG+ et +OP_CHECKMULTISIGVERIFY+. Chaque fois que vous les voyez dans un script de verrouillage, le script de déverrouillage doit contenir une signature ECDSA.

(((&quot;signatures numériques&quot;, &quot;objectifs de&quot;))) Une signature numérique a trois objectifs en bitcoin. Premièrement, la signature prouve que le propriétaire de la clé privée, qui est implicitement le propriétaire des fonds, a _autorisé_ la dépense de ces fonds. Deuxièmement, la preuve de l&#39;autorisation est _indéniable_ (non-répudiable). Troisièmement, la signature prouve que la transaction (ou des parties spécifiques de la transaction) n&#39;a pas et _ne peut pas être modifiée_ par qui que ce soit après avoir été signée.

Notez que chaque entrée de transaction est signée indépendamment. Ceci est essentiel, car ni les signatures ni les entrées ne doivent appartenir ou être appliquées par les mêmes &quot;propriétaires&quot;. En fait, un schéma de transaction spécifique appelé &quot;CoinJoin&quot; utilise ce fait pour créer des transactions multipartites pour la confidentialité.

[NOTE]
====
Chaque entrée de transaction et toute signature qu&#39;elle peut contenir est _complètement_ indépendante de toute autre entrée ou signature. Plusieurs parties peuvent collaborer pour construire des transactions et signer une seule entrée chacune.
====

[[digital_signature_definition]]
.Définition de Wikipedia d&#39;une &quot;signature numérique&quot;
****
(((&quot;signatures numériques&quot;, &quot;défini&quot;)))Une signature numérique est un schéma mathématique permettant de démontrer l&#39;authenticité d&#39;un message ou de documents numériques. Une signature numérique valide donne au destinataire des raisons de croire que le message a été créé par un expéditeur connu (authentification), que l&#39;expéditeur ne peut pas nier avoir envoyé le message (non-répudiable) et que le message n&#39;a pas été altéré en transit (intégrité).

_Source: https://en.wikipedia.org/wiki/Digital_signature_
****

==== Comment fonctionnent les signatures numériques

(((&quot;signatures numériques&quot;, &quot;comment elles fonctionnent&quot;)))Une signature numérique est un _schéma mathématique_ qui se compose de deux parties. La première partie est un algorithme de création d&#39;une signature, à l&#39;aide d&#39;une clé privée (la clé de signature), à partir d&#39;un message (la transaction). La deuxième partie est un algorithme qui permet à quiconque de vérifier la signature, étant donné également le message et une clé publique.

===== Création d&#39;une signature numérique

Dans l&#39;implémentation de l&#39;algorithme ECDSA par bitcoin, le &quot;message&quot; signé est la transaction, ou plus précisément un hachage d&#39;un sous-ensemble spécifique des données de la transaction (voir &lt;<sighash_types>&gt;). La clé de signature est la clé privée de l&#39;utilisateur. Le résultat est la signature :

latexmath:[\(Sig = F_{sig}(F_{hash}(m), dA)\)]

où:

* _dA_ est la clé privée de signature
* _m_ est la transaction (ou une partie de celle-ci)
* _F_~_hash_~ est la fonction de hachage
* _F_~_sig_~ est l&#39;algorithme de signature
* _Sig_ est la signature résultante

Plus de détails sur les mathématiques d&#39;ECDSA peuvent être trouvés dans &lt;<ecdsa_math>&gt;.

La fonction _F_~_sig_~ produit une signature +Sig+ composée de deux valeurs, communément appelées +R+ et +S+ :

----
Sig = (R, S)
----

(((&quot;Distinguished Encoding Rules (DER)&quot;))) Maintenant que les deux valeurs +R+ et +S+ ont été calculées, elles sont sérialisées en un flux d&#39;octets à l&#39;aide d&#39;un schéma de codage standard international appelé _Distinguished Encoding Rules_, ou _DER_ (ou règles d'encodage distingués).

[[seralization_of_signatures_der]]
===== Sérialisation des signatures (DER)

Regardons la transaction Alice (((&quot;cas d'utilisation&quot;, &quot;achat d'un café&quot;, id=&quot;alicesixtwo&quot;)))créée à nouveau. Dans l&#39;entrée de transaction, il y a un script de déverrouillage qui contient la signature encodée DER suivante du portefeuille d&#39;Alice :

----
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e38133
----

Cette signature est un flux d&#39;octets sérialisé des valeurs +R+ et +S+ produites par le portefeuille d&#39;Alice pour prouver qu&#39;elle possède la clé privée autorisée à dépenser cette sortie. Le format de sérialisation se compose de neuf éléments comme suit :

* +0x30+—indiquant le début d&#39;une séquence DER
* +0x45+—la longueur de la séquence (69 octets)
  * +0x02+—une valeur entière suit
  * +0x21+—la longueur de l&#39;entier (33 octets)
  * +R+—++00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb++
  * +0x02+—un autre entier suit
  * +0x20+—la longueur de l&#39;entier (32 octets)
  * +S+—++4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813++
* Un suffixe (+0x01+) indiquant le type de hachage utilisé (+SIGHASH_ALL+)

Voyez si vous pouvez décoder la signature sérialisée (encodée en DER) d&#39;Alice en utilisant cette liste. Les nombres importants sont +R+ et +S+ ; le reste des données fait partie du schéma de codage DER.

==== Vérification de la signature

(((&quot;digital signatures&quot;, &quot;verifying&quot;)))Pour vérifier la signature, il faut avoir la signature (+R+ et +S+), la transaction sérialisée, et la clé publique (qui correspond à la clé privée utilisée pour créer la signature). Essentiellement, la vérification d&#39;une signature signifie &quot;Seul le propriétaire de la clé privée qui a généré cette clé publique pourrait avoir produit cette signature sur cette transaction.&quot;

L&#39;algorithme de vérification de signature prend le message (un hachage de la transaction ou de parties de celui-ci), la clé publique du signataire et la signature (+ valeurs R+ et +S+), et renvoie TRUE si la signature est valide pour ce message et cette clé publique.

[[sighash_types]]
==== Types de hachage de signature (SIGHASH)

(((&quot;signatures numériques&quot;, &quot;signature hash types&quot;)))(((&quot;commitment&quot;)))Les signatures numériques sont appliquées aux messages, qui dans le cas du bitcoin, sont les transactions elles-mêmes. La signature implique un _engagement_ du signataire sur des données de transaction spécifiques. Dans sa forme la plus simple, la signature s&#39;applique à l&#39;ensemble de la transaction, engageant ainsi toutes les entrées, sorties et autres champs de transaction. Cependant, une signature ne peut s&#39;engager que sur un sous-ensemble des données d&#39;une transaction, ce qui est utile pour un certain nombre de scénarios, comme nous le verrons dans cette section.

(((&quot;drapeau SIGHASH&quot;)))Les signatures Bitcoin ont un moyen d&#39;indiquer quelle partie des données d&#39;une transaction est incluse dans le hachage signé par la clé privée à l&#39;aide d&#39;un drapeau +SIGHASH+. Le drapeau +SIGHASH+ est un octet unique ajouté à la signature. Chaque signature a un drapeau +SIGHASH+ et le drapeau peut être différent d&#39;une entrée à l&#39;autre. Une transaction avec trois entrées signées peut avoir trois signatures avec des drapeaux +SIGHASH+ différents, chaque signature signant (committant) différentes parties de la transaction.

N&#39;oubliez pas que chaque entrée peut contenir une signature dans son script de déverrouillage. Par conséquent, une transaction qui contient plusieurs entrées peut avoir des signatures avec différents indicateurs +SIGHASH+ qui valident différentes parties de la transaction dans chacune des entrées. Notez également que les transactions bitcoin peuvent contenir des entrées de différents &quot;propriétaires&quot;, qui ne peuvent signer qu&#39;une seule entrée dans une transaction partiellement construite (et invalide), collaborant avec d&#39;autres pour rassembler toutes les signatures nécessaires pour effectuer une transaction valide. De nombreux types d&#39;indicateurs +SIGHASH+ n&#39;ont de sens que si vous pensez à plusieurs participants collaborant en dehors du réseau Bitcoin et mettant à jour une transaction partiellement signée.

[role="pagebreak-before"]
Il existe trois indicateurs +SIGHASH+ : +ALL+, +NONE+ et +SINGLE+, comme indiqué dans &lt;<sighash_types_and_their>&gt;.

[[sighash_types_and_their]]
.Types SIGHASH et leurs significations
[options="header"]
|=======================
|Drapeau +SIGHASH+| Valeur | Description
| +TOUS+ | 0x01 | La signature s&#39;applique à toutes les entrées et sorties
| +AUCUN+ | 0x02 | La signature s&#39;applique à toutes les entrées, aucune des sorties
| +SIMPLE+ | 0x03 | La signature s&#39;applique à toutes les entrées mais uniquement à la sortie avec le même numéro d&#39;index que l&#39;entrée signée
|=======================

De plus, il existe un drapeau modificateur +SIGHASH_ANYONECANPAY+, qui peut être combiné avec chacun des drapeaux précédents. Lorsque +ANYONECANPAY+ est défini, une seule entrée est signée, laissant le reste (et leurs numéros de séquence) ouverts pour modification. Le +ANYONECANPAY+ a la valeur +0x80+ et est appliqué par OR au niveau du bit, ce qui donne les drapeaux combinés comme indiqué dans &lt;<sighash_types_with_modifiers>&gt;.

[[sighash_types_with_modifiers]]
.Types SIGHASH avec modificateurs et leurs significations
[options="header"]
|=======================
|Drapeau SIGHASH| Valeur | Description
| ALL\|ANYONECANPAY | 0x81 | La signature s&#39;applique à une entrée et à toutes les sorties
| NONE\|ANYONECANPAY | 0x82 | La signature s&#39;applique à une entrée, aucune des sorties
| SINGLE\|ANYONECANPAY | 0x83 | La signature s&#39;applique à une entrée et à la sortie avec le même numéro d&#39;index
|=======================

Ces combinaisons de drapeaux sont résumées dans &lt;<sighash_combinations>&gt;.

[[sighash_combinations]]
.Résumé des différentes combinaisons de sighash
image::images/sighash_combinations.png[&quot;Résumé des différentes combinaisons de drapeaux SIGHASH&quot;]

La façon dont les drapeaux +SIGHASH+ sont appliqués lors de la signature et de la vérification est qu&#39;une copie de la transaction est faite et que certains champs à l&#39;intérieur sont tronqués (mis à zéro et vidés). La transaction résultante est sérialisée. Le drapeau +SIGHASH+ est ajouté à la fin de la transaction sérialisée et le résultat est haché. Le hachage lui-même est le &quot;message&quot; qui est signé. Selon l&#39;indicateur +SIGHASH+ utilisé, différentes parties de la transaction sont tronquées. Le hachage résultant dépend de différents sous-ensembles de données dans la transaction. En incluant le +SIGHASH+ comme dernière étape avant le hachage, la signature valide également le type +SIGHASH+, de sorte qu&#39;il ne peut pas être modifié (par exemple, par un mineur).

[NOTE]
====
Tous les types +SIGHASH+ signent le champ +nLocktime+ de la transaction (voir &lt;<transaction_locktime_nlocktime>&gt;). De plus, le type +SIGHASH+ lui-même est ajouté à la transaction avant sa signature, de sorte qu&#39;il ne peut pas être modifié une fois signé.
====

Dans l&#39;exemple de la transaction d&#39;Alice (voir la liste dans &lt;<seralization_of_signatures_der>&gt;), nous avons vu que la dernière partie de la signature codée en DER était +01+, qui est le drapeau +SIGHASH_ALL+. Cela verrouille les données de transaction, de sorte que la signature d&#39;Alice valide l&#39;état de toutes les entrées et sorties. C&#39;est la forme de signature la plus courante.

Examinons quelques-uns des autres types de +SIGHASH+ et comment ils peuvent être utilisés dans la pratique :

+ALL|ANYONECANPAY+ :: (((&quot;dons caritatifs&quot;)))(((&quot;cas d'utilisation&quot;, &quot;dons caritatifs&quot;)))Cette construction peut être utilisée pour effectuer une transaction de type &quot;financement participatif&quot;. les fonds peuvent construire une transaction avec une seule sortie. La sortie unique paie le montant &quot;objectif&quot; à la collecte de fonds. Une telle transaction n&#39;est évidemment pas valide, car elle n&#39;a pas d&#39;entrées. Cependant, d&#39;autres peuvent maintenant la modifier en ajoutant une entrée de leur propre, en tant que don. Ils signent leur propre entrée avec +ALL|ANYONECANPAY+. À moins que suffisamment d&#39;entrées ne soient rassemblées pour atteindre la valeur de la sortie, la transaction n&#39;est pas valide. Chaque don est un &quot;engagement&quot;, qui ne peut pas être collecté par le collecteur de fonds jusqu&#39;à ce que le montant total de l&#39;objectif soit atteint.

+NONE+ :: Cette construction peut être utilisée pour créer un &quot;chèque au porteur&quot; ou un &quot;chèque en blanc&quot; d&#39;un montant spécifique. Il s&#39;engage sur l&#39;entrée, mais permet de modifier le script de verrouillage de sortie. N&#39;importe qui peut écrire sa propre adresse Bitcoin dans le script de verrouillage de sortie et racheter la transaction. Cependant, la valeur de sortie elle-même est verrouillée par la signature.

+NONE|ANYONECANPAY+ :: Cette construction peut être utilisée pour construire un &quot;collecteur de poussière&quot;. Les utilisateurs qui ont de minuscules UTXO dans leur portefeuille ne peuvent pas les dépenser car le coût des frais dépasse la valeur de la poussière. Avec ce type de signature, la poussière UTXO peut être donnée à quiconque pour l&#39;agréger et la dépenser quand il le souhaite.

(((&quot;Bitmask Sighash Modes&quot;))) Il y a quelques propositions pour modifier ou étendre le système +SIGHASH+. L&#39;une de ces propositions est _Bitmask Sighash Modes_ de Glenn Willen de Blockstream, dans le cadre du projet Elements. Cela vise à créer un remplacement flexible pour les types +SIGHASH+ qui permet &quot;des masques de bits arbitraires et réinscriptibles par des mineurs d&#39;entrées et de sorties&quot; qui peuvent exprimer &quot;des schémas de pré-engagement contractuels plus complexes, tels que des offres signées avec changement dans un échange d&#39;actifs distribué&quot;.

[NOTE]
====
Vous ne verrez pas les drapeaux +SIGHASH+ présentés comme une option dans l&#39;application de portefeuille d&#39;un utilisateur. À quelques exceptions près, les portefeuilles construisent des scripts P2PKH et signent avec les drapeaux +SIGHASH_ALL+. Pour utiliser un indicateur +SIGHASH+ différent, vous devrez écrire un logiciel pour construire et signer des transactions. Plus important encore, les drapeaux +SIGHASH+ peuvent être utilisés par des applications bitcoin à usage spécial qui permettent de nouvelles utilisations.
====

[[ecdsa_math]]
==== Mathématiques ECDSA

(((&quot;Elliptic Curve Digital Signature Algorithm (ECDSA)&quot;)))Comme mentionné précédemment, les signatures sont créées par une fonction mathématique _F_~_sig_~ qui produit une signature composée de deux valeurs _R_ et _S_. Dans cette section, nous examinons la fonction _F_~_sig_~ plus en détail.

(((&quot;clés publiques et privées&quot;, &quot;paires de clés&quot;, &quot;éphémère&quot;)))L&#39;algorithme de signature génère d&#39;abord une paire de clés publiques privées _éphémères_ (temporaires). Cette paire de clés temporaire est utilisée dans le calcul des valeurs _R_ et _S_, après une transformation impliquant la clé privée de signature et le hachage de la transaction.

La paire de clés temporaire est basée sur un nombre aléatoire _k_, qui est utilisé comme clé privée temporaire. À partir de _k_, nous générons la clé publique temporaire correspondante _P_ (calculée comme _P = k*G_, de la même manière que les clés publiques bitcoin sont dérivées ; voir &lt;<pubkey>&gt;). La valeur _R_ de la signature numérique est alors la coordonnée x de la clé publique éphémère _P_.

A partir de là, l&#39;algorithme calcule la valeur _S_ de la signature, telle que :

_S_ = __k__^-1^ (__Hash__(__m__) + __dA__ * __R__) _mod n_

où:

* _k_ est la clé privée éphémère
* _R_ est la coordonnée x de la clé publique éphémère
* _dA_ est la clé privée de signature
* _m_ est les données de transaction
* _n_ est l&#39;ordre premier de la courbe elliptique

La vérification est l&#39;inverse de la fonction de génération de signature, utilisant les valeurs _R_, _S_ et la clé publique pour calculer une valeur _P_, qui est un point sur la courbe elliptique (la clé publique éphémère utilisée dans la création de signature) :

_P_ = __S__^-1^ * __Hash__(__m__) * _G_ + __S__^-1^ * _R_ * _Qa_

où:

* _R_ et _S_ sont les valeurs de signature
* _Qa_ est la clé publique d&#39;Alice
* _m_ est les données de transaction qui ont été signées
* _G_ est le point générateur de la courbe elliptique

Si la coordonnée x du point calculé _P_ est égale à _R_, alors le vérificateur peut conclure que la signature est valide.

Notez qu&#39;en vérifiant la signature, la clé privée n&#39;est ni connue ni révélée.

[TIP]
====
ECDSA est nécessairement un calcul assez compliqué; une explication complète est au-delà de la portée de ce livre. Un certain nombre d&#39;excellents guides en ligne vous guident étape par étape : recherchez &quot;ECDSA expliqué&quot; ou essayez celui-ci : https://bit.ly/2r0HhGB[].
====

==== L&#39;importance du caractère aléatoire dans les signatures

(((&quot;signatures numériques&quot;, &quot;caractère aléatoire&quot;)))Comme nous l&#39;avons vu dans &lt;<ecdsa_math>&gt;, l&#39;algorithme de génération de signature utilise une clé aléatoire _k_, comme base d&#39;un couple clé privée/publique éphémère. La valeur de _k_ n&#39;est pas importante, _tant qu&#39;elle est aléatoire_. Si la même valeur _k_ est utilisée pour produire deux signatures sur différents messages (transactions), alors la signature _clé privée_ peut être calculée par n&#39;importe qui. La réutilisation de la même valeur pour _k_ dans un algorithme de signature conduit à l&#39;exposition de la clé privée !

[WARNING]
====
(((&quot;avertissements et mises en garde&quot;, &quot;signatures numériques&quot;)))Si la même valeur _k_ est utilisée dans l&#39;algorithme de signature sur deux transactions différentes, la clé privée peut être calculée et exposée au monde !
====

Ce n&#39;est pas seulement une possibilité théorique. Nous avons vu ce problème conduire à l&#39;exposition de clés privées dans quelques implémentations différentes d&#39;algorithmes de signature de transaction en bitcoin. Des personnes se sont fait voler des fonds en raison de la réutilisation par inadvertance d&#39;une valeur _k_. La raison la plus courante de réutilisation d&#39;une valeur _k_ est un générateur de nombres aléatoires mal initialisé.

(((&quot;nombres aléatoires&quot;, &quot;génération de nombres aléatoires&quot;)))(((&quot;entropie&quot;, &quot;génération de nombres aléatoires&quot;)))(((&quot;initialisation déterministe&quot;)))Pour éviter cette vulnérabilité, la meilleure pratique de l&#39;industrie est de ne pas générer _k_ avec un générateur de nombres aléatoires semé d&#39;entropie, mais plutôt d&#39;utiliser un processus déterministe-aléatoire semé avec les données de transaction elles-mêmes. Cela garantit que chaque transaction produit un _k_ différent. L&#39;algorithme standard de l&#39;industrie pour l&#39;initialisation déterministe de _k_ est défini dans https://tools.ietf.org/html/rfc6979[RFC 6979], publié par l&#39;Internet Engineering Task Force.

Si vous implémentez un algorithme pour signer des transactions en bitcoin, vous _devez_ utiliser la RFC 6979 ou un algorithme déterministe-aléatoire similaire pour vous assurer de générer un _k_ différent pour chaque transaction.(((&quot;&quot;, startref=&quot;Tdigsig06&quot;)))

=== Adresses Bitcoin, soldes et autres abstractions

(((&quot;transactions&quot;, &quot;abstractions de niveau supérieur&quot;, id=&quot;Thigher06&quot;)))Nous avons commencé ce chapitre avec la découverte que les transactions sont très différentes &quot;dans les coulisses&quot; de la façon dont elles sont présentées dans les portefeuilles, les explorateurs de chaîne de blocs, et d&#39;autres applications destinées aux utilisateurs. De nombreux concepts simplistes et familiers des chapitres précédents, tels que les adresses et les soldes Bitcoin, semblent être absents de la structure de transaction. Nous avons vu que les transactions ne contiennent pas d&#39;adresses Bitcoin en soi, mais fonctionnent plutôt via des scripts qui verrouillent et déverrouillent des valeurs discrètes de bitcoin. Les soldes ne sont présents nulle part dans ce système et pourtant, chaque application de portefeuille affiche bien en évidence le solde du portefeuille de l&#39;utilisateur.

Maintenant que nous avons exploré ce qui est réellement inclus dans une transaction bitcoin, nous pouvons examiner comment les abstractions de niveau supérieur sont dérivées des composants apparemment primitifs de la transaction.

Regardons à nouveau comment la transaction d&#39;Alice a été présentée sur un explorateur de blocs populaire (&lt;<alice_transaction_to_bobs_cafe>&gt;).

[[alice_transaction_to_bobs_cafe]]
.Transaction d&#39;Alice au Bob&#39;s Café
image::images/mbc2_0208.png["Alice Coffee Transaction"]

Sur le côté gauche de la transaction, l&#39;explorateur de explorateur de chaîne de blocs affiche l&#39;adresse Bitcoin d&#39;Alice comme &quot;expéditeur&quot;. En fait, cette information n&#39;est pas dans la transaction elle-même. Lorsque l&#39;explorateur de blockchain fait référence à la transaction, il fait également référence à la transaction précédente associée à l&#39;entrée et extrait la première sortie de cette transaction plus ancienne. Dans cette sortie se trouve un script de verrouillage qui verrouille l&#39;UTXO sur le hachage de la clé publique d&#39;Alice (un script P2PKH). L&#39;explorateur de blockchain a extrait le hachage de la clé publique et l&#39;a encodé à l&#39;aide de l&#39;encodage Base58Check pour produire et afficher l&#39;adresse Bitcoin qui représente cette clé publique.

De même, sur le côté droit, l&#39;explorateur de blockchain affiche les deux sorties ; le premier à l&#39;adresse Bitcoin de Bob et le second à l&#39;adresse Bitcoin d&#39;Alice (comme change). Encore une fois, pour créer ces adresses Bitcoin, l&#39;explorateur de blockchain a extrait le script de verrouillage de chaque sortie, l&#39;a reconnu comme un script P2PKH et a extrait le hachage de clé publique de l&#39;intérieur. Enfin, l&#39;explorateur de blockchain a réencodé chaque hachage de clé publique avec Base58Check pour produire et afficher les adresses Bitcoin.

Si vous deviez cliquer sur l&#39;adresse Bitcoin de Bob, l&#39;explorateur de blockchain vous montrerait la vue dans &lt;<the_balance_of_bobs_bitcoin_address>&gt;.

[[the_balance_of_bobs_bitcoin_address]]
.Le solde de l&#39;adresse Bitcoin de Bob
image::images/mbc2_0608.png[&quot;Le solde de l&#39;adresse Bitcoin de Bob&quot;]

L&#39;explorateur de la chaîne de blocs affiche le solde de l&#39;adresse Bitcoin de Bob. Mais nulle part dans le système Bitcoin il n&#39;y a un concept de &quot;solde&quot;. Au lieu de cela, les valeurs affichées ici sont construites par l&#39;explorateur de explorateur de chaîne de blocs comme suit.

Pour construire le montant &quot;Total reçu&quot;, l&#39;explorateur de explorateur de la chaîne de blocs décodera d&#39;abord l&#39;encodage Base58Check de l&#39;adresse Bitcoin pour récupérer le hachage 160 bits de la clé publique de Bob qui est encodé dans l&#39;adresse. Ensuite, l&#39;explorateur de blockchain recherchera dans la base de données des transactions, à la recherche de sorties avec des scripts de verrouillage P2PKH contenant le hachage de la clé publique de Bob. En additionnant la valeur de toutes les sorties, l&#39;explorateur de la chaîne de blocs peut produire la valeur totale reçue.

Construire le solde actuel (affiché comme &quot;Solde final&quot;) nécessite un peu plus de travail. L&#39;explorateur de la chaîne de blocs conserve une base de données distincte des sorties actuellement non dépensées, l&#39;ensemble UTXO. Pour maintenir cette base de données, l&#39;explorateur de la chaîne de blocs doit surveiller le réseau Bitcoin, ajouter les UTXO nouvellement créés et supprimer les UTXO dépensés, en temps réel, tels qu&#39;ils apparaissent dans les transactions non confirmées. Il s&#39;agit d&#39;un processus compliqué qui dépend du suivi des transactions au fur et à mesure qu&#39;elles se propagent, ainsi que du maintien d&#39;un consensus avec le réseau Bitcoin pour s&#39;assurer que la chaîne correcte est suivie. Parfois, l&#39;explorateur de la chaîne de blocs est désynchronisé et sa perspective de l&#39;ensemble UTXO est incomplète ou incorrecte.

À partir de l&#39;ensemble UTXO, l&#39;explorateur de la chaîne de blocs résume la valeur de toutes les sorties non dépensées faisant référence au hachage de la clé publique de Bob et produit le numéro &quot;Solde final&quot; affiché à l&#39;utilisateur.

Afin de produire cette image unique, avec ces deux &quot;soldes&quot;, l&#39;explorateur de la chaîne de blocs doit indexer et rechercher parmi des dizaines, des centaines, voire des centaines de milliers de transactions.

En résumé, les informations présentées aux utilisateurs via les applications de portefeuille, les explorateurs de chaînes de blocs et d&#39;autres interfaces utilisateur Bitcoin sont souvent composées d&#39;abstractions de niveau supérieur qui sont dérivées en recherchant de nombreuses transactions différentes, en inspectant leur contenu et en manipulant les données qu&#39;elles contiennent. En présentant cette vision simpliste des transactions bitcoin qui ressemblent à des chèques bancaires d&#39;un expéditeur à un destinataire, ces applications doivent extraire de nombreux détails sous-jacents. Ils se concentrent principalement sur les types de transactions courants : P2PKH avec des signatures SIGHASH_ALL sur chaque entrée. Ainsi, alors que les applications bitcoin peuvent présenter plus de 80% de toutes les transactions de manière facile à lire, elles sont parfois bloquées par des transactions qui s&#39;écartent de la norme. Les transactions qui contiennent des scripts de verrouillage plus complexes, ou différents indicateurs SIGHASH, ou de nombreuses entrées et sorties, démontrent la simplicité et la faiblesse de ces abstractions.

Chaque jour, des centaines de transactions qui ne contiennent pas de sorties P2PKH sont confirmées sur la chaîne de blocs. Les explorateurs de chaîne de blocs les présentent souvent avec des messages d&#39;avertissement rouges indiquant qu&#39;ils ne peuvent pas décoder une adresse.

Comme nous le verrons au chapitre suivant, il ne s&#39;agit pas nécessairement de transactions étranges. Ce sont des transactions qui contiennent des scripts de verrouillage plus complexes que le P2PKH commun. Nous apprendrons ensuite à décoder et à comprendre des scripts plus complexes et les applications qu&#39;ils prennent en charge.(((&quot;&quot;, startref=&quot;Thigher06&quot;)))(((&quot;&quot;, startref=&quot;alicesixtwo&quot;)))