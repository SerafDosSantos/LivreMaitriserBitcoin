<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <date>2022-03-09</date>
</articleinfo>
<section id="mining">
<title>Minage et Consensus</title>
<section id="_présentation">
<title>Présentation</title>
<simpara><indexterm>
  <primary>&quot;exploitation minière et consensus&quot;</primary><secondary>&quot;but de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;but de&quot;</primary>
</indexterm>Le mot &quot;exploitation minière&quot; est quelque peu trompeur. En évoquant l&#39;extraction de métaux précieux, il focalise notre attention sur la récompense du minage, le nouveau bitcoin créé dans chaque bloc. Bien que l&#39;exploitation minière soit incitée par cette récompense, l&#39;objectif principal de l&#39;exploitation minière n&#39;est pas la récompense ou la génération de nouvelles pièces. Si vous considérez l&#39;exploitation minière uniquement comme le processus par lequel les pièces sont créées, vous confondez les moyens (incitations) avec le but du processus. Le minage est le mécanisme qui sous-tend la chambre de compensation décentralisée, par laquelle les transactions sont validées et compensées. Le minage est l&#39;invention qui rend le bitcoin spécial, un mécanisme de sécurité décentralisé qui est à la base de l&#39;argent numérique P2P.</simpara>
<simpara><indexterm>
  <primary>&quot;exploitation minière et consensus&quot;</primary><secondary>&quot;consensus décentralisé&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;consensus décentralisé&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;autorité centrale de confiance&quot;</primary>
</indexterm>L&#39;exploitation minière <emphasis>sécurise le système Bitcoin</emphasis> et permet l&#39;émergence d&#39;un <emphasis>consensus à l&#39;échelle du réseau sans autorité centrale</emphasis>. <indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;frais de transaction&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;frais de transaction&quot;</primary>
</indexterm> La récompense des pièces nouvellement frappées et des frais de transaction est un système d&#39;incitation qui aligne les actions des mineurs sur la sécurité du réseau, tout en mettant en œuvre simultanément l&#39;offre monétaire.</simpara>
<informalexample>
<simpara><indexterm>
  <primary>&quot;systèmes décentralisés&quot;</primary><secondary>&quot;minage de bitcoins et&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;minage de bitcoins et&quot;</primary>
</indexterm>Le but du minage n&#39;est pas la création de nouveaux bitcoins. C&#39;est le système d&#39;incitation. Le minage est le mécanisme par lequel la <emphasis>sécurité</emphasis> du bitcoin est <emphasis>décentralisée</emphasis>.</simpara>
</informalexample>
<simpara>Les mineurs valident les nouvelles transactions et les enregistrent dans le grand livre mondial. Un nouveau bloc, contenant les transactions qui se sont produites depuis le dernier bloc, est &quot;miné&quot; toutes les 10 minutes en moyenne, ajoutant ainsi ces transactions à la blockchain. Les transactions qui font partie d&#39;un bloc et ajoutées à la blockchain sont considérées comme &quot;confirmées&quot;, ce qui permet aux nouveaux propriétaires de bitcoin de dépenser le bitcoin qu&#39;ils ont reçu dans ces transactions.</simpara>
<simpara><indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;récompenses de minage&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;récompenses de minage&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;récompenses et frais de minage&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;récompenses et frais de minage&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Algorithme de preuve de travail&quot;</primary>
</indexterm><indexterm>
  <primary>&quot; minage et consensus&quot;</primary><secondary>&quot;Algorithme de preuve de travail&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Algorithme de preuve de travail&quot;</primary>
</indexterm> Les mineurs reçoivent deux types de récompenses en échange de la sécurité fournie par le minage : de nouvelles pièces créées avec chaque nouveau bloc, également appelées <emphasis>récompense de bloc</emphasis> ou <emphasis>récompense de coinbase</emphasis>, et les frais de transaction de toutes les transactions incluses dans le bloc. Pour gagner cette récompense, les mineurs s&#39;affrontent pour résoudre un problème mathématique difficile basé sur un algorithme de hachage cryptographique. La solution au problème, appelée Proof-of-Work, est incluse dans le nouveau bloc et agit comme preuve que le mineur a déployé des efforts informatiques importants. La compétition pour résoudre l&#39;algorithme Proof-of-Work pour gagner la récompense et le droit d&#39;enregistrer les transactions sur la blockchain est la base du modèle de sécurité de Bitcoin.</simpara>
<simpara>Le processus est appelé minage parce que la récompense (nouvelle génération de pièces) est conçue pour simuler des rendements décroissants, tout comme le minage de métaux précieux. La masse monétaire de Bitcoin est créée par l&#39;exploitation minière, de la même manière qu&#39;une banque centrale émet de la nouvelle monnaie en imprimant des billets de banque. La quantité maximale de bitcoins nouvellement créés qu&#39;un mineur peut ajouter à un bloc diminue environ tous les quatre ans (ou précisément tous les 210 000 blocs). Il a commencé à 50 bitcoins par bloc en janvier 2009 et a été réduit de moitié à 25 bitcoins par bloc en novembre 2012. Il a été réduit de moitié à 12,5 bitcoins en juillet 2016 et de nouveau à 6,25 bitcoins en mai 2020. Sur la base de cette formule, les récompenses de minage de bitcoins diminuent de façon exponentielle. jusqu&#39;à environ l&#39;an 2140, lorsque tous les bitcoins (20,99999998 millions) auront été émis. Après 2140, aucun nouveau bitcoin ne sera émis.</simpara>
<simpara>Les mineurs de Bitcoin gagnent également des frais sur les transactions. Chaque transaction comprend généralement des frais de transaction, sous la forme d&#39;un surplus de bitcoin entre les entrées et les sorties de la transaction. Le mineur de bitcoin gagnant peut &quot;garder la monnaie&quot; sur les transactions incluses dans le bloc gagnant. Aujourd&#39;hui, les frais représentent 0,5% ou moins des revenus d&#39;un mineur de bitcoin, la grande majorité provenant du bitcoin nouvellement créé. Cependant, à mesure que la récompense de bloc diminue avec le temps et que le nombre de transactions par bloc augmente, une plus grande proportion des revenus de minage de bitcoins proviendra des frais. Progressivement, la récompense minière sera dominée par les frais de transaction, qui constitueront la principale incitation pour les mineurs. Après 2140, la quantité de nouveaux bitcoins dans chaque bloc tombe à zéro et l&#39;extraction de bitcoins ne sera encouragée que par les frais de transaction.</simpara>
<simpara>Dans ce chapitre, nous examinerons d&#39;abord l&#39;exploitation minière en tant que mécanisme d&#39;approvisionnement monétaire, puis nous examinerons la fonction la plus importante de l&#39;exploitation minière : le mécanisme de consensus décentralisé qui sous-tend la sécurité du bitcoin.</simpara>
<simpara>Pour comprendre l&#39;exploitation minière et le consensus, nous suivrons la transaction d&#39;Alice telle qu&#39;elle est reçue et ajoutée à un bloc par l&#39;équipement minier de Jing. Ensuite, nous suivrons le bloc tel qu&#39;il est extrait, ajouté à la blockchain et accepté par le réseau Bitcoin à travers le processus de consensus émergent.</simpara>
<section id="_économie_bitcoin_et_création_de_devises">
<title>Économie Bitcoin et création de devises</title>
<simpara><indexterm>
  <primary>&quot;exploitation minière et consensus&quot;</primary><secondary>&quot;économie du bitcoin et création de monnaie&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;économie du bitcoin et création de monnaie&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;création de monnaie&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;masse monétaire&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;taux d&#39;émission&quot;</primary>
</indexterm>Bitcoin sont &quot;frappés&quot; lors de la création de chaque bloc à un taux fixe et décroissant. Chaque bloc, généré en moyenne toutes les 10 minutes, contient des bitcoins entièrement nouveaux, créés à partir de rien. Tous les 210 000 blocs, soit environ tous les quatre ans, le taux d&#39;émission des devises est diminué de 50 %. Pendant les quatre premières années de fonctionnement du réseau, chaque bloc contenait 50 nouveaux bitcoins.</simpara>
<simpara>En novembre 2012, le nouveau taux d&#39;émission de bitcoins a été réduit à 25 bitcoins par bloc. En juillet 2016, il a été réduit à 12,5 bitcoins par bloc, et en mai 2020, il a de nouveau été réduit à 6,25 bitcoins par bloc. Le taux de nouvelles pièces diminue ainsi de manière exponentielle sur 32 &quot;halvings&quot; jusqu&#39;au bloc 6 720 000 (miné environ en 2137), lorsqu&#39;il atteint l&#39;unité monétaire minimale de 1 satoshi. Enfin, après 6,93 millions de blocs, en 2140 environ, près de 2 099 999 997 690 000 satoshis, soit près de 21 millions de bitcoins, seront émis. Par la suite, les blocs ne contiendront plus de nouveaux bitcoins et les mineurs seront récompensés uniquement par les frais de transaction. &lt;&lt;bitcoin_money_supply&gt; &gt; montre le bitcoin total en circulation au fil du temps, à mesure que l&#39;émission de devises diminue.</simpara>
<variablelist id="bitcoin_money_supply"><title>Offre de monnaie bitcoin au fil du temps basée sur un taux d&#39;émission géométriquement décroissant</title>
<varlistentry>
<term>
image 
</term>
<listitem>
<simpara>
images/mbc2_1001.png[&quot;BitcoinMoneySupply&quot;]
</simpara>
</listitem>
</varlistentry>
</variablelist>
<informalexample>
<simpara>Le nombre maximum de pièces minées est la <emphasis>limite supérieure</emphasis> des récompenses minières possibles pour le bitcoin. En pratique, un mineur peut intentionnellement exploiter un bloc en prenant moins que la récompense complète. Ces blocs ont déjà été extraits et d&#39;autres pourraient l&#39;être à l&#39;avenir, ce qui entraînerait une émission totale inférieure de la monnaie.</simpara>
</informalexample>
<simpara>Dans l&#39;exemple de code dans &lt;&lt;max_money&gt; &gt;, nous calculons le montant total de bitcoin qui sera émis.</simpara>
<example id="max_money">
<title>Un script pour calculer la quantité totale de bitcoins qui sera émise</title>
<programlisting language="python" linenumbering="unnumbered">inclure::code/max_money.py[]</programlisting>
</example>
<simpara>&lt;&lt;max_money_run&gt; &gt; affiche la sortie produite en exécutant ce script.</simpara>
<example id="max_money_run">
<title>Exécuter le script max_money.py</title>
<programlisting language="bash" linenumbering="unnumbered">$ python max_money.py
Total BTC à créer : 2100000000000000.0 Satoshis</programlisting>
</example>
<simpara>L&#39;émission finie et décroissante crée une masse monétaire fixe qui résiste à l&#39;inflation. Contrairement à une monnaie fiduciaire, qui peut être imprimée en nombre infini par une banque centrale, le bitcoin ne peut jamais être gonflé par l&#39;impression.</simpara>
<sidebar>
<title>Argent déflationniste</title>
<simpara><indexterm>
  <primary>&quot;monnaie déflationniste&quot;</primary>
</indexterm> La conséquence la plus importante et la plus débattue d&#39;une émission monétaire fixe et décroissante est que la monnaie a tendance à être intrinsèquement déflationniste. La déflation est le phénomène d&#39;appréciation de la valeur due à une inadéquation entre l&#39;offre et la demande qui fait monter la valeur (et le taux de change) d&#39;une monnaie. Le contraire de l&#39;inflation, la déflation des prix, signifie que l&#39;argent a plus de pouvoir d&#39;achat au fil du temps.</simpara>
<simpara>De nombreux économistes soutiennent qu&#39;une économie déflationniste est une catastrophe qu&#39;il faut éviter à tout prix. En effet, en période de déflation rapide, les gens ont tendance à accumuler de l&#39;argent au lieu de le dépenser, en espérant que les prix chuteront. Un tel phénomène s&#39;est déroulé au cours de la « décennie perdue » du Japon, lorsqu&#39;un effondrement complet de la demande a poussé la monnaie dans une spirale déflationniste.</simpara>
<simpara>Les experts du Bitcoin affirment que la déflation n&#39;est pas mauvaise en soi. La déflation est plutôt associée à un effondrement de la demande car c&#39;est le seul exemple de déflation que nous ayons à étudier. Dans une monnaie fiduciaire avec possibilité d&#39;impression illimitée, il est très difficile d&#39;entrer dans une spirale déflationniste à moins qu&#39;il n&#39;y ait un effondrement complet de la demande et une réticence à imprimer de l&#39;argent. La déflation du bitcoin n&#39;est pas causée par un effondrement de la demande, mais par une offre limitée de manière prévisible.</simpara>
<simpara>L&#39;aspect positif de la déflation, bien sûr, c&#39;est qu&#39;elle est le contraire de l&#39;inflation. L&#39;inflation provoque une dépréciation lente mais inévitable de la monnaie, se traduisant par une forme de taxation cachée qui punit les épargnants afin de renflouer les débiteurs (y compris les plus gros débiteurs, les gouvernements eux-mêmes). Les monnaies sous contrôle gouvernemental souffrent de l&#39;aléa moral d&#39;une émission facile de dette qui peut ensuite être effacée par la dépréciation aux dépens des épargnants.</simpara>
<simpara>Il reste à voir si l&#39;aspect déflationniste de la monnaie est un problème lorsqu&#39;il n&#39;est pas entraîné par une rétraction économique rapide, ou un avantage parce que la protection contre l&#39;inflation et l&#39;avilissement l&#39;emporte largement sur les risques de déflation.</simpara>
</sidebar>
</section>
</section>
<section id="_consensus_décentralisé">
<title>Consensus décentralisé</title>
<simpara><indexterm>
  <primary>&quot;exploitation minière et consensus&quot;</primary><secondary>&quot;consensus décentralisé&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;consensus décentralisé&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;systèmes décentralisés&quot;</primary><secondary>&quot;consensus dans&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;consensus dans&quot;</primary>
</indexterm> Dans le chapitre précédent, nous avons examiné la blockchain, le registre public mondial (liste) de tous transactions, que tout le monde dans le réseau Bitcoin accepte comme enregistrement de propriété faisant autorité.</simpara>
<simpara>Mais comment tout le monde dans le réseau peut-il s&#39;entendre sur une seule « vérité » universelle sur qui possède quoi, sans avoir à faire confiance à personne ? Tous les systèmes de paiement traditionnels dépendent d&#39;un modèle de confiance qui a une autorité centrale fournissant un service de chambre de compensation, vérifiant et compensant essentiellement toutes les transactions. Bitcoin n&#39;a pas d&#39;autorité centrale, mais d&#39;une manière ou d&#39;une autre, chaque nœud complet possède une copie complète d&#39;un grand livre public auquel il peut faire confiance en tant qu&#39;enregistrement faisant autorité. La blockchain n&#39;est pas créée par une autorité centrale, mais est assemblée indépendamment par chaque nœud du réseau. D&#39;une manière ou d&#39;une autre, chaque nœud du réseau, agissant sur les informations transmises via des connexions réseau non sécurisées, peut arriver à la même conclusion et assembler une copie du même registre public que tout le monde. Ce chapitre examine le processus par lequel le réseau Bitcoin parvient à un consensus mondial sans autorité centrale.</simpara>
<simpara><indexterm>
  <primary>&quot;consensus émergent&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;extraction et consensus&quot;</primary><secondary>&quot;consensus émergent&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;consensus émergent&quot;</primary>
</indexterm>La principale invention de Satoshi Nakamoto est le mécanisme décentralisé de <emphasis>consensus émergent</emphasis>. Emergent, parce que le consensus n&#39;est pas atteint explicitement - il n&#39;y a pas d&#39;élection ou de moment fixe où le consensus se produit. Au lieu de cela, le consensus est un artefact émergent de l&#39;interaction asynchrone de milliers de nœuds indépendants, qui suivent tous des règles simples. Toutes les propriétés du bitcoin, y compris la monnaie, les transactions, les paiements et le modèle de sécurité qui ne dépend pas de l&#39;autorité centrale ou de la confiance, découlent de cette invention.</simpara>
<simpara>Le consensus décentralisé de Bitcoin émerge de l&#39;interaction de quatre processus qui se produisent indépendamment sur les nœuds du réseau :</simpara>
<itemizedlist>
<listitem>
<simpara>
Vérification indépendante de chaque transaction, par chaque nœud complet, sur la base d&#39;une liste complète de critères
</simpara>
</listitem>
<listitem>
<simpara>
Agrégation indépendante de ces transactions dans de nouveaux blocs par des nœuds de minage, associée à un calcul démontré via un algorithme de preuve de travail
</simpara>
</listitem>
<listitem>
<simpara>
Vérification indépendante des nouveaux blocs par chaque nœud et assemblage dans une chaîne
</simpara>
</listitem>
<listitem>
<simpara>
Sélection indépendante, par chaque nœud, de la chaîne avec le calcul le plus cumulatif démontré par la preuve de travail
</simpara>
</listitem>
</itemizedlist>
<simpara>Dans les prochaines sections, nous examinerons ces processus et la manière dont ils interagissent pour créer la propriété émergente du consensus à l&#39;échelle du réseau qui permet à n&#39;importe quel nœud Bitcoin d&#39;assembler sa propre copie du grand livre public mondial faisant autorité.</simpara>
</section>
<section id="tx_verification">
<title>Vérification indépendante des transactions</title>
<simpara><indexterm>
  <primary>&quot;exploitation minière et consensus&quot;</primary><secondary>&quot;vérification indépendante des transactions&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;vérification indépendante des transactions&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;vérification indépendante de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;vérification indépendante de&quot;</primary>
</indexterm>Dans &lt;&lt;transactions&gt; &gt;, nous avons vu comment un logiciel de portefeuille crée des transactions en collectant des UTXO, en fournissant les scripts de déverrouillage appropriés, puis en construisant de nouvelles sorties attribuées à un nouveau propriétaire. La transaction résultante est ensuite envoyée aux nœuds voisins du réseau Bitcoin afin qu&#39;elle puisse être propagée sur l&#39;ensemble du réseau Bitcoin.</simpara>
<simpara>Cependant, avant de transmettre les transactions à ses voisins, chaque nœud Bitcoin qui reçoit une transaction vérifiera d&#39;abord la transaction. Cela garantit que seules les transactions valides sont propagées sur le réseau, tandis que les transactions non valides sont rejetées au premier nœud qui les rencontre.</simpara>
<simpara>Chaque nœud vérifie chaque transaction par rapport à une longue liste de critères :</simpara>
<itemizedlist>
<listitem>
<simpara>
La syntaxe et la structure des données de la transaction doivent être correctes.
</simpara>
</listitem>
<listitem>
<simpara>
Ni les listes d&#39;entrées ni de sorties ne sont vides.
</simpara>
</listitem>
<listitem>
<simpara>
La taille de la transaction est inférieure à la taille maximale autorisée pour un bloc excluant les données témoins, comme indiqué dans <ulink url="https://bit.ly/3t623VL"><emphasis>tx_check.cpp</emphasis></ulink>.
</simpara>
</listitem>
<listitem>
<simpara>
Chaque valeur de sortie, ainsi que le total, doit être dans la plage de valeurs autorisée (moins de 21 millions de pièces, plus que le seuil de <emphasis>poussière</emphasis>).
</simpara>
</listitem>
<listitem>
<simpara>
Aucune des entrées n&#39;a hash=0, N=–1 (les transactions coinbase ne doivent pas être relayées).
</simpara>
</listitem>
<listitem>
<simpara>
<literal>nLocktime</literal> est égal à <literal>INT_MAX</literal>, ou les valeurs <literal>nLocktime</literal> et <literal>nSequence</literal> sont satisfaites selon <literal>MedianTimePast</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
La taille de la transaction en octets est supérieure ou égale à 82.
</simpara>
</listitem>
<listitem>
<simpara>
Le nombre d&#39;opérations de signature (SIGOPS) contenues dans la transaction est inférieur à la limite d&#39;opérations de signature.
</simpara>
</listitem>
<listitem>
<simpara>
Le script de déverrouillage (<literal>scriptSig</literal>) ne peut pousser que des nombres sur la pile, et le script de verrouillage (<literal>scriptPubkey</literal>) doit correspondre aux formes <literal>IsStandard</literal> (cela rejette les transactions &quot;non standard&quot;).
</simpara>
</listitem>
<listitem>
<simpara>
Une transaction correspondante dans le pool ou dans un bloc de la branche principale doit exister.
</simpara>
</listitem>
<listitem>
<simpara>
Pour chaque entrée, si la sortie référencée existe dans une autre transaction du pool, la transaction doit être rejetée.
</simpara>
</listitem>
<listitem>
<simpara>
Pour chaque entrée, regardez dans la branche principale et le pool de transactions pour trouver sa transaction parente. Si la transaction parent est manquante pour une entrée, il s&#39;agira d&#39;une transaction orpheline. Ajouter au pool de transactions orphelines, si une transaction correspondante n&#39;est pas déjà dans le pool.
</simpara>
</listitem>
<listitem>
<simpara>
Pour chaque entrée, si sa transaction parente est une transaction coinbase, elle doit avoir au moins <literal>COINBASE_MATURITY</literal> (100) confirmations.
</simpara>
</listitem>
<listitem>
<simpara>
Pour chaque entrée, la sortie référencée doit exister et ne peut pas déjà être dépensée.
</simpara>
</listitem>
<listitem>
<simpara>
En utilisant les transactions parentes pour obtenir les valeurs d&#39;entrée, vérifiez que chaque valeur d&#39;entrée, ainsi que la somme, se situent dans la plage de valeurs autorisée (moins de 21 millions de pièces, plus de 0).
</simpara>
</listitem>
<listitem>
<simpara>
Rejeter si la somme des valeurs d&#39;entrée est inférieure à la somme des valeurs de sortie.
</simpara>
</listitem>
<listitem>
<simpara>
Rejeter si les frais de transaction seraient trop bas (<literal>minRelayTxFee</literal>) pour entrer dans un bloc vide.
</simpara>
</listitem>
<listitem>
<simpara>
Les scripts de déverrouillage pour chaque entrée doivent être validés par rapport aux scripts de verrouillage de sortie correspondants.
</simpara>
</listitem>
</itemizedlist>
<simpara>Ces conditions peuvent être vues en détail dans les fonctions <literal>AcceptToMemoryPool</literal>, <literal>CheckTransaction</literal> et <literal>CheckInputs</literal> dans Bitcoin Core. Notez que les conditions changent avec le temps, pour faire face à de nouveaux types d&#39;attaques par déni de service ou parfois pour assouplir les règles afin d&#39;inclure davantage de types de transactions.</simpara>
<simpara>En vérifiant indépendamment chaque transaction lors de sa réception et avant de la propager, chaque nœud crée un pool de transactions valides (mais non confirmées) connu sous le nom de <emphasis>transaction pool</emphasis>, <emphasis>memory pool</emphasis> ou <emphasis>mempool</emphasis>.</simpara>
</section>
<section id="_nœuds_miniers">
<title>Nœuds miniers</title>
<simpara><indexterm>
  <primary>&quot;mining and consensus&quot;</primary><secondary>&quot;mining nodes&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;mining nodes&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Bitcoin nodes&quot;</primary><secondary>&quot;mining nodes&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;mining nodes&quot;</primary>
</indexterm>Certains des nœuds du réseau Bitcoin sont des nœuds spécialisés appelés <emphasis>miners</emphasis>. Dans &lt;&lt;ch01_intro_what_is_bitcoin&gt; &gt; nous avons présenté <indexterm>
  <primary>&quot;use cases&quot;</primary><secondary>&quot;mining for bitcoin&quot;</secondary><tertiary>id=&quot;jingten&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;mining for bitcoin&quot;</primary><secondary>id=&quot;jingten&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;jingten&quot;</primary>
</indexterm>Jing, un étudiant en génie informatique à Shanghai, en Chine, qui est un mineur de bitcoin. Jing gagne du bitcoin en exécutant une &quot;plate-forme minière&quot;, qui est un système informatique spécialisé conçu pour exploiter le bitcoin. Le matériel minier spécialisé de Jing est connecté à un serveur exécutant un nœud Bitcoin complet. Contrairement à Jing, certains mineurs minent sans nœud complet, comme nous le verrons dans &lt;&lt;mining_pools&gt; &gt;. Comme tous les autres nœuds complets, le nœud de Jing reçoit et propage les transactions non confirmées sur le réseau Bitcoin. Le nœud de Jing, cependant, agrège également ces transactions dans de nouveaux blocs.</simpara>
<simpara>Le nœud de Jing est à l&#39;écoute de nouveaux blocs, propagés sur le réseau Bitcoin, comme tous les nœuds. Cependant, l&#39;arrivée d&#39;un nouveau bloc a une signification particulière pour un nœud minier. La compétition entre mineurs se termine effectivement par la propagation d&#39;un nouveau bloc qui fait office d&#39;annonce d&#39;un gagnant. Pour les mineurs, recevoir un nouveau bloc valide signifie que quelqu&#39;un d&#39;autre a gagné la compétition et qu&#39;il a perdu. Cependant, la fin d&#39;un tour d&#39;une compétition est aussi le début du tour suivant. Le nouveau bloc n&#39;est pas seulement un drapeau à damier, marquant la fin de la course ; c&#39;est aussi le pistolet de départ dans la course pour le bloc suivant.</simpara>
</section>
<section id="_agréger_les_transactions_en_blocs">
<title>Agréger les transactions en blocs</title>
<simpara><indexterm>
  <primary>&quot;exploration et consensus&quot;</primary><secondary>&quot;agrégation des transactions en blocs&quot;</secondary><tertiary>id=&quot;MACaggreg10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;agrégation des transactions en blocs&quot;</primary><secondary>id=&quot;MACaggreg10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;MACaggreg10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;agrégation en blocs&quot;</secondary><tertiary>id=&quot;Taggreg10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;agrégation en blocs&quot;</primary><secondary>id=&quot;Taggreg10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Taggreg10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs &quot;</primary><secondary>&quot;agrégation des transactions dans&quot;</secondary><tertiary>id=&quot;Baggreg10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;agrégation des transactions dans&quot;</primary><secondary>id=&quot;Baggreg10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Baggreg10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;blocs candidats&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;blocs candidats&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs candidats&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;groupes de transactions&quot;</primary>
</indexterm> <indexterm>
  <primary>&quot;pools de mémoire (mempools)&quot;</primary>
</indexterm>Après avoir validé les transactions, un nœud Bitcoin les ajoutera au <emphasis>memory pool</emphasis>, ou <emphasis>transaction pool</emphasis>, où les transactions attendent jusqu&#39;à ce qu&#39;elles puissent être incluses (exploitées) dans un bloc. Le nœud de Jing collecte, valide et relaie les nouvelles transactions comme n&#39;importe quel autre nœud. Contrairement aux autres nœuds, cependant, le nœud de Jing regroupera ensuite ces transactions dans un <emphasis>bloc candidat</emphasis>.</simpara>
<simpara>Suivons les blocs qui ont été créés à l&#39;époque où Alice achetait une tasse de café au Bob&#39;s Cafe (voir &lt;&lt;cup_of_coffee&gt; &gt;). La transaction d&#39;Alice a été incluse dans le bloc 277 316. Dans le but de démontrer les concepts de ce chapitre, supposons que ce bloc a été miné par le système de minage de Jing et suivons la transaction d&#39;Alice au fur et à mesure qu&#39;elle fait partie de ce nouveau bloc.</simpara>
<simpara>Le nœud minier de Jing maintient une copie locale de la blockchain. Au moment où <indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;acheter du café&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;acheter du café&quot;</primary>
</indexterm>Alice achète la tasse de café, le nœud de Jing a assemblé une chaîne jusqu&#39;au bloc 277 314. Le nœud de Jing écoute les transactions, essaie d&#39;extraire un nouveau bloc et écoute également les blocs découverts par d&#39;autres nœuds. Comme le nœud de Jing est en train d&#39;exploiter, il reçoit le bloc 277 315 via le réseau Bitcoin. L&#39;arrivée de ce bloc signifie la fin de la compétition pour le bloc 277,315 et le début de la compétition pour créer le bloc 277,316.</simpara>
<simpara>Au cours des 10 minutes précédentes, alors que le nœud de Jing cherchait une solution pour bloquer 277 315, il collectait également des transactions en vue du bloc suivant. À ce jour, il a collecté quelques centaines de transactions dans le pool de mémoire. Lors de la réception du bloc 277,315 et de sa validation, le nœud de Jing le comparera également à toutes les transactions du pool de mémoire et supprimera celles qui étaient incluses dans le bloc 277,315. Quelles que soient les transactions restantes dans le pool de mémoire, elles ne sont pas confirmées et attendent d&#39;être enregistrées dans un nouveau bloc.</simpara>
<simpara><indexterm>
  <primary>&quot;Proof-of-Work algorithm&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;mining and consensus&quot;</primary><secondary>&quot;Proof-of-Work algorithm&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Proof-of-Work algorithm&quot;</primary>
</indexterm>Le nœud de Jing construit immédiatement un nouveau bloc vide, un candidat pour le bloc 277 316. Ce bloc est appelé <emphasis>bloc candidat</emphasis> car ce n&#39;est pas encore un bloc valide, car il ne contient pas de preuve de travail valide. Le bloc ne devient valide que si le mineur réussit à trouver une solution à l&#39;algorithme Proof-of-Work.</simpara>
<simpara>Lorsque le nœud de Jing regroupe toutes les transactions du pool de mémoire, le nouveau bloc candidat contient 418 transactions avec des frais de transaction totaux de 0,09094928 bitcoin. Vous pouvez voir ce bloc dans la blockchain à l&#39;aide de l&#39;interface de ligne de commande du client Bitcoin Core, comme indiqué dans &lt;&lt;block277316&gt; &gt;.</simpara>
<example id="block277316">
<title>Utiliser la ligne de commande pour récupérer le bloc 277,316</title>
<programlisting language="bash" linenumbering="unnumbered">$ bitcoin-cli getblockhash 277316

0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4

$ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d9\
44a9b31b2cc7bdc4</programlisting>
<programlisting language="json" linenumbering="unnumbered">{
    &amp;quot;hachage&amp;quot; : &amp;quot;0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4&amp;quot;,
    &amp;quot;confirmations&amp;quot; : 35561,
    &amp;quot;taille&amp;quot; : 218629,
    &amp;quot;hauteur&amp;quot; : 277316,
    &amp;quot;version 2,
    &amp;quot;merkleroot&amp;quot; : &amp;quot;c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e&amp;quot;,
    &amp;quot;tx&amp;quot; : [
        &amp;quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&amp;quot;,
        &amp;quot;b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe&amp;quot;,

        ... 417 transactions supplémentaires ...

       ],
    &amp;quot;heure&amp;quot; : 1388185914,
    &amp;quot;nonce&amp;quot; : 924591752,
    &amp;quot;bits&amp;quot; : &amp;quot;1903a30c&amp;quot;,
    &amp;quot;difficulté&amp;quot; : 1180923195.25802612,
    &amp;quot;chaînette&amp;quot; : &amp;quot;00000000000000000000000000000000000000000934695e92aaf53afa1a&amp;quot;,
    &amp;quot;hachage de bloc précédent&amp;quot; : &amp;quot;0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569&amp;quot;
}</programlisting>
</example>
<section id="_la_transaction_coinbase">
<title>La transaction Coinbase</title>
<simpara><indexterm>
  <primary>&quot;coinbase transactions&quot;</primary><secondary>id=&quot;coinbtrans10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;coinbtrans10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;coinbase transactions&quot;</secondary><tertiary>id=&quot;Tcoinb10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;coinbase transactions&quot;</primary><secondary>id=&quot;Tcoinb10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Tcoinb10&quot;</primary>
</indexterm>La première transaction d&#39;un bloc est une transaction spéciale, appelée <emphasis>coinbase transaction</emphasis>. Cette transaction est construite par le nœud de Jing et contient sa <emphasis>récompense</emphasis> pour l&#39;effort de minage.</simpara>
<informalexample>
<simpara>Lorsque le bloc 277 316 a été miné, la récompense était de 25 bitcoins par bloc. Depuis, deux périodes de &quot;halving&quot; se sont écoulées. La récompense globale est passée à 12,5 bitcoins en juillet 2016 et à 6,25 bitcoins en mai 2020.</simpara>
</informalexample>
<simpara>Le nœud de Jing crée la transaction coinbase en tant que paiement sur son propre portefeuille : &quot;Pay Jing&#39;s address 25.09094928 bitcoin.&quot; Le montant total de la récompense que Jing collecte pour l&#39;extraction d&#39;un bloc est la somme de la récompense coinbase (25 nouveaux bitcoins) et des frais de transaction (0,09094928) de toutes les transactions incluses dans le bloc, comme indiqué dans &lt;&lt;generation_tx_example&gt; &gt;.</simpara>
<simpara id="generation_tx_example">Transaction .Coinbase</simpara>
<informalexample>
<screen>$ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1</screen>
<screen>{
    &amp;quot;Hex&amp;quot;: &amp;quot;01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000&amp;quot;,
    &amp;quot;txid&amp;quot; : &amp;quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&amp;quot;,
    &amp;quot;version 1,
    &amp;quot;temps de verrouillage&amp;quot; : 0,
    &amp;quot;vin&amp;quot; : [
        {
            &amp;quot;coinbase&amp;quot; : &amp;quot;03443b0403858402062f503253482f&amp;quot;,
            &amp;quot;séquence&amp;quot; : 4294967295
        }
    ],
    &amp;quot;vouter&amp;quot; : [
        {
            &amp;quot;valeur&amp;quot; : 25.09094928,
            &amp;quot;n&amp;quot; : 0,
            &amp;quot;scriptPubKey&amp;quot; : {
                &amp;quot;asm&amp;quot; : &amp;quot;02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG&amp;quot;,
                &amp;quot;hex&amp;quot; : &amp;quot;2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac&amp;quot;,
                &amp;quot;reqSigs&amp;quot; : 1,
                &amp;quot;type&amp;quot; : &amp;quot;pubkey&amp;quot;,
                &amp;quot;adresses&amp;quot; : [
                    &amp;quot;1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N&amp;quot;
                ]
            }
        }
    ]
}</screen>
</informalexample>
<simpara>Contrairement aux transactions régulières, la transaction coinbase ne consomme pas (dépense) UTXO comme entrées. Au lieu de cela, il n&#39;a qu&#39;une seule entrée, appelée <emphasis>coinbase</emphasis>, qui crée du bitcoin à partir de rien. La transaction coinbase a une sortie, payable à la propre adresse Bitcoin du mineur. La sortie de la transaction coinbase envoie la valeur de 25,09094928 bitcoin à l&#39;adresse Bitcoin du mineur ; dans ce cas c&#39;est <literal>1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N</literal>.</simpara>
</section>
<section id="_récompense_et_frais_coinbase">
<title>Récompense et frais Coinbase</title>
<simpara><indexterm>
  <primary>&quot;coinbase transactions&quot;</primary><secondary>&quot;récompenses et frais&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;récompenses et frais&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;frais de transaction&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;frais de transaction&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;exploitation minière et consensus&quot;</primary><secondary>&quot;récompenses et frais&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;récompenses et frais&quot;</primary>
</indexterm> transaction coinbase, le nœud de Jing calcule d&#39;abord le montant total des frais de transaction en ajoutant toutes les entrées et sorties des 418 transactions qui ont été ajoutées au bloc. Les frais sont calculés comme suit :</simpara>
<screen>Frais totaux = Somme (entrées) - Somme (sorties)</screen>
<simpara>Dans le bloc 277 316, le total des frais de transaction est de 0,09094928 bitcoin.</simpara>
<simpara>Ensuite, le nœud de Jing calcule la récompense correcte pour le nouveau bloc. La récompense est calculée en fonction de la hauteur du bloc, à partir de 50 bitcoins par bloc et réduite de moitié tous les 210 000 blocs. Parce que ce bloc est à la hauteur 277 316, la récompense correcte est de 25 bitcoins.</simpara>
<simpara>Le calcul peut être vu dans la fonction <literal>GetBlockSubsidy</literal> dans le client Bitcoin Core, comme indiqué dans &lt;&lt;getblocksubsidy_source&gt; &gt;.</simpara>
<example id="getblocksubsidy_source">
<title>Calcul de la récompense de bloc—Fonction GetBlockSubsidy, Bitcoin Core Client, main.cpp</title>
<programlisting language="cpp" linenumbering="unnumbered">CAmount GetBlockSubsidy(int nHeight, const Consensus ::Params&amp;amp; consensusParams)
{
    int halvings = nHeight / consensusParams.nSubsidyHalvingInterval ;
    // Force la récompense du bloc à zéro lorsque le décalage vers la droite n&amp;#39;est pas défini.
    si (moitiés &amp;gt;= 64)
        renvoie 0 ;

    CAmount nSubsidy = 50 * COIN ;
    // La subvention est réduite de moitié tous les 210 000 blocs, ce qui se produira environ tous les 4 ans.
    nSubvention &amp;gt;&amp;gt;= moitiés ;
    retourner nSubvention ;
}</programlisting>
</example>
<simpara>La subvention initiale est calculée en satoshis en multipliant 50 par la constante <literal>COIN</literal> (100 000 000 satoshis). Cela fixe la récompense initiale (<literal>nSubsidy</literal>) à 5 milliards de satoshis.</simpara>
<simpara><indexterm>
  <primary>&quot;halvings&quot;</primary>
</indexterm>Ensuite, la fonction calcule le nombre de <literal>halvings</literal> qui se sont produits en divisant la hauteur actuelle du bloc par l&#39;intervalle de halving (<literal>SubsidyHalvingInterval</literal>). Dans le cas du bloc 277 316, avec un intervalle de moitié tous les 210 000 blocs, le résultat est 1 moitié.</simpara>
<simpara>Le nombre maximum de moitiés autorisé est de 64, donc le code impose une récompense nulle (ne renvoie que les frais) si les 64 moitiés sont dépassées.</simpara>
<simpara>Ensuite, la fonction utilise l&#39;opérateur binaire de décalage vers la droite pour diviser la récompense (<literal>nSubsidy</literal>) par deux pour chaque cycle de réduction de moitié. Dans le cas du bloc 277 316, cela entraînerait un décalage binaire vers la droite de la récompense de 5 milliards de satoshis une fois (une réduction de moitié) et donnerait 2,5 milliards de satoshis, soit 25 bitcoins. L&#39;opérateur de décalage binaire vers la droite est utilisé car il est plus efficace que plusieurs divisions répétées. Pour éviter un bogue potentiel, l&#39;opération de décalage est ignorée après 63 moitiés et la subvention est définie sur 0.</simpara>
<simpara>Enfin, la récompense coinbase (<literal>nSubsidy</literal>) est ajoutée aux frais de transaction (<literal>nFees</literal>), et la somme est restituée.</simpara>
<informalexample>
<simpara>Si le nœud minier de Jing écrit la transaction coinbase, qu&#39;est-ce qui empêche Jing de se &quot;récompenser&quot; lui-même 100 ou 1000 bitcoins ? La réponse est qu&#39;une récompense incorrecte aurait pour conséquence que le bloc serait considéré comme invalide par tout le monde, gaspillant l&#39;électricité de Jing utilisée pour la preuve de travail. Jing ne peut dépenser la récompense que si le blocage est accepté par tout le monde.</simpara>
</informalexample>
</section>
<section id="_structure_de_la_transaction_coinbase">
<title>Structure de la transaction Coinbase</title>
<simpara><indexterm>
  <primary>&quot;coinbase transactions&quot;</primary><secondary>&quot;structure of&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;structure of&quot;</primary>
</indexterm>Avec ces calculs, le nœud de Jing construit ensuite la transaction coinbase pour se payer 25,09094928 bitcoins.</simpara>
<simpara>Comme vous pouvez le voir dans &lt;&lt;generation_tx_example&gt; &gt;, la transaction coinbase a un format spécial. Au lieu d&#39;une entrée de transaction spécifiant un UTXO précédent à dépenser, il a une entrée &quot;coinbase&quot;. Nous avons examiné les entrées de transaction dans &lt;&lt;tx_in_structure&gt; &gt;. Comparons une entrée de transaction régulière avec une entrée de transaction coinbase. &lt;&lt;table_8-1&gt; &gt; montre la structure d&#39;une entrée de transaction normale, tandis que &lt;&lt;table_8-2&gt; &gt; montre la structure de l&#39;entrée de la transaction coinbase.</simpara>
<table id="table_8-1"
frame="all"
rowsep="1" colsep="1"
>
<title>La structure d&#39;une entrée de transaction &quot;normale&quot;</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Taille</simpara></entry>
<entry align="left" valign="top"><simpara>Champ</simpara></entry>
<entry align="left" valign="top"><simpara>La description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Hachage de transaction</simpara></entry>
<entry align="left" valign="top"><simpara>Pointeur vers la transaction contenant l&#39;UTXO à dépenser</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Indice de sortie</simpara></entry>
<entry align="left" valign="top"><simpara>Le numéro d&#39;index de l&#39;UTXO à dépenser, le premier est 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1–9 octets (VarInt)</simpara></entry>
<entry align="left" valign="top"><simpara>Taille du script de déverrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>Longueur du script de déverrouillage en octets, à suivre</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>variables</simpara></entry>
<entry align="left" valign="top"><simpara>Déverrouillage-Script</simpara></entry>
<entry align="left" valign="top"><simpara>Un script remplissant les conditions du script de verrouillage UTXO</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Numéro de séquence</simpara></entry>
<entry align="left" valign="top"><simpara>Généralement défini sur 0xFFFFFFFF pour désactiver BIP 125 et BIP 68</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="table_8-2"
frame="all"
rowsep="1" colsep="1"
>
<title>La structure d&#39;une entrée de transaction coinbase</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Taille</simpara></entry>
<entry align="left" valign="top"><simpara>Champ</simpara></entry>
<entry align="left" valign="top"><simpara>La description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Hachage de transaction</simpara></entry>
<entry align="left" valign="top"><simpara>Tous les bits sont à zéro : pas une référence de hachage de transaction</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Indice de sortie</simpara></entry>
<entry align="left" valign="top"><simpara>Tous les bits sont des uns : 0xFFFFFFFF</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1–9 octets (VarInt)</simpara></entry>
<entry align="left" valign="top"><simpara>Taille des données Coinbase</simpara></entry>
<entry align="left" valign="top"><simpara>Longueur des données coinbase, de 2 à 100 octets</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>variables</simpara></entry>
<entry align="left" valign="top"><simpara>Données Coinbase</simpara></entry>
<entry align="left" valign="top"><simpara>Données arbitraires utilisées pour les nonce supplémentaires et les balises minières. Dans les blocs v2 ; doit commencer par la hauteur du bloc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Numéro de séquence</simpara></entry>
<entry align="left" valign="top"><simpara>Réglé sur 0xFFFFFFFF</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Dans une transaction coinbase, les deux premiers champs sont définis sur des valeurs qui ne représentent pas une référence UTXO. Au lieu d&#39;un &quot;hachage de transaction&quot;, le premier champ est rempli de 32 octets tous mis à zéro. &quot;L&#39;index de sortie&quot; est rempli de 4 octets tous mis à 0xFF (255 décimal). Le &quot;Script de déverrouillage&quot; (<literal>scriptSig</literal>) est remplacé par les données coinbase, un champ de données utilisé par les mineurs, comme nous le verrons ensuite.</simpara>
</section>
<section id="_données_coinbase">
<title>Données Coinbase</title>
<simpara><indexterm>
  <primary>&quot;coinbase transactions&quot;</primary><secondary>&quot;coinbase data&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;coinbase data&quot;</primary>
</indexterm>Les transactions Coinbase n&#39;ont pas de champ de script de déverrouillage (aka, <literal>scriptSig</literal>). Au lieu de cela, ce champ est remplacé par des données coinbase, qui doivent être comprises entre 2 et 100 octets. À l&#39;exception des premiers octets, le reste des données de coinbase peut être utilisé par les mineurs comme ils le souhaitent ; ce sont des données arbitraires.</simpara>
<simpara><indexterm>
  <primary>&quot;valeurs nonce&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;bloc de genèse&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;bloc de genèse&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blockchain (la)&quot;</primary><secondary>&quot;bloc de genèse&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;bloc de genèse&quot;</primary>
</indexterm>(((&quot;bloc de genèse&quot;)) ) Dans le bloc de genèse, par exemple, Satoshi Nakamoto a ajouté le texte &quot;The Times 03/Jan/2009 Chancellor on bound of second bailout for banks&quot; dans les données coinbase, l&#39;utilisant comme preuve de la date et pour transmettre un message. Actuellement, les mineurs utilisent les données coinbase pour inclure des valeurs nonce supplémentaires et des chaînes identifiant le pool de minage.</simpara>
<simpara>Les premiers octets de la coinbase étaient auparavant arbitraires, mais ce n&#39;est plus le cas. Conformément à BIP-34, les blocs de version 2 (blocs avec le champ de version défini sur 2) doivent contenir l&#39;index de hauteur de bloc en tant qu&#39;opération &quot;push&quot; de script au début du champ coinbase.</simpara>
<simpara>Dans le bloc 277 316, nous voyons que la coinbase (voir &lt;&lt;generation_tx_example&gt; &gt;), qui se trouve dans le script de déverrouillage ou le champ <literal>scriptSig</literal> de l&#39;entrée de transaction, contient la valeur hexadécimale <literal>03443b0403858402062f503253482f</literal>. Décodons cette valeur.</simpara>
<simpara>Le premier octet, <literal>03</literal>, indique au moteur d&#39;exécution de script de pousser les trois octets suivants sur la pile de script (voir &lt;&lt;tx_script_ops_table_pushdata&gt; &gt;). Les trois octets suivants, <literal>0x443b04</literal>, sont la hauteur de bloc encodée au format little-endian (en arrière, octet le moins significatif en premier). Inversez l&#39;ordre des octets et le résultat est <literal>0x043b44</literal>, soit 277 316 en décimal.</simpara>
<simpara>Les quelques chiffres hexadécimaux suivants (<literal>0385840206</literal>) sont utilisés pour coder un <emphasis>nonce</emphasis> supplémentaire (voir &lt;&lt;extra_nonce&gt; &gt;), ou valeur aléatoire, utilisée pour trouver une solution de preuve de travail appropriée.</simpara>
<simpara><indexterm>
  <primary>&quot;propositions d&#39;amélioration de bitcoin&quot;</primary><secondary>&quot;Pay to Script Hash (BIP-16)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Pay to Script Hash (BIP-16)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration de bitcoin&quot;</primary><secondary>&quot;CHECKHASHVERIFY (BIP-17)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;CHECKHASHVERIFY (BIP-17)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;CHECKHASHVERIFY (CHV )&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Pay-to-Script-Hash (P2SH)&quot;</primary><secondary>&quot; &lt;span class="keep-together"&gt;&lt;code&gt;/P2SH/&lt;/code&gt;&lt;/span&gt; data&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot; &lt;span class="keep-together"&gt;&lt;code&gt;/P2SH/&lt;/code&gt;&lt;/span&gt; data&quot;</primary>
</indexterm> &lt;span class="keep-together"&gt;&lt;code&gt;/P2SH/&lt;/code&gt;&lt;/span&gt; ], ce qui indique que le nœud de minage qui a miné ce bloc prend en charge l&#39;amélioration P2SH définie dans BIP-16. L&#39;introduction de la capacité P2SH a nécessité une signalisation par les mineurs pour approuver le BIP-16 ou le BIP-17. Ceux qui approuvaient la mise en œuvre du BIP-16 devaient inclure la chaîne <literal>/P2SH/</literal> dans leurs données coinbase. Ceux qui approuvaient l&#39;implémentation BIP-17 de P2SH devaient inclure la chaîne <literal>p2sh/CHV</literal> dans leurs données coinbase. Enfin, le BIP-16 a été élu vainqueur, et de nombreux mineurs ont continué à inclure la chaîne <literal>/P2SH/</literal> dans leur coinbase pour indiquer qu&#39;ils prennent en charge cette fonctionnalité.</simpara>
<simpara>&lt;&lt;satoshi_words&gt; &gt; utilise la bibliothèque libbitcoin introduite dans &lt;&lt;alt_libraries&gt; &gt; pour extraire les données coinbase du bloc genesis, affichant le message de Satoshi. Notez que la bibliothèque libbitcoin contient une copie statique du bloc genesis, de sorte que l&#39;exemple de code peut récupérer le bloc genesis directement à partir de la bibliothèque.</simpara>
<example id="satoshi_words">
<title>Extraire les données coinbase du bloc genesis</title>
<programlisting language="cpp" linenumbering="unnumbered">inclure::code/satoshi-words.cpp[]</programlisting>
</example>
<simpara>Nous compilons le code avec le compilateur GNU C++ et exécutons l&#39;exécutable résultant, comme indiqué dans &lt;&lt;satoshi_words_run&gt; &gt;.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;MACaggreg10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;MACaggreg10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Baggreg10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Baggreg10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Taggreg10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Taggreg10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Tcoinb10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Tcoinb10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;coinbtrans10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;coinbtrans10&quot;</primary>
</indexterm></simpara>
<example id="satoshi_words_run">
<title>Compilation et exécution de l&#39;exemple de code satoshi-words</title>
<programlisting language="bash" linenumbering="unnumbered"># Compiler le code
$ g++ -o satoshi-words satoshi-words.cpp $(pkg-config --cflags --libs libbitcoin)
# Lancer l&amp;#39;exécutable
$ ./mots satoshi
^D��&lt;GS&gt; ^A^DEThe Times 03/Jan/2009 La chancelière est sur le point de renflouer les banques</programlisting>
</example>
</section>
</section>
<section id="_construction_de_l_39_en_tête_de_bloc">
<title>Construction de l&#39;en-tête de bloc</title>
<simpara><indexterm>
  <primary>&quot;extraction et consensus&quot;</primary><secondary>&quot;construire des en-têtes de bloc&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;construire des en-têtes de bloc&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;en-têtes&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;en-têtes&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;en-têtes&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blockchain (la)&quot;</primary><secondary>&quot; en-têtes de bloc&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot; en-têtes de bloc&quot;</primary>
</indexterm> Pour construire l&#39;en-tête de bloc, le nœud d&#39;exploration de données doit remplir six champs, comme indiqué dans &lt;&lt;block_header_structure_ch10&gt; &gt;.</simpara>
<table id="block_header_structure_ch10"
frame="all"
rowsep="1" colsep="1"
>
<title>La structure de l&#39;entête du bloc</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Taille</simpara></entry>
<entry align="left" valign="top"><simpara>Champ</simpara></entry>
<entry align="left" valign="top"><simpara>La description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Version</simpara></entry>
<entry align="left" valign="top"><simpara>Un numéro de version pour suivre les mises à niveau du logiciel/protocole</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Hachage de bloc précédent</simpara></entry>
<entry align="left" valign="top"><simpara>Une référence au hachage du bloc précédent (parent) dans la chaîne</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Racine de Merkel</simpara></entry>
<entry align="left" valign="top"><simpara>Un hachage de la racine de l&#39;arbre Merkle des transactions de ce bloc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Horodatage</simpara></entry>
<entry align="left" valign="top"><simpara>Le temps de création approximatif de ce bloc (secondes à partir d&#39;Unix Epoch)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Cible</simpara></entry>
<entry align="left" valign="top"><simpara>La cible de l&#39;algorithme de preuve de travail pour ce bloc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Nonce</simpara></entry>
<entry align="left" valign="top"><simpara>Un compteur utilisé pour l&#39;algorithme Proof-of-Work</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Au moment où le bloc 277 316 a été miné, le numéro de version décrivant la structure du bloc est la version 2, qui est codée au format petit-boutiste sur 4 octets sous la forme <literal>0x02000000</literal>.</simpara>
<simpara><indexterm>
  <primary>&quot;blocks&quot;</primary><secondary>&quot;parent blocks&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;parent blocks&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;parent blocks&quot;</primary>
</indexterm>Ensuite, le nœud de minage doit ajouter le &quot;Previous Block Hash&quot; (également appelé <literal>prevhash</literal>). C&#39;est le hachage de l&#39;en-tête de bloc du bloc 277,315, le bloc précédent reçu du réseau, que le nœud de Jing a accepté et sélectionné comme <emphasis>parent</emphasis> du bloc candidat 277,316. Le hachage d&#39;en-tête de bloc pour le bloc 277 315 est :</simpara>
<screen>0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569</screen>
<informalexample>
<simpara>En sélectionnant le bloc <emphasis>parent</emphasis> spécifique, indiqué par le champ Hash du bloc précédent dans l&#39;en-tête du bloc candidat, Jing engage sa puissance minière à étendre la chaîne qui se termine dans ce bloc spécifique. En substance, c&#39;est ainsi que Jing &quot;vote&quot; avec son pouvoir minier pour la chaîne valide la plus longue.</simpara>
</informalexample>
<simpara><indexterm>
  <primary>&quot;arbres merkle&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blockchain (la)&quot;</primary><secondary>&quot;arbres merkle&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;arbres merkle&quot;</primary>
</indexterm>L&#39;étape suivante consiste à résumer toutes les transactions avec un arbre merkle, afin d&#39;ajouter la racine merkle à la en-tête de bloc. La transaction coinbase est répertoriée comme la première transaction du bloc. Ensuite, 418 transactions supplémentaires sont ajoutées après, pour un total de 419 transactions dans le bloc. Comme nous l&#39;avons vu dans le &lt;&lt;merkle_trees&gt; &gt;, il doit y avoir un nombre pair de nœuds &quot;feuilles&quot; dans l&#39;arbre, donc la dernière transaction est dupliquée, créant 420 nœuds, chacun contenant le hachage d&#39;une transaction. Les hachages de transaction sont ensuite combinés, par paires, créant chaque niveau de l&#39;arbre, jusqu&#39;à ce que toutes les transactions soient résumées en un nœud à la &quot;racine&quot; de l&#39;arbre. La racine de l&#39;arborescence merkle résume toutes les transactions en une seule valeur de 32 octets, que vous pouvez voir répertoriée comme &quot;racine merkle&quot; dans &lt;&lt;block277316&gt; &gt;, et ici :</simpara>
<screen>c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e</screen>
<simpara>Le nœud minier de Jing ajoutera alors un horodatage de 4 octets, codé comme un horodatage &quot;d&#39;époque&quot; Unix, qui est basé sur le nombre de secondes écoulées depuis minuit UTC, le jeudi 1er janvier 1970. L&#39;heure <literal>1388185914</literal> est égale à vendredi , 27 décembre 2013, 23:11:54 UTC.</simpara>
<simpara>Le nœud de Jing remplit ensuite la cible, qui définit la preuve de travail requise pour en faire un bloc valide. La cible est stockée dans le bloc en tant que métrique de &quot;bits cibles&quot;, qui est un codage d&#39;exposant de mantisse de la cible. Le codage a un exposant de 1 octet, suivi d&#39;une mantisse de 3 octets (coefficient). Dans le bloc 277 316, par exemple, la valeur des bits cibles est <literal>0x1903a30c</literal>. La première partie <literal>0x19</literal> est un exposant hexadécimal, tandis que la partie suivante, <literal>0x03a30c</literal>, est le coefficient. Le concept de cible est expliqué dans &lt;&lt;target&gt; &gt; et la représentation des &quot;bits cibles&quot; est expliquée dans &lt;&lt;target_bits&gt; &gt;.</simpara>
<simpara>Le dernier champ est le nonce, qui est initialisé à zéro.</simpara>
<simpara>Une fois tous les autres champs remplis, l&#39;en-tête du bloc est maintenant terminé et le processus d&#39;extraction peut commencer. L&#39;objectif est maintenant de trouver une valeur pour le nonce qui se traduit par un hachage d&#39;en-tête de bloc égal ou inférieur à la cible. Le nœud de minage devra tester des milliards ou des billions de valeurs de nonce avant de trouver un nonce qui réponde à l&#39;exigence.</simpara>
</section>
<section id="_miner_le_bloc">
<title>Miner le bloc</title>
<simpara><indexterm>
  <primary>&quot;mining and consensus&quot;</primary><secondary>&quot;mining the block&quot;</secondary><tertiary>id=&quot;MACmining10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;mining the block&quot;</primary><secondary>id=&quot;MACmining10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;MACmining10&quot;</primary>
</indexterm>Maintenant qu&#39;un bloc candidat a été construit par le nœud de Jing, il est temps pour la plate-forme de minage matériel de Jing de &quot;miner&quot; le bloc, pour trouver une solution à l&#39;algorithme de preuve de travail qui rend le bloc valide. Tout au long de ce livre, nous avons étudié les fonctions de hachage cryptographique utilisées dans divers aspects du système Bitcoin. La fonction de hachage SHA256 est la fonction utilisée dans le processus d&#39;extraction de bitcoin.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;jingten&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;jingten&quot;</primary>
</indexterm></simpara>
<simpara><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm> Dans les termes les plus simples, le minage est le processus de hachage répété de l&#39;en-tête de bloc, en modifiant un paramètre, jusqu&#39;à ce que le hachage résultant corresponde à une cible spécifique. Le résultat de la fonction de hachage ne peut pas être déterminé à l&#39;avance, pas plus qu&#39;un modèle ne peut être créé qui produira une valeur de hachage spécifique. Cette caractéristique des fonctions de hachage signifie que la seule façon de produire un résultat de hachage correspondant à une cible spécifique est d&#39;essayer encore et encore, en modifiant de manière aléatoire l&#39;entrée jusqu&#39;à ce que le résultat de hachage souhaité apparaisse par hasard.</simpara>
<section id="_algorithme_de_preuve_de_travail">
<title>Algorithme de preuve de travail</title>
<simpara><indexterm>
  <primary>&quot;Proof-of-Work algorithm&quot;</primary><secondary>id=&quot;proof10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;proof10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;mining and consensus&quot;</primary><secondary>&quot;Proof-of-Work algorithm&quot;</secondary><tertiary>id=&quot;Cproof10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Proof-of-Work algorithm&quot;</primary><secondary>id=&quot;Cproof10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Cproof10&quot;</primary>
</indexterm>Un algorithme de hachage prend une entrée de données de longueur arbitraire et produit un résultat déterministe de longueur fixe, une empreinte numérique de l&#39;entrée. Pour toute entrée spécifique, le hachage résultant sera toujours le même et peut être facilement calculé et vérifié par toute personne mettant en œuvre le même algorithme de hachage. <indexterm>
  <primary>&quot;collisions&quot;</primary>
</indexterm>La principale caractéristique d&#39;un algorithme de hachage cryptographique est qu&#39;il est impossible de trouver deux entrées différentes qui produisent la même empreinte digitale (appelée <emphasis>collision</emphasis>). En corollaire, il est également pratiquement impossible de sélectionner une entrée de manière à produire une empreinte digitale souhaitée, autrement qu&#39;en essayant des entrées aléatoires.</simpara>
<simpara>Avec SHA256, la sortie a toujours une longueur de 256 bits, quelle que soit la taille de l&#39;entrée. Dans &lt;&lt;sha256_example1&gt; &gt;, nous utiliserons l&#39;interpréteur Python pour calculer le hachage SHA256 de la phrase &quot;Je suis Satoshi Nakamoto&quot;.</simpara>
<simpara id="sha256_example1">Exemple .SHA256</simpara>
<informalexample>
<programlisting language="bash" linenumbering="unnumbered">$ python</programlisting>
<programlisting language="pycon" linenumbering="unnumbered">Python 3.7.3
&amp;gt;&amp;gt;&amp;gt; importer hashlib
&amp;gt;&amp;gt;&amp;gt; hashlib.sha256(b&amp;quot;Je suis Satoshi Nakamoto&amp;quot;).hexdigest()
&amp;#39;5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e&amp;#39;</programlisting>
</informalexample>
<simpara>&lt;&lt;sha256_example1&gt; &gt; montre le résultat du calcul du hachage de <literal>&quot;Je suis Satoshi Nakamoto&quot;</literal> : <literal>5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e</literal>. Ce nombre de 256 bits est le <emphasis>hash</emphasis> ou <emphasis>digest</emphasis> de la phrase et dépend de chaque partie de la phrase. L&#39;ajout d&#39;une seule lettre, d&#39;un signe de ponctuation ou de tout autre caractère produira un hachage différent.</simpara>
<simpara>Maintenant, si nous changeons la phrase, nous devrions nous attendre à voir des hachages complètement différents. Essayons cela en ajoutant un nombre à la fin de notre phrase, en utilisant le script Python simple dans &lt;&lt;sha256_example_generator&gt; &gt;.</simpara>
<simpara id="sha256_example_generator">Script .SHA256 pour générer de nombreux hachages en itérant sur un nonce</simpara>
<informalexample>
<programlisting language="python" linenumbering="unnumbered">inclure::code/hash_example.py[]</programlisting>
</informalexample>
<simpara>L&#39;exécution de ceci produira les hachages de plusieurs phrases, rendues différentes en ajoutant un nombre à la fin du texte. En incrémentant le nombre, nous pouvons obtenir différents hachages, comme indiqué dans &lt;&lt;sha256_example_generator_output&gt; &gt;.</simpara>
<example id="sha256_example_generator_output">
<title>SHA256 sortie d&#39;un script pour générer de nombreux hachages en itérant sur un nonce</title>
<programlisting language="bash" linenumbering="unnumbered">$ python hash_example.py</programlisting>
<screen>Je suis Satoshi Nakamoto0 =&amp;gt; a80a81401765c8eddee25df36728d732...
Je suis Satoshi Nakamoto1 =&amp;gt; f7bc9a6304a4647bb41241a677b5345f...
Je suis Satoshi Nakamoto2 =&amp;gt; ea758a8134b115298a1583ffb80ae629...
Je suis Satoshi Nakamoto3 =&amp;gt; bfa9779618ff072c903d773de30c99bd...
Je suis Satoshi Nakamoto4 =&amp;gt; bce8564de9a83c18c31944a66bde992f...
Je suis Satoshi Nakamoto5 =&amp;gt; eb362c3cf3479be0a97a20163589038e...
Je suis Satoshi Nakamoto6 =&amp;gt; 4a2fd48e3be420d0d28e202360cfbaba...
Je suis Satoshi Nakamoto7 =&amp;gt; 790b5a1349a5f2b909bf74d0d166b17a...
Je suis Satoshi Nakamoto8 =&amp;gt; 702c45e5b15aa54b625d68dd947f1597...
Je suis Satoshi Nakamoto9 =&amp;gt; 7007cf7dd40f5e933cd89fff5b791ff0...
Je suis Satoshi Nakamoto10 =&amp;gt; c2f38c81992f4614206a21537bd634a...
Je suis Satoshi Nakamoto11 =&amp;gt; 7045da6ed8a914690f087690e1e8d66...
Je suis Satoshi Nakamoto12 =&amp;gt; 60f01db30c1a0d4cbce2b4b22e88b9b...
Je suis Satoshi Nakamoto13 =&amp;gt; 0ebc56d59a34f5082aaef3d66b37a66...
Je suis Satoshi Nakamoto14 =&amp;gt; 27ead1ca85da66981fd9da01a8c6816...
Je suis Satoshi Nakamoto15 =&amp;gt; 394809fb809c5f83ce97ab554a2812c...
Je suis Satoshi Nakamoto16 =&amp;gt; 8fa4992219df33f50834465d3047429...
Je suis Satoshi Nakamoto17 =&amp;gt; dca9b8b4f8d8e1521fa4eaa46f4f0cd...
Je suis Satoshi Nakamoto18 =&amp;gt; 9989a401b2a3a318b01e9ca9a22b0f3...
Je suis Satoshi Nakamoto19 =&amp;gt; cda56022ecb5b67b2bc93a2d764e75f...</screen>
</example>
<simpara>Chaque phrase produit un résultat de hachage complètement différent. Ils semblent complètement aléatoires, mais vous pouvez reproduire les résultats exacts de cet exemple sur n&#39;importe quel ordinateur avec Python et voir les mêmes hachages exacts.</simpara>
<simpara>Le nombre utilisé comme variable dans un tel scénario est appelé un <emphasis>nonce</emphasis>. Le nonce est utilisé pour faire varier la sortie d&#39;une fonction cryptographique, dans ce cas pour faire varier l&#39;empreinte SHA256 de la phrase.</simpara>
<simpara>Pour relever le défi de cet algorithme, fixons-nous un objectif : trouver une phrase qui produit un hachage hexadécimal commençant par un zéro. Heureusement, ce n&#39;est pas difficile ! &lt;&lt;sha256_example_generator_output&gt; &gt; montre que la phrase &quot;I am Satoshi Nakamoto13&quot; produit le hash <literal>0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5</literal>, ce qui correspond à nos critères. Il a fallu 13 tentatives pour le trouver. En termes de probabilités, si la sortie de la fonction de hachage est uniformément distribuée, nous nous attendrions à trouver un résultat avec un 0 comme préfixe hexadécimal une fois tous les 16 hachages (un sur 16 chiffres hexadécimaux de 0 à F). En termes numériques, cela signifie trouver une valeur de hachage inférieure à <literal>0x100000000000000000000000000000000000000000000000000000000000</literal>. Nous appelons ce seuil la <emphasis>cible</emphasis> et le but est de trouver un hachage qui est numériquement égal ou inférieur à la cible. Si nous diminuons la cible, la tâche de trouver un hachage inférieur à la cible devient de plus en plus difficile.</simpara>
<simpara>Pour donner une analogie simple, imaginez un jeu où les joueurs lancent une paire de dés à plusieurs reprises, en essayant de lancer autant ou moins qu&#39;une cible spécifiée. Au premier tour, l&#39;objectif est de 11. À moins que vous ne lanciez un double-six, vous gagnez. Au tour suivant, l&#39;objectif est de 10. Les joueurs doivent lancer 10 ou moins pour gagner, encore une fois une tâche facile. Disons que quelques tours plus tard, l&#39;objectif est tombé à 5. Maintenant, plus de la moitié des lancers de dés dépasseront l&#39;objectif et seront donc invalides. Il faut exponentiellement plus de lancers de dés pour gagner, plus la cible est basse. Finalement, lorsque l&#39;objectif est de 2 (le minimum possible), un seul lancer sur 36, soit 2 % d&#39;entre eux, produira un résultat gagnant.</simpara>
<simpara>Du point de vue d&#39;un observateur qui sait que la cible du jeu de dés est 2, si quelqu&#39;un a réussi à lancer un lancer gagnant, on peut supposer qu&#39;il a tenté, en moyenne, 36 lancers. En d&#39;autres termes, on peut estimer la quantité de travail nécessaire pour réussir à partir de la difficulté imposée par la cible. Lorsque l&#39;algorithme est basé sur une fonction déterministe telle que SHA256, l&#39;entrée elle-même constitue la <emphasis>preuve</emphasis> qu&#39;une certaine quantité de <emphasis>travail</emphasis> a été effectuée pour produire un résultat égal ou inférieur à la cible. Par conséquent, <emphasis>Preuve de travail</emphasis>.</simpara>
<informalexample>
<simpara>Même si chaque tentative produit un résultat aléatoire, la probabilité de tout résultat possible peut être calculée à l&#39;avance. Par conséquent, un résultat d&#39;une difficulté spécifiée constitue la preuve d&#39;une quantité de travail spécifique.</simpara>
</informalexample>
<simpara>Dans &lt;&lt;sha256_example_generator_output&gt; &gt;, le &quot;nonce&quot; gagnant est 13 et ce résultat peut être confirmé par n&#39;importe qui indépendamment. N&#39;importe qui peut ajouter le nombre 13 comme suffixe à la phrase &quot;Je suis Satoshi Nakamoto&quot; et calculer le hachage, en vérifiant qu&#39;il est inférieur à la cible. Le résultat réussi est également une preuve de travail, car cela prouve que nous avons fait le travail pour trouver ce nonce. Alors qu&#39;il ne faut qu&#39;un seul calcul de hachage pour vérifier, il nous a fallu 13 calculs de hachage pour trouver un nonce qui a fonctionné. Si nous avions une cible inférieure (difficulté plus élevée), il faudrait beaucoup plus de calculs de hachage pour trouver un nonce approprié, mais un seul calcul de hachage pour que quiconque puisse le vérifier. De plus, en connaissant la cible, n&#39;importe qui peut estimer la difficulté à l&#39;aide de statistiques et donc savoir combien de travail a été nécessaire pour trouver un tel nonce.</simpara>
<informalexample>
<simpara>La preuve de travail doit produire un hachage qui est <emphasis>égal ou inférieur à</emphasis> la cible. Une cible plus élevée signifie qu&#39;il est moins difficile de trouver un hachage égal ou inférieur à la cible. Une cible inférieure signifie qu&#39;il est plus difficile de trouver un hachage égal ou inférieur à la cible. La cible et la difficulté sont inversement liées.</simpara>
</informalexample>
<simpara><indexterm>
  <primary>&quot;cibles&quot;</primary>
</indexterm> La preuve de travail de Bitcoin est très similaire au défi présenté dans &lt;&lt;sha256_example_generator_output&gt; &gt;. Le mineur construit un bloc candidat rempli de transactions. Ensuite, le mineur calcule le hachage de l&#39;en-tête de ce bloc et voit s&#39;il est égal ou inférieur à la <emphasis>target</emphasis> actuelle. Si le hachage est supérieur à la cible, le mineur modifiera le nonce (généralement en l&#39;incrémentant simplement de un) et réessayera. À la difficulté actuelle du réseau Bitcoin, les mineurs doivent essayer des quadrillions de fois avant de trouver un nonce qui se traduit par un hachage d&#39;en-tête de bloc suffisamment bas.</simpara>
<simpara>Un algorithme de preuve de travail très simplifié est implémenté en Python dans &lt;&lt;pow_example1&gt; &gt;.</simpara>
<example id="pow_example1">
<title>Mise en œuvre simplifiée de la preuve de travail</title>
<programlisting language="python" linenumbering="unnumbered">#!/usr/bin/env python
# example of proof-of-work algorithm

import hashlib
import time

max_nonce = 2 ** 32 # 4 billion

def proof_of_work(header, difficulty_bits):

    # calculate the difficulty target
    target = 2 ** (256-difficulty_bits)

    for nonce in xrange(max_nonce):
        hash_result = hashlib.sha256(str(header)+str(nonce)).hexdigest()

        # check if this is a valid result, below the target
        if long(hash_result, 16) &lt; target:
            print "Success with nonce %d" % nonce
            print "Hash is %s" % hash_result
            return (hash_result,nonce)

    print "Failed after %d (max_nonce) tries" % nonce
    return nonce


if __name__ == '__main__':

    nonce = 0
    hash_result = ''

    # difficulty from 0 to 31 bits
    for difficulty_bits in xrange(32):

        difficulty = 2 ** difficulty_bits
        print "Difficulty: %ld (%d bits)" % (difficulty, difficulty_bits)

        print "Starting search..."

        # checkpoint the current time
        start_time = time.time()

        # make a new block which includes the hash from the previous block
        # we fake a block of transactions - just a string
        new_block = 'test block with transactions' + hash_result

        # find a valid nonce for the new block
        (hash_result, nonce) = proof_of_work(new_block, difficulty_bits)

        # checkpoint how long it took to find a result
        end_time = time.time()

        elapsed_time = end_time - start_time
        print "Elapsed Time: %.4f seconds" % elapsed_time

        if elapsed_time &gt; 0:

            # estimate the hashes per second
            hash_power = float(long(nonce)/elapsed_time)
            print "Hashing Power: %ld hashes per second" % hash_power</programlisting>
</example>
<simpara>En exécutant ce code, vous pouvez définir la difficulté souhaitée (en bits, combien de bits de tête doivent être nuls) et voir combien de temps il faut à votre ordinateur pour trouver une solution. Dans &lt;&lt;pow_example_outputs&gt; &gt;, vous pouvez voir comment cela fonctionne sur un ordinateur portable moyen.</simpara>
<example id="pow_example_outputs">
<title>Exécution de l&#39;exemple de preuve de travail pour diverses difficultés</title>
<programlisting language="bash" linenumbering="unnumbered">$ python preuve-de-travail-exemple.py*</programlisting>
<screen>Difficulté : 1 (0 bits)

[...]

Difficulté : 8 (3 bits)
Lancement de la recherche...
Succès avec nonce 9
Le hachage est 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1
Temps écoulé : 0,0004 seconde
Puissance de hachage : 25 065 hachages par seconde
Difficulté : 16 (4 bits)
Lancement de la recherche...
Succès avec nonce 25
Le hachage est 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148
Temps écoulé : 0,0005 seconde
Puissance de hachage : 52 507 hachages par seconde
Difficulté : 32 (5 bits)
Lancement de la recherche...
Succès avec nonce 36
Le hachage est 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903
Temps écoulé : 0,0006 seconde
Puissance de hachage : 58 164 hachages par seconde

[...]

Difficulté : 4194304 (22 bits)
Lancement de la recherche...
Succès avec nonce 1759164
Le hachage est 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3
Temps écoulé : 13,3201 secondes
Puissance de hachage : 132 068 hachages par seconde
Difficulté : 8388608 (23 bits)
Lancement de la recherche...
Succès avec nonce 14214729
Le hachage est 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3
Temps écoulé : 110,1507 secondes
Puissance de hachage : 129 048 hachages par seconde
Difficulté : 16777216 (24 bits)
Lancement de la recherche...
Succès avec nonce 24586379
Le hachage est 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95
Temps écoulé : 195,2991 secondes
Puissance de hachage : 125 890 hachages par seconde

[...]

Difficulté : 67108864 (26 bits)
Lancement de la recherche...
Succès avec nonce 84561291
Le hachage est 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a
Temps écoulé : 665,0949 secondes
Puissance de hachage : 127 141 hachages par seconde</screen>
</example>
<simpara>Comme vous pouvez le constater, augmenter la difficulté de 1 bit entraîne un doublement du temps nécessaire pour trouver une solution. Si vous pensez à l&#39;ensemble de l&#39;espace numérique de 256 bits, chaque fois que vous contraignez un bit de plus à zéro, vous réduisez l&#39;espace de recherche de moitié. Dans &lt;&lt;pow_example_outputs&gt; &gt;, il faut 84 millions de tentatives de hachage pour trouver un nonce qui produit un hachage avec 26 bits de tête comme zéro. Même à une vitesse de plus de 120 000 hachages par seconde, il faut tout de même 10 minutes sur un portable pour trouver cette solution.</simpara>
<simpara>Au moment de la rédaction, le réseau tente de trouver un bloc dont le hachage d&#39;en-tête est égal ou inférieur à :</simpara>
<screen>0000000000000000029AB900000000000000000000000000000000000000000</screen>
<simpara>Comme vous pouvez le voir, il y a beaucoup de zéros au début de cette cible, ce qui signifie que la plage acceptable de hachages est beaucoup plus petite, il est donc plus difficile de trouver un hachage valide. Il faudra en moyenne plus de 1,8 hachages zêta (mille milliards de milliards de hachages) pour que le réseau découvre le bloc suivant. Cela semble être une tâche impossible, mais heureusement, le réseau apporte 3 exa-hachages par seconde (EH/sec) de puissance de traitement, ce qui permettra de trouver un bloc en environ 10 minutes en moyenne.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Cproof10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Cproof10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;proof10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;proof10&quot;</primary>
</indexterm></simpara>
</section>
<section id="target_bits">
<title>Représentation cible</title>
<simpara><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;minage du bloc&quot;</secondary><tertiary>&quot;représentation cible&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;minage du bloc&quot;</primary><secondary>&quot;représentation cible&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;représentation cible&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cibles&quot;</primary><secondary>id=&quot;cibles10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;cibles10&quot;</primary>
</indexterm>Dans &lt;&lt;block277316&gt; &gt;, nous avons vu que le bloc contient la cible, dans une notation appelée &quot;target bits&quot; ou simplement &quot;bits&quot;, qui dans le bloc 277 316 a la valeur <literal>0x1903a30c</literal>. Cette notation exprime la cible de preuve de travail sous la forme d&#39;un format coefficient/exposant, avec les deux premiers chiffres hexadécimaux pour l&#39;exposant et les six chiffres hexadécimaux suivants pour le coefficient. Dans ce bloc, par conséquent, l&#39;exposant est <literal>0x19</literal> et le coefficient est <literal>0x03a30c</literal>.</simpara>
<simpara>La formule pour calculer la cible de difficulté à partir de cette représentation est :</simpara>
<ul class="simplelist">
  <li>cible = coefficient * 2 <sup>(8*(exposant–3))</sup></li>
</ul>
<simpara>En utilisant cette formule et la valeur des bits de difficulté 0x1903a30c, nous obtenons :</simpara>
<ul class="simplelist">
  <li>cible = 0x03a30c * 2 <sup>0x08*(0x19-0x03)</sup></li>
  <li>=&gt; cible = 0x03a30c * 2 <sup>(0x08*0x16)</sup></li>
  <li>=&gt; cible = 0x03a30c * 2 <sup>0xB0</sup></li>
</ul>
<simpara>qui en décimal est :</simpara>
<ul class="simplelist">
  <li>=&gt; cible = 238 348 * 2 <sup>176</sup></li>
  <li>=&gt; cible =<br/> 22 829 202 948 393 929 850 749 706 076 701 368 331 072 452 018 388 575 715 328</li>
</ul>
<simpara>retour en hexadécimal :</simpara>
<ul class="simplelist">
  <li>=&gt; cible =<br/> 0x0000000000000003A30C000000000000000000000000000000000000000000</li>
</ul>
<simpara>Cela signifie qu&#39;un bloc valide pour la hauteur 277 316 est celui qui a un hachage d&#39;en-tête de bloc inférieur à cette cible. En binaire, ce nombre doit avoir plus de 60 bits de tête mis à zéro. Avec ce niveau de difficulté, un seul mineur traitant 1 billion de hachages par seconde (1 terahash par seconde ou 1 TH/sec) ne trouverait une solution qu&#39;une fois tous les 8 496 blocs ou une fois tous les 59 jours, en moyenne.</simpara>
</section>
<section id="cible">
<title>Reciblage pour ajuster la difficulté</title>
<simpara><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;minage du bloc&quot;</secondary><tertiary>&quot;retargeting pour ajuster la difficulté&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;minage du bloc&quot;</primary><secondary>&quot;retargeting pour ajuster la difficulté&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;retargeting pour ajuster la difficulté&quot;</primary>
</indexterm> Comme nous l&#39;avons vu, la cible détermine la difficulté et affecte donc le temps qu&#39;il faut pour trouver une solution au Proof-of- Algorithme de travail. Cela conduit à des questions évidentes : pourquoi la difficulté est-elle ajustable, qui l&#39;ajuste et comment ?</simpara>
<simpara>Les blocs de Bitcoin sont générés toutes les 10 minutes, en moyenne. C&#39;est le battement de cœur de bitcoin et sous-tend la fréquence d&#39;émission de devises et la rapidité de règlement des transactions. Il doit rester constant non seulement à court terme, mais sur une période de plusieurs décennies. Au cours de cette période, on s&#39;attend à ce que la puissance des ordinateurs continue d&#39;augmenter à un rythme rapide. De plus, le nombre de participants à l&#39;exploitation minière et les ordinateurs qu&#39;ils utilisent changeront également constamment. Pour maintenir le temps de génération de bloc à 10 minutes, la difficulté de minage doit être ajustée pour tenir compte de ces changements. En fait, la cible de preuve de travail est un paramètre dynamique qui est périodiquement ajusté pour atteindre un objectif d&#39;intervalle de bloc de 10 minutes. En termes simples, l&#39;objectif est défini de sorte que la puissance minière actuelle se traduise par un intervalle de bloc de 10 minutes.</simpara>
<simpara>Comment, alors, un tel ajustement s&#39;effectue-t-il dans un réseau totalement décentralisé ? Le reciblage se produit automatiquement et sur chaque nœud indépendamment. Tous les 2 016 blocs, tous les nœuds reciblent la preuve de travail. L&#39;équation de reciblage mesure le temps qu&#39;il a fallu pour trouver les 2 016 derniers blocs et le compare au temps prévu de 20 160 minutes (2 016 blocs multipliés par l&#39;intervalle de bloc de 10 minutes souhaité). Le rapport entre la durée réelle et la durée souhaitée est calculé et un ajustement proportionnel (à la hausse ou à la baisse) est apporté à la cible. En termes simples : si le réseau trouve des blocs plus rapidement que toutes les 10 minutes, la difficulté augmente (la cible diminue). Si la découverte de blocs est plus lente que prévu, la difficulté diminue (la cible augmente).</simpara>
<simpara>L&#39;équation peut se résumer ainsi :</simpara>
<screen>Nouvel objectif = Ancien objectif * (Heure réelle des 2016 derniers blocs / 20160 minutes)</screen>
<simpara>&lt;&lt;retarget_code&gt; &gt; montre le code utilisé dans le client Bitcoin Core.</simpara>
<example id="retarget_code">
<title>Retargeting la preuve de travail—CalculateNextWorkRequired() dans pow.cpp</title>
<programlisting language="cpp" linenumbering="unnumbered">   // Limiter le pas de réglage
    int64_t nActualTimespan = pindexLast-&amp;gt;GetBlockTime() - nFirstBlockTime ;
    LogPrintf(&amp;quot; nActualTimespan = %d avant les limites\n&amp;quot;, nActualTimespan);
    si (nActualTimespan &amp;lt; params.nPowTargetTimespan/4)
        nActualTimespan = params.nPowTargetTimespan/4 ;
    si (nActualTimespan &amp;gt; params.nPowTargetTimespan*4)
        nActualTimespan = params.nPowTargetTimespan*4 ;

    // Recibler
    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);
    arith_uint256 bnNew ;
    arith_uint256 bnOld ;
    bnNew.SetCompact(pindexLast-&amp;gt;nBits);
    bnAncien = bnNouveau ;
    bnNew *= nActualTimespan ;
    bnNew /= params.nPowTargetTimespan ;

    si (bnNew &amp;gt; bnPowLimit)
        bnNouveau = bnPowLimit ;</programlisting>
</example>
<informalexample>
<simpara>Bien que l&#39;étalonnage cible se produise tous les 2 016 blocs, en raison d&#39;une erreur de un par un dans le client Bitcoin Core d&#39;origine, il est basé sur le temps total des 2 015 blocs précédents (et non 2 016 comme il se doit), ce qui entraîne un biais de reciblage vers une difficulté plus élevée de 0,05 %.</simpara>
</informalexample>
<simpara>Les paramètres <literal>Interval</literal> (2 016 blocs) et <literal>TargetTimespan</literal> (deux semaines en 1 209 600 secondes) sont définis dans <emphasis>chainparams.cpp</emphasis>.</simpara>
<simpara>Pour éviter une volatilité extrême de la difficulté, l&#39;ajustement de reciblage doit être inférieur à un facteur quatre (4) par cycle. Si l&#39;ajustement cible requis est supérieur à un facteur de quatre, il sera ajusté d&#39;un facteur de 4 et pas plus. Tout autre ajustement sera effectué au cours de la prochaine période de reciblage, car le déséquilibre persistera au cours des 2 016 prochains blocs. Par conséquent, des écarts importants entre la puissance de hachage et la difficulté peuvent nécessiter plusieurs cycles de blocs de 2 016 pour s&#39;équilibrer.</simpara>
<informalexample>
<simpara>La difficulté d&#39;extraction d&#39;un bloc de bitcoins est d&#39;environ &#39;10 minutes de traitement&#39; pour l&#39;ensemble du réseau, sur la base du temps qu&#39;il a fallu pour extraire les 2 016 blocs précédents, ajusté tous les 2 016 blocs. Ceci est réalisé en abaissant ou en élevant la cible.</simpara>
</informalexample>
<simpara>Notez que la cible est indépendante du nombre de transactions ou de la valeur des transactions. Cela signifie que la quantité de puissance de hachage et donc d&#39;électricité dépensée pour sécuriser le bitcoin est également entièrement indépendante du nombre de transactions. Bitcoin peut évoluer, parvenir à une adoption plus large et rester sécurisé sans aucune augmentation de la puissance de hachage par rapport au niveau actuel. L&#39;augmentation de la puissance de hachage représente les forces du marché alors que de nouveaux mineurs entrent sur le marché pour concourir pour la récompense. Tant qu&#39;une puissance de hachage suffisante est sous le contrôle des mineurs agissant honnêtement à la recherche de la récompense, cela suffit pour empêcher les attaques de &quot;prise de contrôle&quot; et, par conséquent, c&#39;est suffisant pour sécuriser le bitcoin.</simpara>
<simpara>La difficulté du minage est étroitement liée au coût de l&#39;électricité et au taux de change du bitcoin vis-à-vis de la monnaie utilisée pour payer l&#39;électricité. Les systèmes de minage hautes performances sont à peu près aussi efficaces que possible avec la génération actuelle de fabrication de silicium, convertissant l&#39;électricité en calcul de hachage au taux le plus élevé possible. La principale influence sur le marché minier est le prix d&#39;un kilowattheure d&#39;électricité en bitcoin, car cela détermine la rentabilité du minage et donc les incitations à entrer ou à sortir du marché minier.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;targets10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;targets10&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="_réussir_à_miner_le_bloc">
<title>Réussir à miner le bloc</title>
<simpara><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;minage du bloc&quot;</secondary><tertiary>&quot;achèvement réussi&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;minage du bloc&quot;</primary><secondary>&quot;achèvement réussi&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;achèvement réussi&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;minage de bitcoin&quot;</secondary><tertiary>id=&quot;jingtentwo&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;minage de bitcoin&quot;</primary><secondary>id=&quot;jingtentwo&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;jingtentwo&quot;</primary>
</indexterm>Comme nous l&#39;avons vu précédemment, Jing&#39;s node a construit un bloc candidat et l&#39;a préparé pour le minage. Jing possède plusieurs plates-formes de minage de matériel avec des circuits intégrés spécifiques à l&#39;application, où des centaines de milliers de circuits intégrés exécutent l&#39;algorithme SHA256 en parallèle à des vitesses incroyables. Beaucoup de ces machines spécialisées sont connectées à son nœud minier via USB ou un réseau local. Ensuite, le nœud de minage exécuté sur le bureau de Jing transmet l&#39;en-tête de bloc à son matériel de minage, qui commence à tester des milliards de nonces par seconde. Parce que le nonce n&#39;est que de 32 bits, après avoir épuisé toutes les possibilités de nonce (environ 4 milliards), le matériel de minage modifie l&#39;en-tête de bloc (en ajustant l&#39;espace ou l&#39;horodatage supplémentaire du nonce coinbase) et réinitialise le compteur de nonce, en testant de nouvelles combinaisons.</simpara>
<simpara>Près de 11 minutes après avoir commencé à miner le bloc 277 316, l&#39;une des machines de minage de matériel trouve une solution et la renvoie au nœud de minage.</simpara>
<simpara>Lorsqu&#39;il est inséré dans l&#39;en-tête de bloc, le nonce 924 591 752 produit un hachage de bloc de :</simpara>
<screen>0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4</screen>
<simpara>qui est inférieur à la cible :</simpara>
<screen>0000000000000003A30C000000000000000000000000000000000000000000</screen>
<simpara>Immédiatement, le nœud minier de Jing transmet le bloc à tous ses pairs. Ils reçoivent, valident puis propagent le nouveau bloc. Au fur et à mesure que le bloc se répand sur le réseau, chaque nœud l&#39;ajoute à sa propre copie de la blockchain, l&#39;étendant à une nouvelle hauteur de 277 316 blocs. Au fur et à mesure que les nœuds miniers reçoivent et valident le bloc, ils abandonnent leurs efforts pour trouver un bloc à la même hauteur et commencent immédiatement à calculer le bloc suivant dans la chaîne, en utilisant le bloc de Jing comme &quot;parent&quot;. En construisant sur le bloc nouvellement découvert de Jing, les autres mineurs &quot;votent&quot; essentiellement avec leur puissance minière et approuvent le bloc de Jing et la chaîne qu&#39;il prolonge.</simpara>
<simpara>Dans la section suivante, nous examinerons le processus utilisé par chaque nœud pour valider un bloc et sélectionner la chaîne la plus longue, créant ainsi le consensus qui forme la blockchain décentralisée.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;MACmining10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;MACmining10&quot;</primary>
</indexterm>(( (&quot;&quot;, startref=&quot;jingtentwo&quot;)))</simpara>
</section>
<section id="_validation_d_39_un_nouveau_bloc">
<title>Validation d&#39;un nouveau bloc</title>
<simpara><indexterm>
  <primary>&quot;mining and consensus&quot;</primary><secondary>&quot;new block validation&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;new block validation&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocks&quot;</primary><secondary>&quot;new block validation&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;new block validation&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;validation&quot;</primary>
</indexterm>La troisième étape du mécanisme de consensus de bitcoin est indépendante validation de chaque nouveau bloc par chaque nœud du réseau. Au fur et à mesure que le bloc nouvellement résolu se déplace sur le réseau, chaque nœud effectue une série de tests pour le valider avant de le propager à ses pairs. Cela garantit que seuls les blocs valides sont propagés sur le réseau. La validation indépendante garantit également que les mineurs qui agissent honnêtement obtiennent leurs blocs incorporés dans la blockchain, gagnant ainsi la récompense. Les mineurs qui agissent de manière malhonnête voient leurs blocs rejetés et non seulement perdent la récompense, mais gaspillent également les efforts déployés pour trouver une solution de preuve de travail, encourant ainsi le coût de l&#39;électricité sans compensation.</simpara>
<simpara>Lorsqu&#39;un nœud reçoit un nouveau bloc, il valide le bloc en le comparant à une longue liste de critères qui doivent tous être remplis ; sinon, le bloc est rejeté. Ces critères peuvent être vus dans le client Bitcoin Core dans les fonctions <literal>CheckBlock</literal> et <literal>CheckBlockHeader</literal> et incluent :</simpara>
<itemizedlist>
<listitem>
<simpara>
La structure de données du bloc est syntaxiquement valide
</simpara>
</listitem>
<listitem>
<simpara>
Le hachage de l&#39;en-tête de bloc est égal ou inférieur à la cible (applique la preuve de travail)
</simpara>
</listitem>
<listitem>
<simpara>
L&#39;horodatage du bloc est inférieur à deux heures dans le futur (en tenant compte des erreurs de temps)
</simpara>
</listitem>
<listitem>
<simpara>
La taille du bloc est dans les limites acceptables
</simpara>
</listitem>
<listitem>
<simpara>
La première transaction (et seulement la première) est une transaction coinbase
</simpara>
</listitem>
<listitem>
<simpara>
Toutes les transactions dans le bloc sont valides en utilisant la liste de contrôle des transactions décrite dans &lt;&lt;tx_verification&gt; &gt;
</simpara>
</listitem>
</itemizedlist>
<simpara>La validation indépendante de chaque nouveau bloc par chaque nœud du réseau garantit que les mineurs ne peuvent pas tricher. Dans les sections précédentes, nous avons vu comment les mineurs peuvent écrire une transaction qui leur attribue le nouveau bitcoin créé dans le bloc et réclamer les frais de transaction. Pourquoi les mineurs n&#39;écrivent-ils pas eux-mêmes une transaction pour mille bitcoins au lieu de la bonne récompense ? Parce que chaque nœud valide les blocs selon les mêmes règles. Une transaction coinbase invalide rendrait l&#39;ensemble du bloc invalide, ce qui entraînerait le rejet du bloc et, par conséquent, cette transaction ne ferait jamais partie du grand livre. Les mineurs doivent construire un bloc parfait, basé sur les règles partagées que tous les nœuds suivent, et l&#39;exploiter avec une solution correcte à la preuve de travail. Pour ce faire, ils dépensent beaucoup d&#39;électricité dans l&#39;exploitation minière, et s&#39;ils trichent, toute l&#39;électricité et les efforts sont gaspillés. C&#39;est pourquoi la validation indépendante est un élément clé du consensus décentralisé.</simpara>
</section>
<section id="_assemblage_et_sélection_de_chaînes_de_blocs">
<title>Assemblage et sélection de chaînes de blocs</title>
<simpara><indexterm>
  <primary>&quot;extraction et consensus&quot;</primary><secondary>&quot;assemblage et sélection de chaînes de blocs&quot;</secondary><tertiary>id=&quot;MACassembling10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;assemblage et sélection de chaînes de blocs&quot;</primary><secondary>id=&quot;MACassembling10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;MACassembling10&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;assemblage et sélection de chaînes de&quot;</secondary><tertiary>id=&quot;Bassemble10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;assemblage et sélection de chaînes de&quot;</primary><secondary>id=&quot;Bassemble10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Bassemble10&quot;</primary>
</indexterm>Le La dernière étape du mécanisme de consensus décentralisé de Bitcoin est l&#39;assemblage de blocs en chaînes et la sélection de la chaîne avec le plus de preuves de travail. Une fois qu&#39;un nœud a validé un nouveau bloc, il tentera alors d&#39;assembler une chaîne en connectant le bloc à la blockchain existante.</simpara>
<simpara>Les nœuds maintiennent trois ensembles de blocs : ceux connectés à la blockchain principale, ceux qui forment des branches de la blockchain principale (chaînes secondaires) et enfin, les blocs qui n&#39;ont pas de parent connu dans les chaînes connues (orphelins). Les blocs invalides sont rejetés dès que l&#39;un des critères de validation échoue et ne sont donc inclus dans aucune chaîne.</simpara>
<simpara>La &quot;chaîne principale&quot; à tout moment est la chaîne de blocs <emphasis>valide</emphasis> à laquelle est associée la preuve de travail la plus cumulative. Dans la plupart des cas, il s&#39;agit également de la chaîne contenant le plus de blocs, à moins qu&#39;il n&#39;y ait deux chaînes de longueur égale et que l&#39;une ait plus de preuve de travail. La chaîne principale aura également des branches avec des blocs qui sont des &quot;frères et sœurs&quot; des blocs de la chaîne principale. Ces blocs sont valides mais ne font pas partie de la chaîne principale. Elles sont conservées pour référence future, au cas où l&#39;une de ces chaînes serait étendue au-delà de la chaîne principale en cours. Dans la section suivante (&lt;&lt;forks&gt; &gt;), nous verrons comment des chaînes secondaires se produisent à la suite d&#39;une extraction quasi simultanée de blocs à la même hauteur.</simpara>
<simpara>Lorsqu&#39;un nouveau bloc est reçu, un nœud essaie de l&#39;insérer dans la blockchain existante. Le nœud examinera le champ &quot;hachage du bloc précédent&quot; du bloc, qui est la référence au parent du bloc. Ensuite, le nœud tentera de trouver ce parent dans la blockchain existante. La plupart du temps, le parent sera la &quot;pointe&quot; de la chaîne principale, ce qui signifie que ce nouveau bloc étend la chaîne principale. Par exemple, le nouveau bloc 277,316 a une référence au hachage de son bloc parent 277,315. La plupart des nœuds qui reçoivent 277 316 auront déjà le bloc 277 315 comme pointe de leur chaîne principale et relieront donc le nouveau bloc et étendront cette chaîne.</simpara>
<simpara>Parfois, comme nous le verrons dans &lt;&lt;forks&gt; &gt;, le nouveau bloc prolonge une chaîne qui n&#39;est pas la chaîne principale. Dans ce cas, le nœud attachera le nouveau bloc à la chaîne secondaire qu&#39;il prolonge, puis comparera le travail de la chaîne secondaire à la chaîne principale. Si la chaîne secondaire a plus de travail cumulé que la chaîne principale, le nœud <emphasis>reconvergera</emphasis> sur la chaîne secondaire, ce qui signifie qu&#39;il sélectionnera la chaîne secondaire comme sa nouvelle chaîne principale, faisant de l&#39;ancienne chaîne principale une chaîne secondaire. Si le nœud est un mineur, il construira maintenant un bloc étendant cette nouvelle chaîne plus longue.</simpara>
<simpara>Si un bloc valide est reçu et qu&#39;aucun parent n&#39;est trouvé dans les chaînes existantes, ce bloc est considéré comme &quot;orphelin&quot;. Les blocs orphelins sont enregistrés dans le pool de blocs orphelins où ils resteront jusqu&#39;à ce que leur parent soit reçu. Une fois que le parent est reçu et lié aux chaînes existantes, l&#39;orphelin peut être retiré du pool d&#39;orphelins et lié au parent, ce qui en fait une partie d&#39;une chaîne. Les blocs orphelins se produisent généralement lorsque deux blocs extraits dans un court laps de temps sont reçus dans l&#39;ordre inverse (enfant avant parent).</simpara>
<simpara>En sélectionnant la chaîne valide de plus grand travail cumulé, tous les nœuds finissent par parvenir à un consensus à l&#39;échelle du réseau. Les divergences temporaires entre les chaînes sont finalement résolues au fur et à mesure que du travail est ajouté, étendant l&#39;une des chaînes possibles. Les nœuds de minage « votent » avec leur puissance de minage en choisissant quelle chaîne étendre en minant le bloc suivant. Lorsqu&#39;ils exploitent un nouveau bloc et étendent la chaîne, le nouveau bloc lui-même représente leur vote.</simpara>
<simpara>Dans la section suivante, nous verrons comment les divergences entre les chaînes concurrentes (forks) sont résolues par la sélection indépendante de la chaîne de plus grand travail cumulatif.</simpara>
<section id="fourches">
<title>Fourchettes Blockchain</title>
<simpara><indexterm>
  <primary>&quot;extraction et consensus&quot;</primary><secondary>&quot;assemblage et sélection de chaînes de blocs&quot;</secondary><tertiary>&quot;forks de blockchain&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;assemblage et sélection de chaînes de blocs&quot;</primary><secondary>&quot;forks de blockchain&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;forks de blockchain&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blockchain (la)&quot;</primary><secondary>&quot;forks de blockchain&quot;</secondary><tertiary>id=&quot;BCTfork10&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;forks de blockchain&quot;</primary><secondary>id=&quot;BCTfork10&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCTfork10&quot;</primary>
</indexterm>(( (&quot;forks&quot;, &quot;blockchain fork events&quot;, id=&quot;forks10&quot;)))Parce que la blockchain est une structure de données décentralisée, différentes copies de celle-ci ne sont pas toujours cohérentes. Les blocs peuvent arriver à différents nœuds à des moments différents, ce qui amène les nœuds à avoir différentes perspectives de la blockchain. Pour résoudre ce problème, chaque nœud sélectionne et tente toujours d&#39;étendre la chaîne de blocs qui représente le plus de preuve de travail, également connue sous le nom de chaîne la plus longue ou de chaîne de travail cumulative la plus importante. En additionnant le travail enregistré dans chaque bloc d&#39;une chaîne, un nœud peut calculer la quantité totale de travail qui a été dépensée pour créer cette chaîne. Tant que tous les nœuds sélectionnent la plus grande chaîne de travail cumulatif, le réseau mondial Bitcoin finit par converger vers un état cohérent. Les fourches se produisent sous forme d&#39;incohérences temporaires entre les versions de la blockchain, qui sont résolues par une éventuelle reconvergence à mesure que d&#39;autres blocs sont ajoutés à l&#39;une des fourches.</simpara>
<informalexample>
<simpara>Les fourches de blockchain décrites dans cette section se produisent naturellement (accidentellement) en raison de retards de transmission dans le réseau mondial. Plus loin dans ce chapitre, nous verrons également les forks délibérément induits (hard forks et soft forks), qui sont utilisés pour modifier les règles de consensus.</simpara>
</informalexample>
<simpara>Dans les quelques diagrammes suivants, nous suivons la progression d&#39;un événement &quot;fork&quot; à travers le réseau. Le diagramme est une représentation simplifiée du réseau Bitcoin. À des fins d&#39;illustration, différents blocs sont représentés sous différentes formes (étoile, triangle, triangle inversé, losange), répartis sur le réseau. Chaque nœud du réseau est représenté par un cercle.</simpara>
<simpara>Chaque nœud a sa propre perspective de la blockchain mondiale. Au fur et à mesure que chaque nœud reçoit des blocs de ses voisins, il met à jour sa propre copie de la blockchain, en sélectionnant la plus grande chaîne de travail cumulée. À des fins d&#39;illustration, chaque nœud contient une forme qui représente le bloc qui, selon lui, est actuellement la pointe de la chaîne principale. Donc, si vous voyez une forme d&#39;étoile dans le nœud, cela signifie que le bloc en étoile est la pointe de la chaîne principale, en ce qui concerne ce nœud.</simpara>
<simpara>Dans le premier diagramme (&lt;&lt;fork1&gt; &gt;), le réseau a une perspective unifiée de la blockchain, avec le bloc étoile comme pointe de la chaîne principale.</simpara>
<figure id="fork1"><title>Avant la bifurcation—tous les nœuds ont la même perspective</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1002.png"/>
  </imageobject>
  <textobject><phrase>&quot;Avant la bifurcation - tous les nœuds ont la même perspective&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara>Un &quot;fork&quot; se produit chaque fois qu&#39;il y a deux blocs valides différents à la même hauteur de bloc en compétition pour former la blockchain la plus longue. Cela se produit dans des conditions normales chaque fois que deux mineurs résolvent l&#39;algorithme de preuve de travail dans un court laps de temps l&#39;un de l&#39;autre. Alors que les deux mineurs découvrent une solution pour leurs blocs candidats respectifs, ils diffusent immédiatement leur propre bloc &quot;gagnant&quot; à leurs voisins immédiats qui commencent à propager le bloc sur le réseau. Chaque nœud qui reçoit un bloc valide l&#39;incorpore dans sa blockchain, étendant la blockchain d&#39;un bloc. Si ce nœud voit plus tard un autre bloc valide étendre le même parent (à la même hauteur de bloc), il connecte le deuxième bloc sur une chaîne secondaire, bifurquant sa chaîne principale. En conséquence, certains nœuds &quot;verront&quot; un bloc gagnant en premier, tandis que d&#39;autres nœuds verront l&#39;autre bloc gagnant en premier, et deux versions concurrentes de la blockchain émergeront.</simpara>
<simpara>Dans &lt;&lt;fork2&gt; &gt;, on voit deux mineurs (Node X et Node Y) qui minent deux blocs différents presque simultanément. Ces deux blocs sont des enfants du bloc étoile et étendent la chaîne en s&#39;appuyant sur le bloc étoile. Pour nous aider à le suivre, l&#39;un est visualisé comme un bloc triangulaire provenant du nœud X, et l&#39;autre est représenté comme un bloc triangulaire inversé provenant du nœud Y.</simpara>
<figure id="fork2"><title>Visualisation d&#39;un événement fork blockchain : deux blocs trouvés simultanément</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1003.png"/>
  </imageobject>
  <textobject><phrase>&quot;Visualisation d&#39;un événement fork blockchain : deux blocs trouvés simultanément&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara>Supposons, par exemple, que le mineur Node X trouve une solution de preuve de travail pour un bloc &quot;triangle&quot; qui étend la blockchain, en s&#39;appuyant sur le bloc parent &quot;étoile&quot;. Presque simultanément, le mineur Node Y qui étendait également la chaîne du bloc &quot;étoile&quot; trouve une solution pour le bloc &quot;triangle inversé&quot;, son bloc candidat. Maintenant, il y a deux blocs possibles ; un que nous appelons &quot;triangle&quot;, originaire du Nœud X ; et un que nous appelons &quot;triangle inversé&quot;, originaire du nœud Y. Les deux blocs ont été extraits avec succès, les deux blocs sont valides (contiennent une solution valide à la preuve de travail), et les deux blocs étendent le même parent (bloc &quot; Star&quot;). Les deux blocs contiennent probablement la plupart des mêmes transactions, avec seulement peut-être quelques différences dans l&#39;ordre des transactions.</simpara>
<simpara>Au fur et à mesure que les deux blocs se propagent, certains nœuds reçoivent d&#39;abord le bloc &quot;triangle&quot; et d&#39;autres reçoivent le bloc &quot;triangle inversé&quot; en premier. Comme indiqué dans &lt;&lt;fork3&gt; &gt;, le réseau se scinde en deux perspectives différentes de la blockchain ; un côté surmonté du bloc triangle, l&#39;autre du bloc triangle renversé.</simpara>
<figure id="fork3"><title>Visualization of a blockchain fork event: two blocks propagate, splitting the network</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1004.png"/>
  </imageobject>
  <textobject><phrase>Visualization of a blockchain fork event: two blocks propagate, splitting the network</phrase></textobject>
</mediaobject>
</figure>
<simpara>In <xref linkend="fork3"/>, the miner Node X mined (created) the triangle block and extended the star chain with it. Therefore, Node X initially considers the chain with "triangle" block as the main chain. Later, Node X also received the "upside-down triangle" block that was mined by Node Y. Since it was received second, it is assumed to have "lost" the race. Yet, the "upside-down triangle" block is not discarded. It is linked to the "star" block parent and forms a secondary chain. While Node X assumes its main chain is the winning chain, it keeps the "losing" chain so that it has the information needed to reconverge if the "losing" chain ends up "winning."</simpara>
<simpara>On the other side of the network, the miner Node Y constructs a blockchain based on its own perspective of the sequence of events. The miner Node Y mined (created) the "upside-down triangle" and initially considers that chain as the main chain (the "winner" chain). When it later received the "triangle" block that was mined by Node X, it connected it to the "star" block parent as a secondary chain.</simpara>
<simpara>Neither side is "correct," or "incorrect." Both are valid perspectives of the blockchain. Only in hindsight will one prevail, based on how these two competing chains are extended by additional work.</simpara>
<simpara>Each mining node whose perspective resembles Node X will immediately begin mining a candidate block that extends the chain with "triangle" as its tip. By linking "triangle" as the parent of their candidate blocks, they are voting with their hashing power. Their vote supports the chain that they have elected as the main chain.</simpara>
<simpara>Any mining node whose perspective resembles Node Y will start building a candidate block with "upside-down triangle" as its parent, extending the chain that they believe is the main chain. And so, the race begins again.</simpara>
<simpara>Forks are almost always resolved within one block time (10 minutes on average). While part of the network&#8217;s hashing power is dedicated to building on top of "triangle" as the parent, another part of the hashing power is focused on building on top of "upside-down triangle." Even if the hashing power is almost evenly split, it is likely that one set of miners will find a solution and propagate it before the other set of miners have found any solutions. Let&#8217;s say, for example, that the miners building on top of "triangle" find a new block "rhombus" that extends the chain (e.g., star-triangle-rhombus). They immediately propagate this new block and the entire network sees it as a valid solution as shown in <xref linkend="fork4"/>.</simpara>
<simpara>All nodes that had chosen "triangle" as the winner in the previous round will simply extend the chain one more block. The nodes that chose "upside-down triangle" as the winner, however, will now see two chains: star-triangle-rhombus and star-upside-down-triangle. The chain star-triangle-rhombus is now longer (more cumulative work) than the other chain. As a result, those nodes will set the chain star-triangle-rhombus as the main chain and change the star-upside-down-triangle chain to a secondary chain, as shown in <xref linkend="fork5"/>. This is a chain reconvergence, because those nodes are forced to revise their view of the blockchain to incorporate the new evidence of a longer chain. Any miners working on extending the chain star-upside-down-triangle will now stop that work because their candidate block is now considered a child of a stale block, as its parent "upside-down-triangle" is no longer on the longest chain. Since the upside-down-triangle block is now obsolete, the miner Node Y (which mined this block) will not be able to spend the mining reward for this block, even though this block was valid and was successfully mined. The transactions within "upside-down-triangle" that are not within "triangle" are re-inserted in the mempool for inclusion in the next block to become a part of the main chain. The entire network reconverges on a single blockchain star-triangle-rhombus, with "rhombus" as the last block in the chain. All miners immediately start working on candidate blocks that reference "rhombus" as their parent to extend the star-triangle-rhombus chain.</simpara>
<figure id="fork4"><title>Visualization of a blockchain fork event: a new block extends one fork, reconverging the network. Both Node X and Node Y now consider "upside-down-triangle" block as a stale block.</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1005.png"/>
  </imageobject>
  <textobject><phrase>Visualization of a blockchain fork event: a new block extends one fork</phrase></textobject>
</mediaobject>
</figure>
<figure id="fork5"><title>Visualization of a blockchain fork event: the network reconverges on a new longest chain</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1006.png"/>
  </imageobject>
  <textobject><phrase>Visualization of a blockchain fork event: the network reconverges on a new longest chain</phrase></textobject>
</mediaobject>
</figure>
<simpara>It is theoretically possible for a fork to extend to two blocks, if two blocks are found almost simultaneously by miners on opposite "sides" of a previous fork. However, the chance of that happening is very low. Whereas a one-block fork might occur every day, a two-block fork occurs at most once every few weeks.</simpara>
<simpara>Bitcoin&#8217;s block interval of 10 minutes is a design compromise between fast confirmation times (settlement of transactions) and the probability of a fork. A faster block time would make transactions clear faster but lead to more frequent blockchain forks, whereas a slower block time would decrease the number of forks but make settlement slower.<indexterm>
  <primary></primary>
</indexterm><indexterm>
  <primary></primary>
</indexterm><indexterm>
  <primary></primary>
</indexterm><indexterm>
  <primary></primary>
</indexterm></simpara>
</section>
</section>
<section id="_mining_and_the_hashing_race">
<title>Mining and the Hashing Race</title>
<simpara><indexterm>
  <primary>mining and consensus</primary><secondary>hashing power race</secondary>
</indexterm>
<indexterm>
  <primary>hashing power race</primary>
</indexterm>Bitcoin mining is an extremely competitive industry. The hashing power has increased exponentially every year of bitcoin&#8217;s existence. Some years the growth has reflected a complete change of technology, such as in 2010 and 2011 when many miners switched from using CPU mining to GPU mining and field programmable gate array (FPGA) mining. In 2013 the introduction of ASIC mining lead to another giant leap in mining power, by placing the SHA256 function directly on silicon chips specialized for the purpose of mining. The first such chips could deliver more mining power in a single box than the entire Bitcoin network in 2010.</simpara>
<simpara>The following list shows the total hashing power of the Bitcoin network in terahashes/sec (TH/sec), since its inception in 2009 (source: Blockchain.com):</simpara>
<variablelist>
<varlistentry>
<term>
2009
</term>
<listitem>
<simpara>
0.000004 – 0.00001 TH/sec (2.40&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2010
</term>
<listitem>
<simpara>
0.00001 – 0.14 TH/sec (14,247&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2011
</term>
<listitem>
<simpara>
0.14 – 9.49 TH/sec (63.92&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2012
</term>
<listitem>
<simpara>
9.49 – 22 TH/sec (2.32&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2013
</term>
<listitem>
<simpara>
22.04 – 15,942 TH/sec (723.32&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2014
</term>
<listitem>
<simpara>
15,942 – 306,333 TH/sec (19.21&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2015
</term>
<listitem>
<simpara>
306,333 – 881,232 TH/sec (2.87&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2016
</term>
<listitem>
<simpara>
881,232 – 2,807,540 TH/sec (3.18&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2017
</term>
<listitem>
<simpara>
2,807,540 – 18,206,558 TH/sec (6.48&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2018
</term>
<listitem>
<simpara>
18,206,558 – 41,801,528 TH/sec (2.29&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2019
</term>
<listitem>
<simpara>
41,801,528 – 109,757,127 TH/sec (2.62&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
2020
</term>
<listitem>
<simpara>
109,757,127 – 149,064,869 TH/sec (1.35&#x00D7; growth)
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>In the chart in <xref linkend="network_hashing_power"/>, we can see that Bitcoin network&#8217;s hashing power increased over the past two years. As you can see, the competition between miners and the growth of bitcoin has resulted in an exponential increase in the hashing power (total hashes per second across the network).</simpara>
<figure id="network_hashing_power"><title>Total hashing power, terahashes per second (TH/sec) (chart on a linear scale)</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1007.png"/>
  </imageobject>
  <textobject><phrase>NetworkHashingRate</phrase></textobject>
</mediaobject>
</figure>
<simpara>As the amount of hashing power applied to mining bitcoin has exploded, the difficulty has risen to match it. The difficulty metric in the chart shown in <xref linkend="bitcoin_difficulty"/> is measured as a ratio of current difficulty over minimum difficulty (the difficulty of the first block).</simpara>
<figure id="bitcoin_difficulty"><title>Bitcoin&#8217;s mining difficulty metric (chart on a logarithmic scale)</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1008.png"/>
  </imageobject>
  <textobject><phrase>BitcoinDifficulty</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the last two years, the ASIC mining chips have become increasingly denser, approaching the cutting edge of silicon fabrication with a feature size (resolution) of 7 nanometers (nm). Currently, ASIC manufacturers are aiming to overtake general-purpose CPU chip manufacturers, designing chips with a feature size of 5 nm, because the profitability of mining is driving this industry even faster than general computing. There are no more giant leaps left in bitcoin mining, because the industry has reached the forefront of Moore&#8217;s Law, which stipulates that computing density will double approximately every 18 months. Still, the mining power of the network continues to advance at an exponential pace as the race for higher density chips is matched with a race for higher density data centers where thousands of these chips can be deployed. It&#8217;s no longer about how much mining can be done with one chip, but how many chips can be squeezed into a building, while still dissipating the heat and providing adequate power.</simpara>
<section id="extra_nonce">
<title>The Extra Nonce Solution</title>
<simpara><indexterm>
  <primary>nonce values</primary>
</indexterm>Since 2012, bitcoin mining has evolved to resolve a fundamental limitation in the structure of the block header. In the early days of bitcoin, a miner could find a block by iterating through the nonce until the resulting hash was equal to or below the target. As difficulty increased, miners often cycled through all 4 billion values of the nonce without finding a block. However, this was easily resolved by updating the block timestamp to account for the elapsed time. Because the timestamp is part of the header, the change would allow miners to iterate through the values of the nonce again with different results.  Once mining hardware exceeded 4 GH/sec, however, this approach became increasingly difficult because the nonce values were exhausted in less than a second. As ASIC mining equipment started pushing and then exceeding the TH/sec hash rate, the mining software needed more space for nonce values in order to find valid blocks. The timestamp could be stretched a bit, but moving it too far into the future would cause the block to become invalid. A new source of "change" was needed in the block header. The solution was to use the coinbase transaction as a source of extra nonce values. Because the coinbase script can store between 2 and 100 bytes of data, miners started using that space as extra nonce space, allowing them to explore a much larger range of block header values to find valid blocks. The coinbase transaction is included in the merkle tree, which means that any change in the coinbase script causes the merkle root to change. Eight bytes of extra nonce, plus the 4 bytes of "standard" nonce allow miners to explore a total 2<superscript>96</superscript> (8 followed by 28 zeros) possibilities <emphasis>per second</emphasis> without having to modify the timestamp. If, in the future, miners could run through all these possibilities, they could then modify the timestamp. There is also more space in the coinbase script for future expansion of the extra nonce space.</simpara>
</section>
<section id="mining_pools">
<title>Mining Pools</title>
<simpara><indexterm>
  <primary>mining pools</primary>
</indexterm><indexterm>
  <primary>mining pools</primary><secondary>benefits of</secondary>
</indexterm>
<indexterm>
  <primary>benefits of</primary>
</indexterm>In this highly competitive environment, individual miners working alone (also known as solo miners) don&#8217;t stand a chance. The likelihood of them finding a block to offset their electricity and hardware costs is so low that it represents a gamble, like playing the lottery. Even the fastest consumer ASIC mining system cannot keep up with commercial systems that stack tens of thousands of these chips in giant warehouses near hydroelectric powerstations. Miners now collaborate to form mining pools, pooling their hashing power and sharing the reward among thousands of participants. By participating in a pool, miners get a smaller share of the overall reward, but typically get rewarded every day, reducing uncertainty.</simpara>
<simpara>Let&#8217;s look at a specific example. Assume a miner has purchased mining hardware with a combined hashing rate of 14,000 gigahashes per second (GH/s), or 14 TH/s. In 2017 this equipment costs approximately $2,500 USD. The hardware consumes 1375 watts (1.3 kW) of electricity when running, 33 kW-hours a day, at a cost of $1 to $2 per day at very low electricity rates. At current bitcoin difficulty, the miner will be able to solo mine a block approximately once every 4 years. How do we work out that probability? It is based on a network-wide hashing rate of 3 EH/sec (in 2017), and the miner&#8217;s rate of 14 TH/sec:</simpara>
<ul class="simplelist">
  <li>P = (14 * 10<sup>12</sup> / 3 * 10<sup>18</sup>) * 210240 = 0.98</li>
</ul>
<simpara>&#8230;where 210240 is the number of blocks in four years. The miner has a 98% probability of finding a block over four years, based on the global hash rate at the beginning of the period.</simpara>
<simpara>If the miner does find a single block in that timeframe, the payout of 6.25 bitcoin, at approximately $1,000 per bitcoin, will result in a single payout of $6,250, which will produce a net profit of about $750. However, the chance of finding a block in a 4-year period depends on the miner&#8217;s luck. He might find two blocks in 4 years and make a larger profit. Or he might not find a block for 5 years and suffer a big financial loss. Even worse, the difficulty of the bitcoin Proof-of-Work algorithm is likely to go up significantly over that period, at the current rate of growth of hashing power, meaning the miner has, at most, one year to break even before the hardware is effectively obsolete and must be replaced by more powerful mining hardware. Financially this only makes sense at very low electricity cost (less than 1 cent per kW-hour) and only at very large scale.</simpara>
<simpara>Mining pools coordinate many hundreds or thousands of miners, over specialized pool-mining protocols. The individual miners configure their mining equipment to connect to a pool server, and specify a Bitcoin address, which will receive their share of the rewards. Their mining hardware remains connected to the pool server while mining, synchronizing their efforts with the other miners. Thus, the pool miners share the effort to mine a block and then share in the rewards.</simpara>
<simpara>Successful blocks pay the reward to a pool Bitcoin address, rather than individual miners. The pool server will periodically make payments to the miners' Bitcoin addresses, once their share of the rewards has reached a certain threshold. Typically, the pool server charges a percentage fee of the rewards for providing the pool-mining service.</simpara>
<simpara><indexterm>
  <primary>mining pools</primary><secondary>operation of</secondary>
</indexterm>
<indexterm>
  <primary>operation of</primary>
</indexterm>Miners participating in a pool split the work of searching for a solution to a candidate block, earning "shares" for their mining contribution. The mining pool sets a higher target (lower difficulty) for earning a share, typically more than 1,000 times easier than the Bitcoin network&#8217;s target. When someone in the pool successfully mines a block, the reward is earned by the pool and then shared with all miners in proportion to the number of shares they contributed to the effort.</simpara>
<simpara>Pools are open to any miner, big or small, professional or amateur. A pool will therefore have some participants with a single small mining machine, and others with a garage full of high-end mining hardware. Some will be mining with a few tens of a kilowatt of electricity, others will be running a data center consuming a megawatt of power. How does a mining pool measure the individual contributions, so as to fairly distribute the rewards, without the possibility of cheating? The answer is to use bitcoin&#8217;s Proof-of-Work algorithm to measure each pool miner&#8217;s contribution, but set at a lower difficulty so that even the smallest pool miners win a share frequently enough to make it worthwhile to contribute to the pool. By setting a lower difficulty for earning shares, the pool measures the amount of work done by each miner. Each time a pool miner finds a block header hash that is equal to or less than the pool target, she proves she has done the hashing work to find that result. More importantly, the work to find shares contributes, in a statistically measurable way, to the overall effort to find a hash equal to or lower than the Bitcoin network&#8217;s target. Thousands of miners trying to find low-value hashes will eventually find one low enough to satisfy the Bitcoin network target.</simpara>
<simpara>Let&#8217;s return to the analogy of a dice game. If the dice players are throwing dice with a goal of throwing equal to or less than four (the overall network difficulty), a pool would set an easier target, counting how many times the pool players managed to throw equal to or less than eight. When pool players throw equal to or less than eight (the pool share target) but higher than four (higher than the overall network difficulty), they earn shares, but neither they nor the pool win the game because they don&#8217;t achieve the game target (equal to or less than four). The pool players will achieve the easier pool target much more often, earning them shares very regularly, even when they don&#8217;t achieve the harder target of winning the game. Every now and then, one of the pool players will throw a combined dice throw of equal to or less than four, the pool player wins a share and the whole pool wins the game. Then, the earnings can be distributed to the pool players based on the amount of shares each one has earned. Even though the target of eight-or-less wasn&#8217;t winning, it was a fair way to measure dice throws for the players, and it occasionally produces a four-or-less throw.</simpara>
<simpara>Similarly, a mining pool will set a (higher and easier) pool target that will ensure that an individual pool miner can find block header hashes that are equal to or less than the pool target often, earning shares. Every now and then, one of these attempts will produce a block header hash that is equal to or less than the Bitcoin network target, making it a valid block and the whole pool wins.</simpara>
<section id="_managed_pools">
<title>Managed pools</title>
<simpara><indexterm>
  <primary>mining pools</primary><secondary>managed pools</secondary>
</indexterm>
<indexterm>
  <primary>managed pools</primary>
</indexterm><indexterm>
  <primary>pool operators</primary>
</indexterm>Most mining pools are "managed," meaning that there is a company or individual running a pool server. The owner of the pool server is called the <emphasis>pool operator</emphasis>, and he charges pool miners a percentage fee of the earnings.</simpara>
<simpara>The pool server runs specialized software and a pool-mining protocol that coordinate the activities of the pool miners. The pool server is also connected to one or more full Bitcoin nodes and has direct access to a full copy of the blockchain database. This allows the pool server to validate blocks and transactions on behalf of the pool miners, relieving them of the burden of running a full node. For pool miners, this is an important consideration, because a full node requires a dedicated computer with at least 300 to 350 GB of persistent storage (disk) and at least 2 to 4 GB of memory (RAM). Furthermore, the bitcoin software running on the full node needs to be monitored, maintained, and upgraded frequently. Any downtime caused by a lack of maintenance or lack of resources will hurt the miner&#8217;s profitability. For many miners, the ability to mine without running a full node is another big benefit of joining a managed pool.</simpara>
<simpara>Pool miners connect to the pool server using a mining protocol such as Stratum (STM) or GetBlockTemplate (GBT). An older standard called GetWork (GWK) has been mostly obsolete since late 2012, because it does not easily support mining at hash rates above 4 GH/s. Both the STM and GBT protocols create block <emphasis>templates</emphasis> that contain a template of a candidate block header. The pool server constructs a candidate block by aggregating transactions, adding a coinbase transaction (with extra nonce space), calculating the merkle root, and linking to the previous block hash. The header of the candidate block is then sent to each of the pool miners as a template. Each pool miner then mines using the block template, at a higher (easier) target than the Bitcoin network target, and sends any successful results back to the pool server to earn shares.</simpara>
</section>
<section id="_peer_to_peer_mining_pool_p2pool">
<title>Peer-to-peer mining pool (P2Pool)</title>
<simpara><indexterm>
  <primary>mining pools</primary><secondary>peer-to-peer pools (P2Pool)</secondary>
</indexterm>
<indexterm>
  <primary>peer-to-peer pools (P2Pool)</primary>
</indexterm><indexterm>
  <primary>peer-to-peer pools (P2Pool)</primary>
</indexterm>Managed pools create the possibility of cheating by the pool operator, who might direct the pool effort to double-spend transactions or invalidate blocks (see <xref linkend="consensus_attacks"/>). Furthermore, centralized pool servers represent a single-point-of-failure. If the pool server is down or is slowed by a denial-of-service attack, the pool miners cannot mine. In 2011, to resolve these issues of centralization, a new pool mining method was proposed and implemented: P2Pool, a peer-to-peer mining pool without a central operator.</simpara>
<simpara>P2Pool works by decentralizing the functions of the pool server, implementing a parallel blockchain-like system called a <emphasis>share chain</emphasis>. A share chain is a blockchain running at a lower difficulty than the Bitcoin blockchain. The share chain allows pool miners to collaborate in a decentralized pool by mining shares on the share chain at a rate of one share block every 30 seconds. Each of the blocks on the share chain records a proportionate share reward for the pool miners who contribute work, carrying the shares forward from the previous share block. When one of the share blocks also achieves the Bitcoin network target, it is propagated and included on the Bitcoin blockchain, rewarding all the pool miners who contributed to all the shares that preceded the winning share block. Essentially, instead of a pool server keeping track of pool miner shares and rewards, the share chain allows all pool miners to keep track of all shares using a decentralized consensus mechanism like bitcoin&#8217;s blockchain consensus mechanism.</simpara>
<simpara>P2Pool mining is more complex than pool mining because it requires that the pool miners run a dedicated computer with enough disk space, memory, and internet bandwidth to support a full Bitcoin node and the P2Pool node software. P2Pool miners connect their mining hardware to their local P2Pool node, which simulates the functions of a pool server by sending block templates to the mining hardware. On P2Pool, individual pool miners construct their own candidate blocks, aggregating transactions much like solo miners, but then mine collaboratively on the share chain. P2Pool is a hybrid approach that has the advantage of much more granular payouts than solo mining, but without giving too much control to a pool operator like managed pools.</simpara>
<simpara>Even though P2Pool reduces the concentration of power by mining pool operators, it is conceivably vulnerable to 51% attacks against the share chain itself. A much broader adoption of P2Pool does not solve the 51% attack problem for bitcoin itself. Rather, P2Pool makes bitcoin more robust overall, as part of a diversified mining ecosystem.<indexterm>
  <primary></primary>
</indexterm><indexterm>
  <primary></primary>
</indexterm></simpara>
</section>
</section>
</section>
<section id="consensus_attacks">
<title>Consensus Attacks</title>
<simpara><indexterm>
  <primary>mining and consensus</primary><secondary>consensus attacks</secondary>
</indexterm>
<indexterm>
  <primary>consensus attacks</primary>
</indexterm><indexterm>
  <primary>security</primary><secondary>consensus attacks</secondary>
</indexterm>
<indexterm>
  <primary>consensus attacks</primary>
</indexterm>Bitcoin&#8217;s consensus mechanism is, at least theoretically, vulnerable to attack by miners (or pools) that attempt to use their hashing power to dishonest or destructive ends. As we saw, the consensus mechanism depends on having a majority of the miners acting honestly out of self-interest. However, if a miner or group of miners can achieve a significant share of the mining power, they can attack the consensus mechanism so as to disrupt the security and availability of the Bitcoin network.</simpara>
<simpara>It is important to note that consensus attacks can only affect future consensus, or at best, the most recent past (tens of blocks). Bitcoin&#8217;s ledger becomes more and more immutable as time passes. While in theory, a fork can be achieved at any depth, in practice, the computing power needed to force a very deep fork is immense, making old blocks practically immutable. Consensus attacks also do not affect the security of the private keys and signing algorithm (ECDSA). A consensus attack cannot steal bitcoin, spend bitcoin without signatures, redirect bitcoin, or otherwise change past transactions or ownership records. <indexterm>
  <primary>denial-of-service attacks</primary>
</indexterm><indexterm>
  <primary>security</primary><secondary>denial-of-service attacks</secondary>
</indexterm>
<indexterm>
  <primary>denial-of-service attacks</primary>
</indexterm>Consensus attacks can only affect the most recent blocks and cause denial-of-service disruptions on the creation of future blocks.</simpara>
<simpara>One attack scenario against the consensus mechanism is called the "51% attack." In this scenario a group of miners, controlling a majority (51%) of the total network&#8217;s hashing power, collude to attack bitcoin. With the ability to mine the majority of the blocks, the attacking miners can cause deliberate "forks" in the blockchain and double-spend transactions or execute denial-of-service attacks against specific transactions or addresses. A fork/double-spend attack is where the attacker causes previously confirmed blocks to be invalidated by forking below them and re-converging on an alternate chain. With sufficient power, an attacker can invalidate six or more blocks in a row, causing transactions that were considered immutable (six confirmations) to be invalidated. Note that a double-spend can only be done on the attacker&#8217;s own transactions, for which the attacker can produce a valid signature. Double-spending one&#8217;s own transactions is profitable if by invalidating a transaction the attacker can get an irreversible exchange payment or product without paying for it.</simpara>
<simpara>Let&#8217;s examine a practical example of a 51% attack. In the first chapter, we looked at a transaction between <indexterm>
  <primary>use cases</primary><secondary>buying coffee</secondary>
</indexterm>
<indexterm>
  <primary>buying coffee</primary>
</indexterm>Alice and Bob for a cup of coffee. Bob, the cafe owner, is willing to accept payment for cups of coffee without waiting for confirmation (mining in a block), because the risk of a double-spend on a cup of coffee is low in comparison to the convenience of rapid customer service. This is similar to the practice of coffee shops that accept credit card payments without a signature for amounts below $25, because the risk of a credit-card chargeback is low while the cost of delaying the transaction to obtain a signature is comparatively larger. In contrast, selling a more expensive item for bitcoin runs the risk of a double-spend attack, where the buyer broadcasts a competing transaction that spends the same inputs (UTXO) and cancels the payment to the merchant. A double-spend attack can happen in two ways: either before a transaction is confirmed, or if the attacker takes advantage of a blockchain fork to undo several blocks. A 51% attack allows attackers to double-spend their own transactions in the new chain, thus undoing the corresponding transaction in the old chain.</simpara>
<simpara>In our example, malicious attacker Mallory goes to <indexterm>
  <primary>use cases</primary><secondary>retail sales</secondary>
</indexterm>
<indexterm>
  <primary>retail sales</primary>
</indexterm>Carol&#8217;s gallery and purchases a beautiful triptych painting depicting Satoshi Nakamoto as Prometheus. Carol sells "The Great Fire" paintings for $250,000 in bitcoin to Mallory. Instead of waiting for six or more confirmations on the transaction, Carol wraps and hands the paintings to Mallory after only one confirmation. Mallory works with an accomplice, Paul, who operates a large mining pool, and the accomplice launches a 51% attack as soon as Mallory&#8217;s transaction is included in a block. Paul directs the mining pool to remine the same block height as the block containing Mallory&#8217;s transaction, replacing Mallory&#8217;s payment to Carol with a transaction that double-spends the same input as Mallory&#8217;s payment. The double-spend transaction consumes the same UTXO and pays it back to Mallory&#8217;s wallet, instead of paying it to Carol, essentially allowing Mallory to keep the bitcoin. Paul then directs the mining pool to mine an additional block, so as to make the chain containing the double-spend transaction longer than the original chain (causing a fork below the block containing Mallory&#8217;s transaction). When the blockchain fork resolves in favor of the new (longer) chain, the double-spent transaction replaces the original payment to Carol. Carol is now missing the three paintings and also has no bitcoin payment. Throughout all this activity, Paul&#8217;s mining pool participants might remain blissfully unaware of the double-spend attempt, because they mine with automated miners and cannot monitor every transaction or block.<indexterm>
  <primary></primary>
</indexterm></simpara>
<simpara><indexterm>
  <primary>"confirmations"</primary><secondary>"of large-value transactions"</secondary><tertiary>secondary-sortas="large-value transactions"</tertiary>
</indexterm>
<indexterm>
  <primary>"of large-value transactions"</primary><secondary>secondary-sortas="large-value transactions"</secondary>
</indexterm>
<indexterm>
  <primary>secondary-sortas="large-value transactions"</primary>
</indexterm>To protect against this kind of attack, a merchant selling large-value items must wait at least six confirmations before giving the product to the buyer. Alternatively, the merchant should use an escrow multisignature account, again waiting for several confirmations after the escrow account is funded. The more confirmations elapse, the harder it becomes to invalidate a transaction with a 51% attack. For high-value items, payment by bitcoin will still be convenient and efficient even if the buyer has to wait 24 hours for delivery, which would correspond to approximately 144 confirmations.</simpara>
<simpara>In addition to a double-spend attack, the other scenario for a consensus attack is to deny service to specific bitcoin participants (specific Bitcoin addresses). An attacker with a majority of the mining power can simply ignore specific transactions. If they are included in a block mined by another miner, the attacker can deliberately fork and remine that block, again excluding the specific transactions. This type of attack can result in a sustained denial-of-service against a specific address or set of addresses for as long as the attacker controls the majority of the mining power.</simpara>
<simpara>Despite its name, the 51% attack scenario doesn&#8217;t actually require 51% of the hashing power. In fact, such an attack can be attempted with a smaller percentage of the hashing power. The 51% threshold is simply the level at which such an attack is almost guaranteed to succeed. A consensus attack is essentially a tug-of-war for the next block and the "stronger" group is more likely to win. With less hashing power, the probability of success is reduced, because other miners control the generation of some blocks with their "honest" mining power. One way to look at it is that the more hashing power an attacker has, the longer the fork he can deliberately create, the more blocks in the recent past he can invalidate, or the more blocks in the future he can control. Security research groups have used statistical modeling to claim that various types of consensus attacks are possible with as little as 30% of the hashing power.</simpara>
<simpara>The massive increase of total hashing power has arguably made bitcoin impervious to attacks by a single miner. There is no possible way for a solo miner to control more than a small percentage of the total mining power. However, the centralization of control caused by mining pools has introduced the risk of for-profit attacks by a mining pool operator. The pool operator in a managed pool controls the construction of candidate blocks and also controls which transactions are included. This gives the pool operator the power to exclude transactions or introduce double-spend transactions. If such abuse of power is done in a limited and subtle way, a pool operator could conceivably profit from a consensus attack without being noticed.</simpara>
<simpara>Not all attackers will be motivated by profit, however. One potential attack scenario is where an attacker intends to disrupt the Bitcoin network without the possibility of profiting from such disruption. A malicious attack aimed at crippling bitcoin would require enormous investment and covert planning, but could conceivably be launched by a well-funded, most likely state-sponsored, attacker. Alternatively, a well-funded attacker could attack bitcoin&#8217;s consensus by simultaneously amassing mining hardware, compromising pool operators, and attacking other pools with denial-of-service. All of these scenarios are theoretically possible, but increasingly impractical as the Bitcoin network&#8217;s overall hashing power continues to grow exponentially.</simpara>
<simpara>Undoubtedly, a serious consensus attack would erode confidence in bitcoin in the short term, possibly causing a significant price decline. However, the Bitcoin network and software are constantly evolving, so consensus attacks would be met with immediate countermeasures by the bitcoin community, making bitcoin more robust.<indexterm>
  <primary></primary>
</indexterm><indexterm>
  <primary></primary>
</indexterm><indexterm>
  <primary></primary>
</indexterm></simpara>
</section>
<section id="consensus_changes">
<title>Changing the Consensus Rules</title>
<simpara><indexterm>
  <primary>mining and consensus</primary><secondary>consensus rules</secondary><tertiary>changing</tertiary>
</indexterm>
<indexterm>
  <primary>consensus rules</primary><secondary>changing</secondary>
</indexterm>
<indexterm>
  <primary>changing</primary>
</indexterm>The rules of consensus determine the validity of transactions and blocks. These rules are the basis for collaboration between all Bitcoin nodes and are responsible for the convergence of all local perspectives into a single consistent blockchain across the entire network.</simpara>
<simpara>While the consensus rules are invariable in the short term and must be consistent across all nodes, they are not invariable in the long term. In order to evolve and develop the Bitcoin system, the rules have to change from time to time to accommodate new features, improvements, or bug fixes. Unlike traditional software development, however, upgrades to a consensus system are much more difficult and require coordination between all the participants.</simpara>
<section id="hard_forks">
<title>Hard Forks</title>
<simpara><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary>
</indexterm><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary><tertiary>hard forks</tertiary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary><secondary>hard forks</secondary>
</indexterm>
<indexterm>
  <primary>hard forks</primary>
</indexterm>In <xref linkend="forks"/> we looked at how the Bitcoin network may briefly diverge, with two parts of the network following two different branches of the blockchain for a short time. We saw how this process occurs naturally, as part of the normal operation of the network and how the network reconverges on a common blockchain after one or more blocks are mined.</simpara>
<simpara>There is another scenario in which the network may diverge into following two chains: a change in the consensus rules. This type of fork is called a <emphasis>hard fork</emphasis>, because after the fork the network does not reconverge onto a single chain. Instead, the two chains evolve independently. Hard forks occur when part of the network is operating under a different set of consensus rules than the rest of the network. This may occur because of a bug or because of a deliberate change in the implementation of the consensus rules.</simpara>
<simpara>Hard forks can be used to change the rules of consensus, but they require coordination between all participants in the system. Any nodes that do not upgrade to the new consensus rules are unable to participate in the consensus mechanism and are forced onto a separate chain at the moment of the hard fork. Thus, a change introduced by a hard fork can be thought of as not "forward compatible," in that non-upgraded systems can&#8217;t process the new consensus rules after the hard fork event.</simpara>
<simpara>Let&#8217;s examine the mechanics of a hard fork with a specific example.</simpara>
<simpara><xref linkend="blockchainwithforks"/> shows a blockchain with two forks. At block height 4, a one-block fork occurs. This is the type of spontaneous fork we saw in <xref linkend="forks"/>. With the mining of block 5, the network reconverges on one chain and the fork is resolved.</simpara>
<figure id="blockchainwithforks"><title>A blockchain with forks</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1009.png"/>
  </imageobject>
  <textobject><phrase>A blockchain with forks</phrase></textobject>
</mediaobject>
</figure>
<simpara>Later, however, at block height 6, a hard fork occurs. Let&#8217;s assume that a new implementation of the client is released with a change in the consensus rules. Starting on block height 7, miners running this new implementation will accept a new type of digital signature, let&#8217;s call it a "Smores" signature, that is not ECDSA based. Immediately after, a node running the new implementation creates a transaction that contains a Smores signature and a miner with the updated software mines block 7b containing this transaction.</simpara>
<simpara>Any node or miner that has not upgraded the software to validate Smores signatures is now unable to process block 7b. From their perspective, both the transaction that contained a Smores signature and block 7b that contained that transaction are invalid, because they are evaluating them based upon the old consensus rules. These nodes will reject the transaction and the block and will not propagate them. Any miners that are using the old rules will not accept block 7b and will continue to mine a candidate block whose parent is block 6. In fact, miners using the old rules may not even receive block 7b if all the nodes they are connected to are also obeying the old rules and therefore not propagating the block. Eventually, they will be able to mine block 7a, which is valid under the old rules and does not contain any transactions with Smores signatures.</simpara>
<simpara>The two chains continue to diverge from this point. Miners on the "b" chain will continue to accept and mine transactions containing Smores signatures, while miners on the "a" chain will continue to ignore these transactions. Even if block 8b does not contain any Smores-signed transactions, the miners on the "a" chain cannot process it. To them it appears to be an orphan block, as its parent "7b" is not recognized as a valid block.</simpara>
</section>
<section id="_hard_forks_software_network_mining_and_chain">
<title>Hard Forks: Software, Network, Mining, and Chain</title>
<simpara><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary><tertiary>software forks</tertiary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary><secondary>software forks</secondary>
</indexterm>
<indexterm>
  <primary>software forks</primary>
</indexterm>For software developers, the term "fork" has another meaning, adding confusion to the term "hard fork." In open source software, a fork occurs when a group of developers choose to follow a different software roadmap and start a competing implementation of an open source project. We&#8217;ve already discussed two circumstances that will lead to a hard fork in bitcoin: a bug in the consensus rules and a deliberate modification of the consensus rules. In the case of a deliberate change to the consensus rules, a software fork precedes the hard fork. However, for this type of hard fork to occur, a new software implementation of the consensus rules must be developed, adopted, and launched.</simpara>
<simpara>Examples of software forks that have attempted to change consensus rules include Bitcoin XT, Bitcoin Classic, and most recently Bitcoin Unlimited. However, none of these software forks have resulted in a hard fork. While a software fork is a necessary precondition, it is not in itself sufficient for a hard fork to occur. For a hard fork to occur, the competing implementation must be adopted and the new rules activated, by miners, wallets, and intermediary nodes. Conversely, there are numerous alternative implementations of Bitcoin Core, and even software forks, that do not change the consensus rules and barring a bug, can coexist on the network and interoperate without causing a hard fork.</simpara>
<simpara>Consensus rules may differ in obvious and explicit ways, in the validation of transactions or blocks. The rules may also differ in more subtle ways, in the implementation of the consensus rules as they apply to bitcoin scripts or cryptographic primitives such as digital signatures. Finally, the consensus rules may differ in unanticipated ways because of implicit consensus constraints imposed by system limitations or implementation details. An example of the latter was seen in the unanticipated hard fork during the upgrade of Bitcoin Core 0.7 to 0.8, which was caused by a limitation in the Berkeley DB implementation used to store blocks.</simpara>
<simpara>Conceptually, we can think of a hard fork as developing in four stages: a software fork, a network fork, a mining fork, and a chain fork.</simpara>
<simpara>The process begins when an alternative implementation of the client, with modified consensus rules, is created by developers.</simpara>
<simpara>When this forked implementation is deployed in the network, a certain percentage of miners, wallet users, and intermediate nodes may adopt and run this implementation. A resulting fork will depend upon whether the new consensus rules apply to blocks, transactions, or some other aspect of the system. If the new consensus rules pertain to transactions, then a wallet creating a transaction under the new rules may precipitate a network fork, followed by a hard fork when the transaction is mined into a block. If the new rules pertain to blocks, then the hard fork process will begin when a block is mined under the new rules.</simpara>
<simpara>First, the network will fork. Nodes based on the original implementation of the consensus rules will reject any transactions and blocks that are created under the new rules. Furthermore, the nodes following the original consensus rules will temporarily ban and disconnect from any nodes that are sending them these invalid transactions and blocks. As a result, the network will partition into two: old nodes will only remain connected to old nodes and new nodes will only be connected to new nodes. A single transaction or block based on the new rules will ripple through the network and result in the partition into two networks.</simpara>
<simpara>Once a miner using the new rules mines a block, the mining power and chain will also fork. New miners will mine on top of the new block, while old miners will mine a separate chain based on the old rules. The partitioned network will make it so that the miners operating on separate consensus rules won&#8217;t likely receive each other&#8217;s blocks, as they are connected to two separate networks.</simpara>
</section>
<section id="_diverging_miners_and_difficulty">
<title>Diverging Miners and Difficulty</title>
<simpara><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary><tertiary>diverging miners and difficulty</tertiary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary><secondary>diverging miners and difficulty</secondary>
</indexterm>
<indexterm>
  <primary>diverging miners and difficulty</primary>
</indexterm>As miners diverge into mining two different chains, the hashing power is split between the chains. The mining power can be split in any proportion between the two chains. The new rules may only be followed by a minority, or by the vast majority of the mining power.</simpara>
<simpara>Let&#8217;s assume, for example, an 80%&#x2013;20% split, with the majority of the mining power using the new consensus rules. Let&#8217;s also assume that the fork occurs immediately after a retargeting period.</simpara>
<simpara>The two chains would each inherit the difficulty from the retargeting period. The new consensus rules would have 80% of the previously available mining power committed to them. From the perspective of this chain, the mining power has suddenly declined by 20% vis-a-vis the previous period. Blocks will be found on average every 12.5 minutes, representing the 20% decline in mining power available to extend this chain. This rate of block issuance will continue (barring any changes in hashing power) until 2016 blocks are mined, which will take approximately 25,200 minutes (at 12.5 minutes per block), or 17.5 days. After 17.5 days, a retarget will occur and the difficulty will adjust (reduced by 20%) to produce 10-minute blocks again, based on the reduced amount of hashing power in this chain.</simpara>
<simpara>The minority chain, mining under the old rules with only 20% of the hashing power, will face a much more difficult task. On this chain, blocks will now be mined every 50 minutes on average. The difficulty will not be adjusted for 2016 blocks, which will take 100,800 minutes, or approximately 10 weeks to mine. Assuming a fixed capacity per block, this will also result in a reduction of transaction capacity by a factor of 5, as there are fewer blocks per hour available to record transactions.</simpara>
</section>
<section id="_contentious_hard_forks">
<title>Contentious Hard Forks</title>
<simpara><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary><tertiary>contentious hard forks</tertiary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary><secondary>contentious hard forks</secondary>
</indexterm>
<indexterm>
  <primary>contentious hard forks</primary>
</indexterm><indexterm>
  <primary>hard forks</primary>
</indexterm>This is the dawn of consensus software development. Just as open source development changed both the methods and products of software and created new methodologies, new tools, and new communities in its wake, consensus software development also represents a new frontier in computer science. Out of the debates, experiments, and tribulations of the bitcoin development roadmap, we will see new development tools, practices, methodologies, and communities emerge.</simpara>
<simpara>Hard forks are seen as risky because they force a minority to either upgrade or remain on a minority chain. The risk of splitting the entire system into two competing systems is seen by many as an unacceptable risk. As a result, many developers are reluctant to use the hard fork mechanism to implement upgrades to the consensus rules, unless there is near-unanimous support from the entire network. Any hard fork proposals that do not have near-unanimous support are considered too "contentious" to attempt without risking a partition of the system.</simpara>
<simpara>The issue of hard forks is highly controversial in the bitcoin development community, especially as it relates to any proposed changes to the consensus rules controlling the maximum block size limit. Some developers are opposed to any form of hard fork, seeing it as too risky. Others see the mechanism of hard fork as an essential tool for upgrading the consensus rules in a way that avoids "technical debt" and provides a clean break with the past. Finally, some developers see hard forks as a mechanism that should be used rarely, with a lot of advance planning and only under near-unanimous consensus.</simpara>
<simpara>Already we have seen the emergence of new methodologies to address the risks of hard forks. In the next section, we will look at soft forks, and the BIP-34 and BIP-9 methods for signaling and activation of consensus modifications.</simpara>
</section>
<section id="_soft_forks">
<title>Soft Forks</title>
<simpara><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary><tertiary>soft forks</tertiary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary><secondary>soft forks</secondary>
</indexterm>
<indexterm>
  <primary>soft forks</primary>
</indexterm><indexterm>
  <primary>soft forks</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm>Not all consensus rule changes cause a hard fork. Only consensus changes that are forward-incompatible cause a fork. If the change is implemented in such a way that a non-upgraded client still sees the transaction or block as valid under the previous rules, the change can happen without a fork.</simpara>
<simpara>The term <emphasis>soft fork</emphasis> was introduced to distinguish this upgrade method from a "hard fork." In practice, a soft fork is not a fork at all. A soft fork is a forward-compatible change to the consensus rules that allows non-upgraded clients to continue to operate in consensus with the new rules.</simpara>
<simpara>One aspect of soft forks that is not immediately obvious is that soft fork upgrades can only be used to constrain the consensus rules, not to expand them. In order to be forward compatible, transactions and blocks created under the new rules must be valid under the old rules too, but not vice versa. The new rules can only limit what is valid; otherwise, they will trigger a hard fork when rejected under the old rules.</simpara>
<simpara>Soft forks can be implemented in a number of ways&#x2014;the term does not specify a particular method, rather a set of methods that all have one thing in common: they don&#8217;t require all nodes to upgrade or force non-upgraded nodes out of consensus.</simpara>
<section id="_soft_forks_redefining_nop_opcodes">
<title>Soft forks redefining NOP opcodes</title>
<simpara><indexterm>
  <primary>opcodes</primary><secondary>redefinition by soft forks</secondary>
</indexterm>
<indexterm>
  <primary>redefinition by soft forks</primary>
</indexterm><indexterm>
  <primary>soft forks</primary><secondary>redefinition of NOP codes</secondary>
</indexterm>
<indexterm>
  <primary>redefinition of NOP codes</primary>
</indexterm>A number of soft forks have been implemented in bitcoin, based on the re-interpretation of NOP opcodes. Bitcoin Script had ten opcodes reserved for future use, NOP1 through NOP10. Under the consensus rules, the presence of these opcodes in a script is interpreted as a null-potent operator, meaning they have no effect. Execution continues after the NOP opcode as if it wasn&#8217;t there.</simpara>
<simpara>A soft fork therefore can modify the semantics of a NOP code to give it new meaning. For example, BIP-65 (<literal>CHECKLOCKTIMEVERIFY</literal>) reinterpreted the NOP2 opcode. Clients implementing BIP-65 interpret NOP2 as <literal>OP_CHECKLOCKTIMEVERIFY</literal> and impose an absolute locktime consensus rule on UTXO that contain this opcode in their locking scripts. This change is a soft fork because a transaction that is valid under BIP-65 is also valid on any client that is not implementing (ignorant of) BIP-65. To the old clients, the script contains an NOP code, which is ignored.</simpara>
</section>
<section id="_other_ways_to_soft_fork_upgrade">
<title>Other ways to soft fork upgrade</title>
<simpara>The reinterpretation of NOP opcodes was both planned for and an obvious mechanism for consensus upgrades. Recently, however, another soft fork mechanism was introduced that does not rely on NOP opcodes for a very specific type of consensus change. This is examined in more detail in <xref linkend="segwit"/>. Segwit is an architectural change to the structure of a transaction, which moves the unlocking script (witness) from inside the transaction to an external data structure (segregating it). Segwit was initially envisioned as a hard fork upgrade, as it modified a fundamental structure (transaction). In November 2015, a developer working on Bitcoin Core proposed a mechanism by which segwit could be introduced as a soft fork. The mechanism used for this is a modification of the locking script of UTXO created under segwit rules, such that non-upgraded clients see the locking script as redeemable with any unlocking script whatsoever. As a result, segwit can be introduced without requiring every node to upgrade or split from the chain: a soft fork.</simpara>
<simpara>It is likely that there are other, yet to be discovered, mechanisms by which upgrades can be made in a forward-compatible way as a soft fork.</simpara>
</section>
</section>
<section id="_criticisms_of_soft_forks">
<title>Criticisms of Soft Forks</title>
<simpara><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary><tertiary>soft fork drawbacks</tertiary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary><secondary>soft fork drawbacks</secondary>
</indexterm>
<indexterm>
  <primary>soft fork drawbacks</primary>
</indexterm><indexterm>
  <primary>soft forks</primary><secondary>drawbacks of</secondary>
</indexterm>
<indexterm>
  <primary>drawbacks of</primary>
</indexterm>Soft forks based on the NOP opcodes are relatively uncontroversial. The NOP opcodes were placed in Bitcoin Script with the explicit goal of allowing non-disruptive upgrades.</simpara>
<simpara>However, many developers are concerned that other methods of soft fork upgrades make unacceptable tradeoffs. Common criticisms of soft fork changes include:</simpara>
<variablelist>
<varlistentry>
<term>
Technical debt
</term>
<listitem>
<simpara>
Because soft forks are more technically complex than a hard fork upgrade, they introduce <emphasis>technical debt</emphasis>, a term that refers to increasing the future cost of code maintenance because of design tradeoffs made in the past. Code complexity in turn increases the likelihood of bugs and security vulnerabilities.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Validation relaxation
</term>
<listitem>
<simpara>
Non-upgraded clients see transactions as valid, without evaluating the modified consensus rules. In effect, the non-upgraded clients are not validating using the full range of consensus rules, as they are blind to the new rules. This applies to NOP-based upgrades, as well as other soft fork upgrades.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Irreversible upgrades
</term>
<listitem>
<simpara>
Because soft forks create transactions with additional consensus constraints, they become irreversible upgrades in practice. If a soft fork upgrade were to be reversed after being activated, any transactions created under the new rules could result in a loss of funds under the old rules. For example, if a CLTV transaction is evaluated under the old rules, there is no timelock constraint and it can be spent at any time. Therefore, critics contend that a failed soft fork that had to be reversed because of a bug would almost certainly lead to loss of funds.<indexterm>
  <primary></primary>
</indexterm>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="softforksignaling">
<title>Soft Fork Signaling with Block Version</title>
<simpara><indexterm>
  <primary>forks</primary><secondary>changing consensus rules</secondary><tertiary>soft fork activation</tertiary>
</indexterm>
<indexterm>
  <primary>changing consensus rules</primary><secondary>soft fork activation</secondary>
</indexterm>
<indexterm>
  <primary>soft fork activation</primary>
</indexterm><indexterm>
  <primary>soft forks</primary><secondary>activation</secondary>
</indexterm>
<indexterm>
  <primary>activation</primary>
</indexterm>Since soft forks allow non-upgraded clients to continue to operate within consensus, the mechanism for "activating" a soft fork is through miners signaling readiness: a majority of miners must agree that they are ready and willing to enforce the new consensus rules. To coordinate their actions, there is a signaling mechanism that allows them to show their support for a consensus rule change. This mechanism was introduced with the activation of BIP-34 in March 2013 and replaced by the activation of BIP-9 in July 2016.</simpara>
<section id="_bip_34_signaling_and_activation">
<title>BIP-34 Signaling and Activation</title>
<simpara><indexterm>
  <primary>bitcoin improvement proposals</primary><secondary>Block v2, Height in Coinbase (BIP-34)</secondary>
</indexterm>
<indexterm>
  <primary>Block v2, Height in Coinbase (BIP-34)</primary>
</indexterm>The first implementation, in BIP-34, used the block version field to allow miners to signal readiness for a specific consensus rule change. Prior to BIP-34, the block version was set to "1" by <emphasis>convention</emphasis> not enforced by <emphasis>consensus</emphasis>.</simpara>
<simpara>BIP-34 defined a consensus rule change that required the coinbase data field of a coinbase transaction input to contain the block height. Prior to BIP-34, the coinbase data could contain any arbitrary data the miners chose to include. After activation of BIP-34, valid blocks had to contain a specific block-height at the beginning of the coinbase data and be identified with a version number greater than or equal to "2."</simpara>
<simpara>To signal the change and activation of BIP-34, miners set the block version to "2," instead of "1." This did not immediately make version "1" blocks invalid. Once activated, version "1" blocks would become invalid and all version "2" blocks would be required to contain the block height in the coinbase to be valid.</simpara>
<simpara>BIP-34 defined a two-step activation mechanism, based on a rolling window of 1000 blocks. A miner would signal his or her individual readiness for BIP-34 by constructing blocks with "2" as the version number. Strictly speaking, these blocks did not yet have to comply with the new consensus rule of including the block-height in the coinbase transaction because the consensus rule had not yet been activated. The consensus rules activated in two steps:</simpara>
<itemizedlist>
<listitem>
<simpara>
If 75% (750 of the most recent 1000 blocks) are marked with version "2," then version "2" blocks must contain block height in the coinbase transaction or they are rejected as invalid. Version "1" blocks are still accepted by the network and do not need to contain block-height. The old and new consensus rules coexist during this period.
</simpara>
</listitem>
<listitem>
<simpara>
When 95% (950 of the most recent 1000 blocks) are version "2," version "1" blocks are no longer considered valid. Version "2" blocks are valid only if they contain the block-height in the coinbase (as per the previous threshold). Thereafter, all blocks must comply with the new consensus rules, and all valid blocks must contain block-height in the coinbase transaction.
</simpara>
</listitem>
</itemizedlist>
<simpara>After successful signaling and activation under the BIP-34 rules, this mechanism was used twice more to activate soft forks:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki">BIP-66</ulink> Strict DER Encoding of Signatures was activated by BIP-34 style signaling with a block version "3" and invalidating version "2" blocks.
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP-65</ulink> <literal>CHECKLOCKTIMEVERIFY</literal> was activated by BIP-34 style signaling with a block version "4" and invalidating version "3" blocks.
</simpara>
</listitem>
</itemizedlist>
<simpara>After the activation of BIP-65, the signaling and activation mechanism of BIP-34 was retired and replaced with the BIP-9 signaling mechanism described next.</simpara>
<simpara>The standard is defined in <ulink url="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP-34 (Block v2, Height in Coinbase)</ulink>.</simpara>
</section>
<section id="_bip_9_signaling_and_activation">
<title>BIP-9 Signaling and Activation</title>
<simpara><indexterm>
  <primary>bitcoin improvement proposals</primary><secondary>Version bits with timeout and delay (BIP-9)</secondary>
</indexterm>
<indexterm>
  <primary>Version bits with timeout and delay (BIP-9)</primary>
</indexterm><indexterm>
  <primary>bitcoin improvement proposals</primary><secondary>CHECKLOCKTIMEVERIFY (BIP-65)</secondary>
</indexterm>
<indexterm>
  <primary>CHECKLOCKTIMEVERIFY (BIP-65)</primary>
</indexterm><indexterm>
  <primary>bitcoin improvement proposals</primary><secondary>Strict DER signatures (BIP-66)</secondary>
</indexterm>
<indexterm>
  <primary>Strict DER signatures (BIP-66)</primary>
</indexterm>The mechanism used by BIP-34, BIP-66, and BIP-65 was successful in activating three soft forks. However, it was replaced because it had several limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>
By using the integer value of the block version, only one soft fork could be activated at a time, so it required coordination between soft fork proposals and agreement on their prioritization and sequencing.
</simpara>
</listitem>
<listitem>
<simpara>
Furthermore, because the block version was incremented, the mechanism didn&#8217;t offer a straightforward way to reject a change and then propose a different one. If old clients were still running, they could mistake signaling for a new change as signaling for the previously rejected change.
</simpara>
</listitem>
<listitem>
<simpara>
Each new change irrevocably reduced the available block versions for future changes.
</simpara>
</listitem>
</itemizedlist>
<simpara>BIP-9 was proposed to overcome these challenges and improve the rate and ease of implementing future changes.</simpara>
<simpara>BIP-9 interprets the block version as a bit field instead of an integer. Because the block version was originally used as an integer, versions 1 through 4, only 29 bits remain available to be used as a bit field. This leaves 29 bits that can be used to independently and simultaneously signal readiness on 29 different proposals.</simpara>
<simpara>BIP-9 also sets a maximum time for signaling and activation. This way miners don&#8217;t need to signal forever. If a proposal is not activated within the <literal>TIMEOUT</literal> period (defined in the proposal), the proposal is considered rejected. The proposal may be resubmitted for signaling with a different bit, renewing the activation period.</simpara>
<simpara>Furthermore, after the <literal>TIMEOUT</literal> has passed and a feature has been activated or rejected, the signaling bit can be reused for another feature without confusion. Therefore, up to 29 changes can be signaled in parallel and after <literal>TIMEOUT</literal> the bits can be "recycled" to propose new changes.</simpara>
<informalexample>
<simpara>While signaling bits can be reused or recycled, as long as the voting period does not overlap, the authors of BIP-9 recommend that bits are reused only when necessary; unexpected behavior could occur due to bugs in older software. In short, we should not expect to see reuse until all 29 bits have been used once.</simpara>
</informalexample>
<simpara>Proposed changes are identified by a data structure that contains the following fields:</simpara>
<variablelist>
<varlistentry>
<term>
name
</term>
<listitem>
<simpara>
A short description used to distinguish between proposals. Most often the BIP describing the proposal, as "bipN," where N is the BIP number.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bit
</term>
<listitem>
<simpara>
0 through 28, the bit in the block version that miners use to signal approval for this proposal.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
starttime
</term>
<listitem>
<simpara>
The time (based on Median Time Past, or MTP) that signaling starts after which the bit&#8217;s value is interpreted as signaling readiness for the proposal.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
endtime
</term>
<listitem>
<simpara>
The time (based on MTP) after which the change is considered rejected if it has not reached the activation threshold.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Unlike BIP-34, BIP-9 counts activation signaling in whole intervals based on the difficulty retarget period of 2016 blocks. For every retarget period, if the sum of blocks signaling for a proposal exceeds 95% (1916 of 2016), the proposal will be activated one retarget period later.</simpara>
<simpara>BIP-9 offers a proposal state diagram to illustrate the various stages and transitions for a proposal, as shown in <xref linkend="bip9states"/>.</simpara>
<simpara>Proposals start in the <literal>DEFINED</literal> state, once their parameters are known (defined) in the bitcoin software. For blocks with MTP after the start time, the proposal state transitions to <literal>STARTED</literal>. If the voting threshold is exceeded within a retarget period and the timeout has not been exceeded, the proposal state transitions to <literal>LOCKED_IN</literal>. One retarget period later, the proposal becomes <literal>ACTIVE</literal>. Proposals remain in the <literal>ACTIVE</literal> state perpetually once they reach that state. If the timeout elapses before the voting threshold has been reached, the proposal state changes to <literal>FAILED</literal>, indicating a rejected proposal. <literal>FAILED</literal> proposals remain in that state perpetually.</simpara>
<figure id="bip9states"><title>BIP-9 state transition diagram</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_1010.png"/>
  </imageobject>
  <textobject><phrase>BIP-9 Proposal State Transition Diagram</phrase></textobject>
</mediaobject>
</figure>
<simpara>BIP-9 was first implemented for the activation of <literal>CHECKSEQUENCEVERIFY</literal> and associated BIPs (68, 112, 113). The proposal named "csv" was activated successfully in July of 2016.<indexterm>
  <primary></primary>
</indexterm></simpara>
<simpara>The standard is defined in <ulink url="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki">BIP-9 (Version bits with timeout and delay)</ulink>.</simpara>
</section>
</section>
<section id="_consensus_software_development">
<title>Consensus Software Development</title>
<simpara><indexterm>
  <primary>mining and consensus</primary><secondary>consensus software development</secondary>
</indexterm>
<indexterm>
  <primary>consensus software development</primary>
</indexterm><indexterm>
  <primary>development environment</primary><secondary>consensus software development</secondary>
</indexterm>
<indexterm>
  <primary>consensus software development</primary>
</indexterm>Consensus software continues to evolve and there is much discussion on the various mechanisms for changing the consensus rules. By its very nature, bitcoin sets a very high bar on coordination and consensus for changes. As a decentralized system, it has no "authority" that can impose its will on the participants of the network. Power is diffused between multiple constituencies such as miners, core developers, wallet developers, exchanges, merchants, and end users. Decisions cannot be made unilaterally by any of these constituencies. For example, while miners can theoretically change the rules by simple majority (51%), they are constrained by the consent of the other constituencies. If they act unilaterally, the rest of the participants may simply refuse to follow them, keeping the economic activity on a minority chain. Without economic activity (transactions, merchants, wallets, exchanges), the miners will be mining a worthless coin with empty blocks. This diffusion of power means that all the participants must coordinate, or no changes can be made. Status quo is the stable state of this system with only a few changes possible if there is strong consensus by a very large majority. The 95% threshold for soft forks is reflective of this reality.</simpara>
<simpara><indexterm>
  <primary>hard forks</primary>
</indexterm>It is important to recognize that there is no perfect solution for consensus development. Both hard forks and soft forks involve tradeoffs. For some types of changes, soft forks may be a better choice; for others, hard forks may be a better choice. There is no perfect choice; both carry risks. The one constant characteristic of consensus software development is that change is difficult and consensus forces compromise.</simpara>
<simpara>Some see this as a weakness of consensus systems. In time, you may come to see it as I do, as the system&#8217;s greatest strength.</simpara>
</section>
</section>
</article>
