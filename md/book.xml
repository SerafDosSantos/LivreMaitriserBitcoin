<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>Maîtriser Bitcoin</title>
</articleinfo>
<preface id="_préface">
<title>Préface</title>
<section id="_écrire_le_livre_bitcoin">
<title>Écrire le livre Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;bitcoin&quot;</primary><secondary>&quot;bénéfices de&quot;</secondary><tertiary>id=&quot;BCbasicbenefits0&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;bénéfices de&quot;</primary><secondary>id=&quot;BCbasicbenefits0&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCbasicbenefits0&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;systèmes décentralisés&quot;</primary><secondary>&quot;bitcoin comme&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;bitcoin comme&quot;</primary>
</indexterm>Je suis tombé sur bitcoin pour la première fois à la mi-2011. Ma réaction immédiate a été plus ou moins &quot;Pfft ! Nerd money !&quot; et je l&#39;ai ignoré pendant encore six mois, n&#39;en saisissant pas l&#39;importance. C&#39;est une réaction que j&#39;ai vue se répéter chez bon nombre des personnes les plus intelligentes que je connaisse, ce qui me réconforte un peu. La deuxième fois que je suis tombé sur bitcoin, lors d&#39;une discussion sur une liste de diffusion, j&#39;ai décidé de lire le livre blanc écrit par Satoshi Nakamoto pour étudier la source faisant autorité et voir de quoi il s&#39;agissait. <indexterm>
  <primary>&quot;monnaies numériques&quot;</primary><secondary>&quot;bitcoin vs. autres&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;bitcoin vs. autres&quot;</primary>
</indexterm>Je me souviens encore du moment où j&#39;ai fini de lire ces neuf pages, quand j&#39;ai réalisé que le bitcoin n&#39;était pas simplement une monnaie numérique, mais un réseau de confiance qui pouvait aussi fournir la base de bien plus que de simples devises. La prise de conscience que &quot;ce n&#39;est pas de l&#39;argent, c&#39;est un réseau de confiance décentralisé&quot;, m&#39;a lancé dans un voyage de quatre mois pour dévorer toutes les informations sur le bitcoin que j&#39;ai pu trouver. Je suis devenu obsédé et captivé, passant 12 heures ou plus par jour collé à un écran, lisant, écrivant, codant et apprenant autant que possible. Je suis sorti de cet état de fugue, plus de 20 livres en moins à cause du manque de repas réguliers, déterminé à me consacrer au travail sur le bitcoin.</simpara>
<simpara>Deux ans plus tard, après avoir créé un certain nombre de petites start-ups pour explorer divers services et produits liés au bitcoin, j&#39;ai décidé qu&#39;il était temps d&#39;écrire mon premier livre. Bitcoin était le sujet qui m&#39;avait poussé dans une frénésie de créativité et consommé mes pensées; c&#39;était la technologie la plus excitante que j&#39;avais rencontrée depuis Internet. Il était maintenant temps de partager ma passion pour cette technologie incroyable avec un public plus large.</simpara>
</section>
<section id="_public_visé">
<title>Public visé</title>
<simpara><indexterm>
  <primary>&quot;audience visée&quot;</primary>
</indexterm>Ce livre est principalement destiné aux codeurs. Si vous pouvez utiliser un langage de programmation, ce livre vous apprendra comment fonctionnent les monnaies cryptographiques, comment les utiliser et comment développer des logiciels qui fonctionnent avec elles. Les premiers chapitres conviennent également comme une introduction approfondie au bitcoin pour les non-codeurs, tel ceux qui veulent comprendre le fonctionnement interne du bitcoin et des crypto-monnaies.</simpara>
</section>
<section id="_les_conventions_utilisées_dans_ce_livre">
<title>Les conventions utilisées dans ce livre</title>
<simpara><indexterm>
  <primary>&quot;conventions typographiques&quot;</primary>
</indexterm>Les conventions typographiques suivantes sont utilisées dans ce livre :</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis>Italique</emphasis> 
</term>
<listitem>
<simpara>
Indique de nouveaux termes, URL, adresses e-mail, noms de fichiers et extensions de fichiers.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>Largeur constante</literal> 
</term>
<listitem>
<simpara>
Utilisé pour les listes de programmes, ainsi que dans les paragraphes pour faire référence à des éléments de programme tels que des noms de variables ou de fonctions, des bases de données, des types de données, des variables d&#39;environnement, des instructions et des mots-clés.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>Largeur constante en gras</literal></emphasis> 
</term>
<listitem>
<simpara>
Affiche les commandes ou tout autre texte qui doit être saisi littéralement par l&#39;utilisateur.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis><literal>Largeur constante en italique</literal></emphasis> : Affiche le texte qui doit être remplacé par des valeurs fournies par l&#39;utilisateur ou par des valeurs déterminées par le contexte.</simpara>
<tip>
<simpara>Cette icône signifie un conseil ou une suggestion.</simpara>
</tip>
<note>
<simpara>Cette icône signifie une note générale.</simpara>
</note>
<warning>
<simpara>Cette icône indique un avertissement ou une mise en garde.</simpara>
</warning>
</section>
<section id="_exemples_de_codes">
<title>Exemples de codes</title>
<simpara><indexterm>
  <primary>&quot;exemples de code</primary><secondary>obtention et utilisation&quot;</secondary><tertiary>id=&quot;codeuse00&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>obtention et utilisation&quot;</primary><secondary>id=&quot;codeuse00&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;codeuse00&quot;</primary>
</indexterm>Les exemples sont illustrés en Python, C++, et en utilisant la ligne de commande d&#39;un système d&#39;exploitation de type Unix tel que Linux ou macOS. Tous les extraits de code sont disponibles dans le référentiel GitHub (<ulink url="https://github.com/bitcoinbook/bitcoinbook">https://github.com/bitcoinbook/bitcoinbook</ulink>) dans le sous-répertoire <emphasis>code</emphasis> du référentiel principal. Fourchez le code du livre, essayez les exemples de code ou soumettez des corrections via GitHub.</simpara>
<simpara>Tous les extraits de code peuvent être répliqués sur la plupart des systèmes d&#39;exploitation avec une installation minimale de compilateurs et d&#39;interpréteurs pour les langages correspondants. Si nécessaire, nous fournissons des instructions d&#39;installation de base et des exemples étape par étape de la sortie de ces instructions.</simpara>
<simpara>Certains des extraits de code et des sorties de code ont été reformatés pour l&#39;impression. Dans tous ces cas, les lignes ont été séparées par un caractère barre oblique inverse (\), suivi d&#39;un caractère de saut de ligne. Lors de la transcription des exemples, supprimez ces deux caractères et rejoignez les lignes à nouveau et vous devriez voir des résultats identiques comme indiqué dans l&#39;exemple.</simpara>
<simpara>Tous les extraits de code utilisent des valeurs réelles et des calculs dans la mesure du possible, afin que vous puissiez construire d&#39;exemple en exemple et voir les mêmes résultats dans n&#39;importe quel code que vous écrivez pour calculer les mêmes valeurs. Par exemple, les clés privées et les clés et adresses publiques correspondantes sont toutes réelles. Les exemples de transactions, de blocs et de références de chaîne de blocs ont tous été introduits dans la chaîne de blocs bitcoin réelle et font partie du grand livre public, vous pouvez donc les consulter sur n&#39;importe quel système bitcoin.</simpara>
</section>
<section id="_adresses_et_transactions_bitcoin_dans_ce_livre">
<title>Adresses et transactions Bitcoin dans ce livre</title>
<simpara><indexterm>
  <primary>&quot;pour commencer&quot;</primary><secondary>&quot;avertissements et mises en garde&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;éviter d&#39;envoyer de l&#39;argent aux adresses figurant dans le livre&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;éviter d&#39;envoyer de l&#39;argent aux adresses figurant dans le livre&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;avertissements et mises en garde&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avertissements et mises en garde&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;applications chaîne de blocs&quot;</primary><secondary>&quot;avertissements et mises en garde&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;codes QR&quot;</primary><secondary>&quot;avertissements et mises en garde&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary>
</indexterm>Les adresses bitcoin, les transactions, les clés, les codes QR et les données de chaîne de blocs utilisées dans ce livre sont, pour la plupart, réelles. Cela signifie que vous pouvez parcourir la chaîne de blocs, regarder les transactions proposées en exemple, les récupérer avec vos propres scripts ou programmes, etc.</simpara>
<simpara>Cependant, notez que les clés privées utilisées pour construire les adresses sont soit imprimées dans ce livre, soit ont été &quot;radiées&quot;. Cela signifie que si vous envoyez de l&#39;argent à l&#39;une de ces adresses, l&#39;argent sera perdu pour toujours ou, dans certains cas, tous ceux qui peuvent lire ce livre peuvent le prendre en utilisant les clés privées imprimées dans celui-ci.</simpara>
<warning>
<simpara>N&#39;ENVOYEZ PAS D&#39;ARGENT AUX ADRESSES DANS CE LIVRE. Votre argent sera pris par un autre lecteur, ou perdu à jamais.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;codeuse00&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;codeuse00&quot;</primary>
</indexterm></simpara>
</warning>
</section>
<section id="_publication_par_o_39_reilly_media">
<title>Publication par O&#39;Reilly Media</title>
<simpara>Ce livre est dérivé sous licence du livre &quot;Mastering Bitcoin 2nd Edition&quot;, par O&#39;Reilly Media.</simpara>
</section>
<section id="_droit_d_39_auteur_et_licence_de_livre">
<title>Droit d&#39;auteur et licence de livre</title>
<simpara>Copyright (c) 2014 Andreas M. Antonopoulos LLC</simpara>
<simpara>Ce travail est sous licence Creative Commons Attribution-ShareAlike 4.0 International License. Pour voir une copie de cette licence, visitez</simpara>
<simpara><ulink url="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</ulink>.</simpara>
<simpara>Pour fournir une attribution, veuillez créer un lien vers le référentiel du livre :</simpara>
<simpara><ulink url="https://github.com/bitcoinbook/bitcoinbook">https://github.com/bitcoinbook/bitcoinbook</ulink></simpara>
<simpara>et inclure cette licence ou une licence ouverte équivalente, pour satisfaire aux exigences ShareAlike.</simpara>
<simpara>Cette licence conforme à la &quot;Culture libre&quot; a été approuvée par mon éditeur O&#39;Reilly Media (<ulink url="http://oreilly.com">http://oreilly.com</ulink>), qui comprend la valeur du mouvement de source ouverte. O&#39;Reilly Media n&#39;est pas seulement le meilleur éditeur de livres techniques au monde, mais aussi un fervent partisan d&#39;une culture ouverte et du partage des connaissances.</simpara>
<simpara>Merci O&#39;Reilly !</simpara>
</section>
<section id="_contacter_l_39_auteur" role="pagebreak-before">
<title>Contacter l&#39;auteur</title>
<simpara>Vous pouvez me contacter, Andreas M. Antonopoulos, sur mon site personnel :
<ulink url="https://aantonop.com/">https://aantonop.com/</ulink></simpara>
<simpara>Des informations sur <emphasis>Maîtriser Bitcoin (Mastering Bitcoin en anglais)</emphasis> ainsi que l&#39;Édition Ouverte et les traductions sont disponibles sur :
<ulink url="https://bitcoinbook.info/">https://bitcoinbook.info/</ulink></simpara>
<simpara>Suivez-moi sur Twitter:
<ulink url="https://twitter.com/aantonop">https://twitter.com/aantonop</ulink></simpara>
<simpara>Retrouvez plus de 500 vidéos pédagogiques sur ma chaîne YouTube :
<ulink url="https://youtube.com/aantonop">https://youtube.com/aantonop</ulink></simpara>
<simpara>Un grand merci à tous mes mécènes qui soutiennent mon travail par des dons mensuels. Vous pouvez suivre ma page Patreon ici :
<ulink url="https://patreon.com/aantonop">https://patreon.com/aantonop</ulink></simpara>
</section>
<section id="_remerciements">
<title>Remerciements</title>
<simpara><indexterm>
  <primary>&quot;reconnaissances&quot;</primary><secondary>id=&quot;reconnaître0&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;reconnaître0&quot;</primary>
</indexterm>Ce livre représente les efforts et les contributions de nombreuses personnes. Je suis reconnaissant pour toute l&#39;aide que j&#39;ai reçue d&#39;amis, de collègues et même de parfaits inconnus, qui m&#39;ont rejoint dans cet effort pour écrire le livre technique définitif sur les crypto-monnaies et le bitcoin.</simpara>
<simpara>Il est impossible de faire une distinction entre la technologie bitcoin et la communauté bitcoin, et ce livre est autant un produit de cette communauté qu&#39;un livre sur la technologie. Mon travail sur ce livre a été encouragé, applaudi, soutenu et récompensé par toute la communauté bitcoin du tout début jusqu&#39;à la toute fin. Plus que tout, ce livre m&#39;a permis de faire partie d&#39;une merveilleuse communauté pendant deux ans et je ne vous remercierai jamais assez de m&#39;avoir accepté dans cette communauté. Il y a beaucoup trop de personnes à mentionner par leur nom - des personnes que j&#39;ai rencontrées lors de conférences, d&#39;événements, de séminaires, de rencontres, de pizzas et de petits rassemblements privés, ainsi que beaucoup qui ont communiqué avec moi par Twitter, sur reddit, sur bitcointalk. org, et sur GitHub qui ont eu un impact sur ce livre. Chaque idée, analogie, question, réponse et explication que vous trouverez dans ce livre a été à un moment donné inspirée, testée ou améliorée grâce à mes interactions avec la communauté. Merci à tous pour votre soutien; sans vous ce livre n&#39;aurait pas vu le jour. Je suis éternellement reconnaissant.</simpara>
<simpara>Le voyage pour devenir auteur commence bien avant le premier livre, bien sûr. Ma première langue (et ma scolarité) était le grec, j&#39;ai donc dû suivre un cours de rattrapage en anglais écrit lors de ma première année d&#39;université. Je dois remercier Diana Kordas, mon professeur d&#39;écriture d&#39;anglais, qui m&#39;a aidé à développer ma confiance et mes compétences cette année-là. Plus tard, en tant que professionnel, j&#39;ai développé mes compétences en rédaction technique sur le thème des centres de données, en écrivant pour le magazine <emphasis>Network World</emphasis>. Je dois remercier John Dix et John Gallant, qui m&#39;ont donné mon premier travail d&#39;écriture en tant que chroniqueur à <emphasis>Network World</emphasis> et à mon éditeur Michael Cooney et mon collègue Johna Till Johnson qui ont édité mes chroniques et les ont rendues aptes à la publication. Écrire 500 mots par semaine pendant quatre ans m&#39;a donné suffisamment d&#39;expérience pour éventuellement envisager de devenir auteur.</simpara>
<simpara>Merci également à ceux qui m&#39;ont soutenu lorsque j&#39;ai soumis ma proposition de livre à O&#39;Reilly, en fournissant des références et en examinant la proposition. Plus précisément, merci à John Gallant, Gregory Ness, Richard Stiennon, Joel Snyder, Adam B. Levine, Sandra Gittlen, John Dix, Johna Till Johnson, Roger Ver et Jon Matonis. Remerciements particuliers à Richard Kagan et Tymon Mattoszko, qui ont révisé les premières versions de la proposition et à Matthew Taylor, qui a révisé la proposition.</simpara>
<simpara>Merci à Cricket Liu, auteur du titre O&#39;Reilly <emphasis>DNS et BIND</emphasis>, qui m&#39;a présenté O&#39;Reilly. Merci également à Michael Loukides et Allyson MacDonald de O&#39;Reilly, qui ont travaillé pendant des mois pour aider à la réalisation de ce livre. Allyson a été particulièrement patiente lorsque les délais ont été manqués et les livrables retardés alors que la vie intervenait dans notre échéancier. Pour la deuxième édition, je remercie Timothy McGovern d&#39;avoir guidé le processus, Kim Cofer d&#39;avoir patiemment édité et Rebecca Panzer d&#39;avoir illustré de nombreux nouveaux diagrammes.</simpara>
<simpara>Les premières ébauches des premiers chapitres ont été les plus difficiles, car le bitcoin est un sujet difficile à démêler. Chaque fois que je tirais sur un fil de la technologie bitcoin, je devais tirer sur le tout. Je me suis retrouvé coincé à plusieurs reprises et un peu découragé alors que je luttais pour rendre le sujet facile à comprendre et créer un récit autour d&#39;un sujet technique aussi dense. Finalement, j&#39;ai décidé de raconter l&#39;histoire du bitcoin à travers les histoires des personnes utilisant le bitcoin et tout le livre est devenu beaucoup plus facile à écrire. Je dois remercier mon ami et mentor, Richard Kagan, qui m&#39;a aidé à démêler l&#39;histoire et à surmonter les moments de blocage de l&#39;écrivain. Je remercie Pamela Morgan, qui a révisé les premières ébauches de chaque chapitre de la première et de la deuxième édition du livre, et a posé les questions difficiles pour les améliorer. Merci également aux développeurs du groupe San Francisco Bitcoin Developers Meetup ainsi qu&#39;à Taariq Lewis et Denise Terry pour avoir aidé à tester le premier matériel. Merci également à Andrew Naugler pour la conception infographique.</simpara>
<simpara>Pendant le développement du livre, j&#39;ai rendu les premières ébauches disponibles sur GitHub et j&#39;ai invité les commentaires du public. Plus d&#39;une centaine de commentaires, suggestions, corrections et contributions ont été soumis en réponse. Ces contributions sont explicitement reconnues, avec mes remerciements, dans &lt;&lt;github_contrib&gt; &gt;. Surtout, mes sincères remerciements à mes éditeurs bénévoles de GitHub, Ming T. Nguyen (1ère édition) et Will Binns (2e édition), qui ont travaillé sans relâche pour organiser, gérer et résoudre les demandes d&#39;extraction, publier des rapports et effectuer des corrections de bogues sur GitHub.</simpara>
<simpara>Une fois le livre rédigé, il est passé par plusieurs séries d&#39;examens techniques. Merci à Cricket Liu et Lorne Lantz pour leur examen approfondi, leurs commentaires et leur soutien.</simpara>
<simpara>Plusieurs développeurs de bitcoins ont fourni des échantillons de code, des critiques, des commentaires et des encouragements. Merci à Amir Taaki et Eric Voskuil pour les extraits de code par exemple et de nombreux excellents commentaires ; Chris Kleeschulte pour sa contribution à l&#39;annexe Bitcore ; Vitalik Buterin et Richard Kiss pour leur aide avec les mathématiques des courbes elliptiques et leurs contributions au code ; Gavin Andresen pour les corrections, les commentaires et les encouragements ; Michalis Kargakis pour les commentaires, les contributions et la rédaction de btcd ; et Robin Inge pour les soumissions d&#39;errata améliorant la deuxième impression. Dans la deuxième édition, j&#39;ai de nouveau reçu beaucoup d&#39;aide de la part de nombreux développeurs de Bitcoin Core, dont Eric Lombrozo qui a démystifié le Témoin Séparé, Luke Dashjr qui a aidé à améliorer le chapitre sur les transactions, Johnson Lau qui a revu le Témoin Séparé et d&#39;autres chapitres, et bien d&#39;autres. Je dois remercier Joseph Poon, Tadge Dryja et Olaoluwa Osuntokun qui ont expliqué le Lightning Network, revu mes écrits et répondu aux questions lorsque je suis resté bloqué.</simpara>
<simpara>Je dois mon amour des mots et des livres à ma mère, Theresa, qui m&#39;a élevé dans une maison avec des livres tapissant tous les murs. Ma mère m&#39;a également acheté mon premier ordinateur en 1982, bien qu&#39;elle se décrive comme une technophobe. Mon père, Menelaos, un ingénieur civil qui vient de publier son premier livre à 80 ans, est celui qui m&#39;a enseigné la pensée logique et analytique et l&#39;amour de la science et de l&#39;ingénierie.</simpara>
<simpara>Merci à tous de m&#39;avoir soutenu tout au long de ce parcours.</simpara>
</section>
</preface>
<preface id="_glossaire_rapide">
<title>Glossaire rapide</title>
<simpara>Ce glossaire rapide contient de nombreux termes utilisés en relation avec le bitcoin. Ces termes sont utilisés tout au long du livre, alors mettez-les en signet pour une référence rapide.</simpara>
<variablelist>
<varlistentry>
<term>
adresse
</term>
<listitem>
<simpara>
    Une adresse Bitcoin ressemble à <literal>1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV</literal>. Il se compose d&#39;une suite de lettres et de chiffres. Il s&#39;agit en réalité d&#39;une version codée en base58check d&#39;un résultat de hachage à clé publique de 160 bits. Tout comme vous demandez aux autres d&#39;envoyer un courriel à l&#8217;adresse de celle-ci, vous demanderez aux autres de vous envoyer des bitcoins à l&#39;une de vos adresses Bitcoin.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bip
</term>
<listitem>
<simpara>
    Bitcoin Improvement Proposals (ou Propositions d&#8217;améliorations du Bitcoin). Un ensemble de propositions que les membres de la communauté Bitcoin ont soumises pour améliorer Bitcoin. Par exemple, BIP-21 est une proposition visant à améliorer le schéma d&#39;identificateur de ressource uniforme (URI) bitcoin.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bitcoin
</term>
<listitem>
<simpara>
    Le nom de l&#39;unité monétaire (unité de cryptomonnaie), du réseau et du logiciel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bloc
</term>
<listitem>
<simpara>
    Regroupement de transactions, marqué d&#39;un horodatage et d&#39;une empreinte digitale du bloc précédent. L&#39;en-tête du bloc est haché (c.-à-d., on obtient un résultat de hachage) pour produire une preuve de travail, validant ainsi les transactions. Les blocs valides sont ajoutés à la chaîne de blocs principale par consensus du réseau.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
blockchain (ou chaîne de blocs)
</term>
<listitem>
<simpara>
        Une liste de blocs validés, chacun lié à son prédécesseur jusqu&#39;au bloc de genèse.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
récompense de bloc (alias récompense coinbase (ou unité de monnaie primaire du bloc)
</term>
<listitem>
<simpara>
    Un montant inclus dans chaque nouveau bloc comme récompense par le réseau au mineur qui a trouvé la solution Proof-of-Work (ou Preuve de travail)). Environ tous les quatre ans, ou plus précisément tous les 210 000 blocs, la récompense de bloc globale est réduite de moitié. Il est actuellement de 6,25 BTC par bloc.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Byzantine Generals Problem (ou Problème des généraux Byzantins)
</term>
<listitem>
<simpara>
    Un système informatique fiable doit pouvoir faire face à la défaillance d&#39;un ou plusieurs de ses composants. Un composant défaillant peut présenter un type de comportement souvent négligé, à savoir l&#39;envoi d&#39;informations contradictoires à différentes parties du système. Le problème de faire face à ce type d&#39;échec est exprimé abstraitement comme le Byzantine Generals Problem (ou Problème des généraux byzantins) (voir <ulink url="https://fr.wikipedia.org/wiki/Probl%C3%A8me_des_g%C3%A9n%C3%A9raux_byzantins">https://fr.wikipedia.org/wiki/Probl%C3%A8me_des_g%C3%A9n%C3%A9raux_byzantins</ulink>).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bloc candidat
</term>
<listitem>
<simpara>
        Un bloc qu&#39;un mineur essaie toujours d&#39;exploiter. Ce n&#39;est pas encore un bloc valide, car il ne contient pas de Proof-of-Work (ou Preuve de travail) valide.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
coinbase (ou unité de monnaie primaire du bloc) (alias données coinbase)
</term>
<listitem>
<simpara>
        Un champ spécial utilisé comme seule entrée pour les transactions coinbase. Le champ de données coinbase permet de réclamer la récompense de bloc et fournit jusqu&#39;à 100 octets pour les données arbitraires.
        À ne pas confondre avec la "transaction coinbase" ou la "récompense coinbase".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
transaction coinbase
</term>
<listitem>
<simpara>
        La première transaction d&#39;un bloc; toujours créé par un mineur. Le coinbase est unique dans le bloc.
        À ne pas confondre avec coinbase (données coinbase) ou "récompense coinbase".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
stockage à froid
</term>
<listitem>
<simpara>
        Fait référence à la conservation d&#39;une réserve de bitcoins hors ligne. Le stockage à froid est réalisé lorsque les clés privées bitcoin sont créées et stockées dans un environnement hors ligne sécurisé. Le stockage à froid est important pour quiconque possède des avoirs en bitcoins. Les ordinateurs en ligne sont vulnérables aux pirates et ne doivent pas être utilisés pour stocker une quantité importante de bitcoins. (note du traducteur: l&#8217;auteur est un peu paranoïde; les noeuds sont en ligne. Si les noeuds sont insécures, c&#8217;est la fin de ce système et de ce livre.) ;)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
confirmations
</term>
<listitem>
<simpara>
        Une fois qu&#39;une transaction est incluse dans un bloc, elle a une confirmation. Dès qu&#39;un autre bloc est miné sur la même chaîne de blocs, la transaction a deux confirmations, et ainsi de suite. Six confirmations ou plus sont considérées comme une preuve suffisante qu&#39;une transaction ne peut pas être annulée.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
consensus
</term>
<listitem>
<simpara>
    Lorsque plusieurs nœuds, généralement la plupart des nœuds du réseau, ont tous les mêmes blocs dans leur meilleure chaîne de blocs validée localement.
    À ne pas confondre avec les règles de consensus.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
règles de consensus
</term>
<listitem>
<simpara>
    Les règles de validation de bloc que les nœuds complets suivent pour rester en consensus avec les autres nœuds.
    A ne pas confondre avec le consensus.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
difficulté
</term>
<listitem>
<simpara>
        Un paramètre à l&#39;échelle du réseau qui contrôle la quantité de calculs nécessaires pour produire une preuve de travail (ou le Proof-of-Work).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
reciblage de difficulté
</term>
<listitem>
<simpara>
        Un recalcul à l&#39;échelle du réseau de la difficulté qui se produit une fois tous les 2 016 blocs et prend en compte la puissance de hachage des 2 016 blocs précédents.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
cible de difficulté
</term>
<listitem>
<simpara>
    Une difficulté pour le calcul dans tout le réseau et qui permet de solutionner et valider l&#8217;ajout d&#8217;un bloc environ toutes les 10 minutes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
double dépense
</term>
<listitem>
<simpara>
    La double dépense est le résultat d&#39;avoir réussi à dépenser de l&#39;argent plus d&#39;une fois. Bitcoin protège contre les doubles dépenses en vérifiant chaque transaction ajoutée à la chaîne de blocs pour s&#39;assurer que les entrées de la transaction n&#39;avaient pas déjà été dépensées auparavant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
ECDSA
</term>
<listitem>
<simpara>
    Elliptic Curve Digital Signature Algorithm ou ECDSA est un algorithme cryptographique utilisé par bitcoin pour garantir que les fonds ne peuvent être dépensés que par leurs propriétaires légitimes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
nombre aléatoire explicite supplémentaire
</term>
<listitem>
<simpara>
    Au fur et à mesure que la difficulté augmentait, les mineurs parcouraient souvent les 4 milliards de nombres aléatoires explicites (nonce) sans trouver de bloc. Étant donné que le script coinbase peut stocker entre 2 et 100 octets de données, les mineurs ont commencé à utiliser cet espace comme espace pour un nombre aléatoire explicite supplémentaire, leur permettant d&#39;explorer une gamme beaucoup plus large de valeurs d&#39;en-tête de bloc pour trouver des blocs valides.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
frais
</term>
<listitem>
<simpara>
        L&#39;expéditeur d&#39;une transaction inclut souvent une valeur de frais au réseau pour le traitement de la transaction demandée. La plupart des transactions nécessitent des frais minimum de 0,5 mBTC.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
fourche
</term>
<listitem>
<simpara>
    La fourche, également connue sous le nom de fourche accidentelle, se produit lorsque deux blocs ou plus ont la même hauteur de bloc, forçant la chaîne de blocs à se dédoubler. Cela se produit généralement lorsque deux mineurs ou plus trouvent des blocs presque en même temps. Peut également se produire dans le cadre d&#39;une attaque.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bloc de genèse
</term>
<listitem>
<simpara>
        Le premier bloc de la chaîne de blocs, utilisé pour initialiser la cryptomonnaie (ou cybermonnaie).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
halving (ou réduction de moitié)
</term>
<listitem>
<simpara>
    Un événement de réduction de moitié se produit lorsque la récompense de bloc est réduite de moitié, ce qui se produit environ tous les quatre ans (ou précisément tous les 210 000 blocs). Bitcoin a déjà connu trois événements de réduction de moitié : en 2012 (de 50 à 25 BTC), en 2016 (de 25 à 12,5 BTC) et en 2020 (de 12,5 à 6,25 BTC).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
fourche dure
</term>
<listitem>
<simpara>
    La fourche dure, également connu sous le nom de Hard-Forking Change, est une divergence permanente dans la chaîne de blocs, se produit généralement lorsque les nœuds non mis à niveau ne peuvent pas valider les blocs créés par les nœuds mis à niveau qui suivent les nouvelles règles de consensus.
    À ne pas confondre avec une fourche, une fourche molle, une fourche de code ou une fourche Git, mais tout de même un nouvel embranchement d&#8217;une arborescence de données (avec une source parent unique).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
portefeuille matériel (hardware)
</term>
<listitem>
<simpara>
    Un portefeuille matériel est un type spécial de portefeuille bitcoin qui stocke les clés privées de l&#39;utilisateur dans un périphérique matériel sécurisé.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
résultat de hachage
</term>
<listitem>
<simpara>
    Une empreinte numérique d&#39;une entrée binaire.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
hashlocks (ou serrure par empreinte numérique)
</term>
<listitem>
<simpara>
    Un hashlock (ou serrure par empreinte numérique) est un type de contrainte qui limite les dépenses d&#39;une sortie jusqu&#39;à ce qu&#39;une donnée spécifique soit révélée publiquement. Les hashlocks ont la propriété utile qu&#39;une fois qu&#39;un hashlock est ouvert publiquement, tout autre hashlock sécurisé à l&#39;aide de la même clé peut également être ouvert. Cela permet de créer plusieurs sorties qui sont toutes encombrées par le même hashlock et qui deviennent toutes dépensables en même temps.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Protocole HD
</term>
<listitem>
<simpara>
    Le protocole de création et de transfert de clés Hierarchical Deterministic (HD) (BIP-32), qui permet de créer des clés enfants à partir de clés parents dans une hiérarchie.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Portefeuille HD 
</term>
<listitem>
<simpara>
    Portefeuilles utilisant le protocole de création et de transfert de clés Hierarchical Deterministic (HD Protocol) (BIP-32).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Portefeuille d&#8217;amorçage HD
</term>
<listitem>
<simpara>
    Le portefeuille d&#8217;amorçage HD ou la valeur d&#8217;amorçage est une valeur potentiellement courte utilisée comme valeur racine pour générer la clé privée principale et le code de chaîne principal pour un portefeuille HD.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
HTLC
</term>
<listitem>
<simpara>
    Un contrat Hashed TimeLock ou HTLC est une classe de paiements qui utilisent des hashlocks (ou serrures par empreintes numériques) et des timelocks (ou serrures par horodatage) pour exiger que le destinataire d&#39;un paiement reconnaisse avoir reçu le paiement avant une date limite en générant une preuve cryptographique de paiement ou renonce à la possibilité de réclamer le paiement, le retournant au payeur.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
KYC
</term>
<listitem>
<simpara>
     Know Your Customer (ou Connaître son client) (KYC) est le processus d&#39;une entreprise qui identifie et vérifie l&#39;identité de ses clients. Le terme est également utilisé pour désigner la réglementation bancaire qui régit ces activités.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
LevelDB
</term>
<listitem>
<simpara>
    LevelDB est un moyen de stockage clé-valeur open source sur disque. LevelDB est une bibliothèque légère à usage unique pour la persistance avec des liaisons sur de nombreuses plates-formes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Lightning Networks
</term>
<listitem>
<simpara>
    Lightning Network est une implémentation de Hashed Timelock Contracts (HTLC) avec des canaux de paiement bidirectionnels qui permettent aux paiements d&#39;être acheminés en toute sécurité sur plusieurs canaux de paiement pair à pair. Cela permet la formation d&#39;un réseau où n&#39;importe quel pair sur le réseau peut payer n&#39;importe quel autre pair même s&#39;ils n&#39;ont pas directement de canal ouvert entre eux.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Locktime (ou valeur de relâche de transaction)
</term>
<listitem>
<simpara>
    Locktime, ou plus techniquement nLockTime, est la partie d&#39;une transaction qui indique la première heure où le premier bloc auquel cette transaction peut être ajoutée à la chaîne de blocs. C&#8217;est une valeur horodatée servant de date ultérieur pour une transaction; comme un chèque postdaté.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
mempool
</term>
<listitem>
<simpara>
    Le bitcoin Mempool (bassin de mémoire) est une collection de toutes les données de transaction dans un bloc qui ont été vérifiées par les nœuds Bitcoin, mais qui ne sont pas encore confirmées.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
racine de merkle 
</term>
<listitem>
<simpara>
    Le nœud racine d&#39;un arbre Merkle, un descendant de toutes les paires hachées de l&#39;arbre. Les en-têtes de bloc doivent inclure une racine merkle valide issue de toutes les transactions de ce bloc.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
arbre de merkle
</term>
<listitem>
<simpara>
    Un arbre construit en hachant des données appariées (les feuilles), puis en appariant et en hachant les résultats jusqu&#39;à ce qu&#39;il ne reste qu&#39;un seul résultat de hachage, la racine de Merkle. En bitcoin, les feuilles sont presque toujours des transactions d&#39;un seul bloc.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
mineur
</term>
<listitem>
<simpara>
    Un nœud de réseau qui trouve une preuve de travail valide pour les nouveaux blocs, par hachage répété.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
récompense minière
</term>
<listitem>
<simpara>
    Les récompense que les mineurs reçoivent en échange de la sécurité fournie par l&#39;exploitation minière, comprend les nouvelles pièces bitcoin créées avec chaque nouveau bloc, également appelées récompense de bloc ou récompense coinbase, et les frais de transaction de toutes les transactions incluses dans le bloc.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
multisignature
</term>
<listitem>
<simpara>
    La multisignature (multisig) fait référence à l&#39;exigence d&#39;un nombre minimum (M) de clés (N) pour autoriser une transaction M-sur-N.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
réseau
</term>
<listitem>
<simpara>
    Un réseau pair à pair qui propage les transactions et les bloques à chaque nœud Bitcoin du réseau.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
nonce (ou nombre aléatoire explicite)
</term>
<listitem>
<simpara>
    Le &quot;nonce&quot; (ou nombre aléatoire explicite) dans un bloc bitcoin est un champ de 32 bits (4 octets) dont la valeur est définie de manière à ce que le résultat de hachage du bloc contienne une série de zéros non significatifs. Les autres champs ne peuvent pas être modifiés, car ils ont une signification définie.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
transactions hors chaîne 
</term>
<listitem>
<simpara>
    Une transaction hors chaîne est le mouvement de valeur en dehors de la chaîne de blocs, alors qu&#39;une transaction en chaîne&amp;#x2014 est  simplement appelée <emphasis>une transaction</emphasis>&amp;#x2014. La transaction hors chaîne modifie la chaîne de blocs et dépend de cette dernière pour déterminer sa validité. Une transaction hors chaîne de blocs s&#39;appuie sur d&#39;autres méthodes pour enregistrer et valider la transaction.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
opcode
</term>
<listitem>
<simpara>
    Codes d&#39;opération du langage de script bitcoin qui poussent des données ou exécutent des fonctions dans un script pubkey ou un script de signature.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Protocole Open Assets (ou Actifs ouverts)
</term>
<listitem>
<simpara>
    Le protocole Open Assets (ou Actifs ouverts) est un protocole simple et puissant construit au-dessus de la chaîne de blocs Bitcoin. Il permet l&#39;émission et le transfert d&#39;actifs créés par l&#39;utilisateur.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
OP_RETURN
</term>
<listitem>
<simpara>
    Un opcode (ou code d&#8217;opération) utilisé dans l&#39;une des sorties d&#39;une transaction OP_RETURN. A ne pas confondre avec la transaction OP_RETURN.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Transaction OP_RETURN 
</term>
<listitem>
<simpara>
    Un type de transaction qui ajoute des données arbitraires à un script pubkey prouvé que les nœuds complets n&#39;ont pas à stocker dans leur base de données UTXO. A ne pas confondre avec l&#39;opcode OP_RETURN.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bloc orphelin 
</term>
<listitem>
<simpara>
    Les blocs dont le bloc parent n&#39;a pas été traité par le nœud local, ils ne peuvent donc pas encore être entièrement validés. À ne pas confondre avec le bloc obsolète.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
orphan transactions
</term>
<listitem>
<simpara>
    Transactions qui ne peuvent pas entrer dans le bassin de mémoire (Mempool) en raison d&#39;une ou plusieurs transactions d&#39;entrée manquantes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
extrant
</term>
<listitem>
<simpara>
    L&#8217;Output (le produit sorti ou l&#8217;extrant), la sortie de transaction ou TxOut est une sortie dans une transaction qui contient deux champs : un champ de valeur pour transférer zéro ou plusieurs satoshis et un script pubkey pour indiquer quelles conditions doivent être remplies pour que ces satoshis soient dépensés davantage.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2PKH
</term>
<listitem>
<simpara>
    Les transactions qui paient une adresse Bitcoin contiennent des scripts P2PKH ou Pay To PubKey Hash. Une sortie verrouillée par un script P2PKH peut être déverrouillée (dépensée) en présentant une clé publique et une signature numérique créée par la clé privée correspondante.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2SH
</term>
<listitem>
<simpara>
    P2SH ou Pay-to-Script-Hash est un nouveau type de transaction puissant qui simplifie grandement l&#39;utilisation de scripts de transaction complexes. Avec P2SH le script complexe qui détaille les conditions de dépense de la sortie (redeem script) n&#39;est pas présenté dans le script de verrouillage. Au lieu de cela, seul un résultat de hachage de celui-ci se trouve dans le script de verrouillage.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Adresse P2SH
</term>
<listitem>
<simpara>
    Les adresses P2SH sont des encodages Base58Check du résultat de hachage de 20 octets d&#39;un script. Ils utilisent le préfixe de version &quot;5&quot;, ce qui donne des adresses encodées en Base58Check qui commencent par un &quot;3&quot;. Les adresses P2SH cachent toute la complexité, de sorte que la personne effectuant un paiement ne voit pas le script.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2WPKH
</term>
<listitem>
<simpara>
    La signature d&#39;un P2WPKH (Pay-to-Witness-Public-Key-Hash) contient les mêmes informations qu&#39;une dépense P2PKH, mais se trouve dans le champ témoin au lieu du champ scriptSig. Le scriptPubKey est également modifié.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2WSH
</term>
<listitem>
<simpara>
    La différence entre P2SH et P2WSH (Pay-to-Witness-Script-Hash) concerne le changement d&#39;emplacement de la preuve cryptographique du champ scriptSig au champ témoin et le scriptPubKey qui est également modifié.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
portefeuille papier
</term>
<listitem>
<simpara>
    Dans le sens le plus spécifique, un portefeuille papier est un document contenant toutes les données nécessaires pour générer un nombre quelconque de clés privées bitcoin, formant un portefeuille de clés. Cependant, les gens utilisent souvent le terme pour désigner tout moyen de stocker des bitcoins hors ligne en tant que document physique. Cette deuxième définition comprend également les clés papier et les codes échangeables.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
phrase de passe
</term>
<listitem>
<simpara>
    Une phrase de passe est une chaîne de caractères facultative créée par l&#39;utilisateur qui sert de facteur de sécurité supplémentaire protégeant la valeur d&#8217;amorçage, même lorsque la valeur d&#8217;amorçage est compromise par un voleur. Il peut également être utilisé comme une forme de pot de miel, où une phrase de passe choisie (une adresse bitcoin, un URL ou autre) mène à un portefeuille avec une petite quantité de fonds utilisée pour distraire un attaquant du &quot;vrai&quot; portefeuille qui contient la majorité des fonds.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
canaux de paiement
</term>
<listitem>
<simpara>
    Un canal de micropaiement ou canal de paiement est une classe de techniques conçues pour permettre aux utilisateurs d&#39;effectuer plusieurs transactions bitcoin sans engager toutes les transactions dans la chaîne de blocs Bitcoin. Dans un canal de paiement typique, seules deux transactions sont ajoutées à la chaîne de blocs, mais un nombre illimité ou presque illimité de paiements peut être effectué entre les participants.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
exploitation minière groupée
</term>
<listitem>
<simpara>
    L&#39;exploitation minière en groupe est une approche d&#39;exploitation minière dans laquelle plusieurs clients générateurs contribuent à la génération d&#39;un bloc, puis divisent la récompense du bloc en fonction de la puissance de traitement apportée.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Proof-of-Stake (ou Preuve d&#8217;enjeu)
</term>
<listitem>
<simpara>
    La preuve d&#8217;enjeu (PoS) est une méthode par laquelle un réseau de chaîne de blocs de cryptomonnaie vise à atteindre un consensus distribué. La preuve d&#8217;enjeu demande aux utilisateurs de prouver qu&#39;ils sont propriétaires d&#39;un certain montant de devise (leur « enjeu » ou « participation » dans la devise).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Proof-of-Work (ou Preuve de travail)
</term>
<listitem>
<simpara>
    Une donnée qui nécessite des calculs importants pour être trouvée. Dans le bitcoin, les mineurs doivent trouver une solution numérique à l&#39;algorithme SHA256 qui répond à une cible à l&#39;échelle du réseau, la cible de difficulté.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
RIPEMD-160
</term>
<listitem>
<simpara>
    RIPEMD-160 est une fonction de hachage cryptographique 160 bits. RIPEMD-160 est une version renforcée de RIPEMD avec un résultat de hachage de 160 bits, et devrait être sécurisé pour les dix prochaines années ou plus.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
satoshi
</term>
<listitem>
<simpara>
    Un satoshi est la plus petite dénomination de bitcoin pouvant être enregistrée sur la blockchain. Il équivaut à 0,00000001 bitcoin et porte le nom du créateur du bitcoin, Satoshi Nakamoto. <indexterm>
  <primary>&quot;satoshi&quot;</primary>
</indexterm>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Satoshi Nakamoto
</term>
<listitem>
<simpara>
    Satoshi Nakamoto est le nom utilisé par la ou les personnes qui ont conçu le bitcoin et créé son implémentation de référence originale, Bitcoin Core. Dans le cadre de la mise en œuvre, ils ont également conçu la première base de données chaîne de blocs. Dans le processus, ils ont été les premiers à résoudre le problème de la double dépense pour la monnaie numérique. Leur véritable identité reste inconnue.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Script
</term>
<listitem>
<simpara>
    Bitcoin utilise un système de script pour les transactions. Comme Forth, Script est simple, basé sur une pile et traité de gauche à droite. Il n&#39;est délibérément pas complet de Turing et sans boucles.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>ScriptPubKey (alias script pubkey): :
    ScriptPubKey ou script pubkey, est un script inclus dans les sorties qui définit les conditions qui doivent être remplies pour que ces satoshis soient dépensés. Les données permettant de remplir les conditions peuvent être fournies dans un script de signature.</simpara>
<simpara>ScriptSig (ou Script de signature): :
    ScriptSig ou script de signature, sont les données générées par un dépensier qui sont presque toujours utilisées comme variables pour satisfaire un script pubkey.</simpara>
<simpara>clé secrète (ou clé privée): :
        Le numéro secret qui déverrouille le bitcoin envoyé à l&#39;adresse correspondante.  <span class="keep-together">Une clé secrète</span>  ressemble à ceci :</simpara>
<simpara>+</simpara>
<screen>5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh</screen>
<variablelist>
<varlistentry>
<term>
Témoin Séparé
</term>
<listitem>
<simpara>
    Le témoin séparé est une mise à niveau du protocole Bitcoin dans laquelle les données de signature (&quot;témoin&quot;) sont séparées des données de l&#39;expéditeur/destinataire pour optimiser davantage la structure des transactions. Le témoin Séparé a été implémenté comme un embranchement convergent ; un changement qui rend techniquement les règles du protocole de bitcoin plus restrictives.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
SHA
</term>
<listitem>
<simpara>
    Le Secure Hash Algorithm ou SHA est une famille de fonctions de hachage cryptographiques publiées par le National Institute of Standards and Technology (NIST).
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Simplified Payment Verification (SPV ou Vérification simplifiée des paiements): :
    SPV ou vérification simplifiée des paiements est une méthode permettant de vérifier que des transactions particulières ont été incluses dans un bloc, sans télécharger le bloc entier. Cette méthode de vérification est souvent utilisée par les clients Bitcoin légers.</simpara>
<variablelist>
<varlistentry>
<term>
embranchement convergent
</term>
<listitem>
<simpara>
    L&#8217;embranchement convergent ou le Soft-Forking Change est un fourche temporaire dans la chaîne de blocs qui se produit généralement lorsque les mineurs utilisant des nœuds non mis à niveau ne suivent pas une nouvelle règle de consensus que leurs nœuds ne connaissent pas.
    À ne pas confondre avec fourche, fourche dure, fourche logicielle ou fourche de Git.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bloc périmé
</term>
<listitem>
<simpara>
    Un bloc valide qui a été extrait avec succès mais qui n&#39;est pas inclus dans la branche principale actuelle (avec la plupart des preuves de travail cumulatives), car un autre bloc valide qui a été extrait à la même hauteur a vu sa chaîne étendue en premier. Le mineur d&#39;un bloc périmé ne reçoit pas la récompense du bloc ni les frais de transaction de ce bloc.
    À ne pas confondre avec le bloc orphelin ou le bloc candidat.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
timelocks (ou serrures horaires)
</term>
<listitem>
<simpara>
    Un timelock (ou serrure horaire) est un type de contrainte qui limite la dépense de certains bitcoins jusqu&#39;à une heure future ou une hauteur de bloc spécifiée. Les timelocks figurent en bonne place dans de nombreux contrats bitcoin, y compris les canaux de paiement et les contrats de timelock hachés.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
transaction
</term>
<listitem>
<simpara>
    En termes simples, un transfert de bitcoin d&#39;une adresse à une autre. Plus précisément, une transaction est une structure de données signée exprimant un transfert de valeur. Les transactions sont transmises sur le réseau Bitcoin, collectées par les mineurs et incluses dans des blocs, rendus permanents sur la chaîne de blocs.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bassin de transactions
</term>
<listitem>
<simpara>
    Une collection non ordonnée de transactions qui ne sont pas en blocs dans la chaîne principale, mais pour lesquelles nous avons des transactions d&#39;entrée.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Complétude de Turing
</term>
<listitem>
<simpara>
    Un langage de programmation est appelé &quot;Turing complet&quot; s&#39;il peut exécuter n&#39;importe quel programme qu&#39;une machine de Turing peut exécuter, avec suffisamment de temps et de mémoire.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
unspent transaction output (UTXO ou sortie de transaction non dépensée)
</term>
<listitem>
<simpara>
    UTXO est une sortie de transaction non dépensée qui peut être dépensée comme entrée dans une nouvelle transaction.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
portefeuille
</term>
<listitem>
<simpara>
    Logiciel qui contient toutes vos adresses Bitcoin et clés secrètes. Utilisez-le pour envoyer, recevoir et stocker vos bitcoins.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Wallet Import Format (WIF ou Format d&#8217;importation de portefeuille)
</term>
<listitem>
<simpara>
    WIF ou Wallet Import Format (format d&#8217;importation de portefeuille) est un format d&#39;échange de données conçu pour permettre l&#39;exportation et l&#39;importation d&#39;une seule clé privée avec un indicateur indiquant s&#39;il utilise ou non une clé publique compressée.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Certaines définitions fournies ont été extraites sous une licence CC-BY de <ulink url="https://en.bitcoin.it/wiki/Main_Page">bitcoin Wiki</ulink> ou d&#39;autres documentations à source libre.</simpara>
</preface>
<section id="ch01_intro_what_is_bitcoin" role="pagenumrestart">
<title>Introduction</title>
<section id="_qu_39_est_ce_que_bitcoin">
<title>Qu&#39;est-ce que Bitcoin ?</title>
<simpara><indexterm>
  <primary>&quot;bitcoin&quot;</primary><secondary>&quot;défini&quot;</secondary><tertiary>id=&quot;GSdefine01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary><secondary>id=&quot;GSdefine01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;GSdefine01&quot;</primary>
</indexterm>Bitcoin est un ensemble de concepts et de technologies qui constituent la base d&#39;un écosystème de monnaie numérique. Les unités monétaires appelées bitcoin sont utilisées pour stocker et transmettre de la valeur entre les participants au réseau Bitcoin. Les utilisateurs de Bitcoin communiquent entre eux en utilisant le protocole Bitcoin principalement via Internet, bien que d&#39;autres réseaux de transport puissent également être utilisés. La pile de protocole Bitcoin, disponible en tant que logiciel à source libre, peut être exécutée sur une large gamme d&#39;appareils informatiques, y compris les ordinateurs portables et les smartphones, ce qui rend la technologie facilement accessible.</simpara>
<tip>
<simpara>Remarquez comment l&#39;unité monétaire s&#39;appelle &quot;bitcoin&quot; avec un petit <emphasis>b</emphasis>, et le système s&#39;appelle &quot;Bitcoin&quot;, avec un <emphasis>B</emphasis> majuscule.</simpara>
</tip>
<simpara>Les utilisateurs peuvent transférer des bitcoins sur le réseau pour faire à peu près tout ce qui peut être fait avec des devises conventionnelles, y compris acheter et vendre des biens, envoyer de l&#39;argent à des personnes ou à des organisations ou accorder un crédit. Le bitcoin peut être acheté, vendu et échangé contre d&#39;autres devises dans des bureaux de change spécialisés. Le bitcoin est en un sens la forme d&#39;argent idéale pour Internet car il est rapide, sécurisé et sans frontières.</simpara>
<simpara>Contrairement aux monnaies traditionnelles, le bitcoin est entièrement virtuel. Il n&#39;y a pas de pièces physiques ni même de pièces numériques en soi. Les pièces sont impliquées dans des transactions qui transfèrent de la valeur de l&#39;expéditeur au destinataire. Les utilisateurs de Bitcoin possèdent des clés qui leur permettent de prouver la propriété du bitcoin dans le réseau Bitcoin. Avec ces clés, ils peuvent signer des transactions pour débloquer la valeur et la dépenser en la transférant à un nouveau propriétaire. Les clés sont souvent stockées dans un portefeuille numérique sur l&#39;ordinateur ou le smartphone de chaque utilisateur. La possession de la clé qui peut signer une transaction est la seule condition préalable pour dépenser du bitcoin, mettant le contrôle entièrement entre les mains de chaque utilisateur.</simpara>
<simpara>Bitcoin est un système distribué pair à pair. En tant que tel, il n&#39;y a pas de serveur &quot;central&quot; ou de point de contrôle. Les unités de bitcoin sont créés par un processus appelé &quot;minage&quot;, qui implique une compétition pour trouver des solutions à un problème mathématique lors du traitement des transactions Bitcoin. Tout participant au réseau Bitcoin (c&#39;est-à-dire toute personne utilisant un appareil exécutant la pile complète du protocole Bitcoin) peut opérer en tant que mineur, en utilisant la puissance de traitement de son ordinateur pour vérifier et enregistrer les transactions. Toutes les 10 minutes, en moyenne, un mineur de Bitcoin peut valider les transactions et est récompensé par un tout nouveau bitcoin. Essentiellement, l&#39;extraction de Bitcoin décentralise les fonctions d&#39;émission et de compensation de devises d&#39;une banque centrale et remplace le besoin de cette dernière.</simpara>
<simpara>Le protocole Bitcoin comprend des algorithmes intégrés qui régulent la fonction de minage sur le réseau. La difficulté de la tâche de traitement que les mineurs doivent effectuer est ajustée dynamiquement de sorte qu&#39;en moyenne, quelqu&#39;un réussisse toutes les 10 minutes, quel que soit le nombre de mineurs (et la quantité de traitement) en compétition à tout moment. Le protocole réduit également de moitié le taux de création de nouveaux bitcoins tous les 4 ans et limite le nombre total de bitcoins qui seront créés à un total fixe juste en dessous de 21 millions de pièces. Le résultat est que le nombre de bitcoins en circulation suit de près une courbe facilement prévisible qui approche les 21 millions d&#39;ici 2140. En raison du taux d&#39;émission décroissant du bitcoin, sur le long terme, la monnaie Bitcoin est déflationniste. De plus, le bitcoin ne peut pas être gonflé en &quot;imprimant&quot; de la nouvelle monnaie au-delà du taux d&#39;émission prévu.</simpara>
<simpara>Dans les coulisses, Bitcoin est aussi le nom du protocole, un réseau pair à pair et une innovation informatique distribuée. La monnaie bitcoin n&#39;est vraiment que la première application de cette invention. Bitcoin représente l&#39;aboutissement de décennies de recherche en cryptographie et en systèmes distribués et comprend quatre innovations clés réunies dans une combinaison unique et puissante. Bitcoin se compose de :</simpara>
<itemizedlist>
<listitem>
<simpara>
Un réseau pair à pair décentralisé (le protocole Bitcoin)
</simpara>
</listitem>
<listitem>
<simpara>
Un registre public des transactions (la chaîne de blocs)
</simpara>
</listitem>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;exploitation minière et consensus&quot;</primary><secondary>&quot;règles de consensus&quot;</secondary><tertiary>&quot;satisfaisant&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;règles de consensus&quot;</primary><secondary>&quot;satisfaisant&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;satisfaisant&quot;</primary>
</indexterm>Un ensemble de règles pour la validation indépendante des transactions et l&#39;émission de devises (règles de consensus)
</simpara>
</listitem>
<listitem>
<simpara>
Un mécanisme pour parvenir à un consensus mondial décentralisé sur la chaîne de blocs valide (algorithme de Proof-of-Work (ou Preuve de travail))
</simpara>
</listitem>
</itemizedlist>
<simpara>En tant que développeur, je vois Bitcoin comme un Internet de l&#39;argent, un réseau pour propager la valeur et sécuriser la propriété des actifs numériques via un calcul distribué. Il y a beaucoup plus à Bitcoin qu&#39;il n&#39;y paraît à première vue.</simpara>
<simpara>Dans ce chapitre, nous commencerons par expliquer certains des concepts et termes principaux, et obtenir le logiciel nécessaire et utiliser Bitcoin pour des transactions simples. Dans les chapitres suivants, nous commencerons à déballer les couches de technologie qui rendent Bitcoin possible et examinerons le fonctionnement interne du réseau et du protocole Bitcoin.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;GSdefine01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;GSdefine01&quot;</primary>
</indexterm></simpara>
<sidebar role="pagebreak-before less_space">
<title>Devises numériques avant Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;monnaies numériques&quot;</primary><secondary>&quot;avant le bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avant le bitcoin&quot;</primary>
</indexterm>L&#39;émergence d&#39;une monnaie numérique viable est étroitement liée aux développements de la cryptographie. Cela n&#39;est pas surprenant si l&#39;on considère les défis fondamentaux liés à l&#39;utilisation de bits pour représenter la valeur qui peut être échangée contre des biens et des services. Trois questions fondamentales pour quiconque accepte de l&#39;argent numérique sont :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Puis-je avoir la certitude que l&#39;argent est authentique et non contrefait ?
</simpara>
</listitem>
<listitem>
<simpara>
Puis-je avoir confiance que l&#39;argent numérique ne peut être dépensé qu&#39;une seule fois (connu sous le nom de problème de « double dépense ») ?
</simpara>
</listitem>
<listitem>
<simpara>
Puis-je être sûr que personne d&#39;autre ne pourra prétendre que cet argent lui appartient et pas à moi ?
</simpara>
</listitem>
</orderedlist>
<simpara>Les émetteurs de papier-monnaie luttent constamment contre le problème de la contrefaçon en utilisant des papiers et des technologies d&#39;impression de plus en plus sophistiqués. L&#39;argent physique résout facilement le problème des doubles dépenses, car le même billet papier ne peut pas se trouver à deux endroits à la fois. Bien sûr, l&#39;argent conventionnel est aussi souvent stocké et transmis numériquement. Dans ces cas, les problèmes de contrefaçon et de double dépense sont traités en compensant toutes les transactions électroniques par des autorités centrales qui ont une vue globale de la monnaie en circulation. Pour la monnaie numérique, qui ne peut tirer profit des encres ésotériques ou des bandes holographiques, la cryptographie fournit la base pour faire confiance à la légitimité de la revendication de valeur d&#39;un utilisateur. Plus précisément, les signatures numériques cryptographiques permettent à un utilisateur de signer un actif numérique ou une transaction prouvant la propriété de cet actif. Avec l&#39;architecture appropriée, les signatures numériques peuvent également être utilisées pour résoudre le problème des doubles dépenses.</simpara>
<simpara>Lorsque la cryptographie a commencé à devenir plus largement disponible et comprise à la fin des années 1980, de nombreux chercheurs ont commencé à essayer d&#39;utiliser la cryptographie pour créer des monnaies numériques. Ces premiers projets de monnaie numérique émettaient de la monnaie numérique, généralement adossée à une monnaie nationale ou à un métal précieux comme l&#39;or.</simpara>
<simpara><indexterm>
  <primary>&quot;systèmes décentralisés&quot;</primary><secondary>&quot;vs. centralisé&quot;</secondary><tertiary>secondary-sortas=&quot;centralisé&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;vs. centralisé&quot;</primary><secondary>secondary-sortas=&quot;centralisé&quot;</secondary>
</indexterm>
<indexterm>
  <primary>secondary-sortas=&quot;centralisé&quot;</primary>
</indexterm> Bien que ces anciennes monnaies numériques fonctionnaient, elles étaient centralisées et, par conséquent, faciles à attaquer par les gouvernements et les pirates. Les premières monnaies numériques utilisaient une chambre de compensation centrale pour régler toutes les transactions à intervalles réguliers, tout comme un système bancaire traditionnel. Malheureusement, dans la plupart des cas, ces monnaies numériques naissantes ont été ciblées par des gouvernements inquiets et ont finalement été dissoutes. Certains ont échoué dans des crashs spectaculaires lorsque la société mère a été liquidée brutalement. Pour être robuste contre l&#39;intervention d&#39;antagonistes, qu&#39;il s&#39;agisse de gouvernements légitimes ou d&#39;éléments criminels, une monnaie numérique <emphasis>décentralisée</emphasis> était nécessaire pour éviter un seul point d&#39;attaque. Bitcoin est un tel système, décentralisé par conception, et libre de toute autorité centrale ou point de contrôle qui peut être attaqué ou corrompu.</simpara>
</sidebar>
</section>
<section id="_histoire_de_bitcoin">
<title>Histoire de Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;Nakamoto</primary><secondary>Satoshi&quot;</secondary>
</indexterm>
<indexterm>
  <primary>Satoshi&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;informatique distribuée&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;bitcoin&quot;</primary><secondary>&quot;histoire de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;histoire de&quot;</primary>
</indexterm>Bitcoin a été inventé en 2008 avec la publication d&#39;un article intitulé &quot;Bitcoin : A Peer-to-Peer Electronic Cash System,&quot;<footnote><simpara>&quot;Bitcoin: A Peer-to-Peer Electronic Cash System,&quot; Satoshi Nakamoto (<ulink url="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</ulink>).</simpara></footnote> écrit sous l&#39;alias de Satoshi Nakamoto (voir <xref linkend="satoshi_whitepaper"/>). Nakamoto a combiné plusieurs inventions antérieures telles que b-money et HashCash pour créer un système de paiement électronique entièrement décentralisé qui ne repose pas sur une autorité centrale pour l&#39;émission de devises ou le règlement et la validation des transactions. <indexterm>
  <primary>&quot;Algorithme de preuve de travail&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;systèmes décentralisés&quot;</primary><secondary>&quot;consensus dans&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;consensus dans&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;exploration et consensus&quot;</primary><secondary>&quot;Algorithme de preuve de travail&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Algorithme de preuve de travail&quot;</primary>
</indexterm>L&#39;innovation clé consistait à utiliser un système de calcul distribué (appelé algorithme de « preuve de travail ») pour effectuer une « élection » globale toutes les 10 minutes, permettant au réseau décentralisé d&#39;arriver à un <emphasis>consensus</emphasis> sur l&#39;état des transactions. <indexterm>
  <primary>&quot;problème de double dépense&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;dépenser du bitcoin&quot;</primary><secondary>&quot;problème de double dépense&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;problème de double dépense&quot;</primary>
</indexterm>Cela résout élégamment le problème de la double dépense où une seule unité monétaire peut être dépensée deux fois. Auparavant, le problème des doubles dépenses était une faiblesse de la monnaie numérique et était résolu en compensant toutes les transactions via une chambre de compensation centrale.</simpara>
<simpara>Le réseau Bitcoin a démarré en 2009, sur la base d&#39;une référence d&#8217;implémentation publiée par Nakamoto et révisée depuis par de nombreux autres programmeurs. La mise en œuvre de l&#39;algorithme Proof-of-Work (ou Preuve de travail ou minage) qui assure la sécurité et la résilience de Bitcoin a augmenté de manière exponentielle et dépasse désormais la puissance de traitement combinée des meilleurs supercalculateurs du monde. La valeur marchande totale de Bitcoin a parfois dépassé 1 billion de dollars américains, selon le taux de change bitcoin-dollar. La transaction la plus importante traitée jusqu&#39;à présent par le réseau était de 1,1 milliard de dollars américains, transmise instantanément et traitée pour des frais de seulement 0,68 $.</simpara>
<simpara>Satoshi Nakamoto s&#39;est retiré du public en avril 2011, laissant la responsabilité de développer le code et le réseau à un groupe prospère de bénévoles. L&#39;identité de la personne ou des personnes derrière Bitcoin est encore inconnue. <indexterm>
  <primary>&quot;licences à sources libres&quot;</primary>
</indexterm>Cependant, ni Satoshi Nakamoto ni personne d&#39;autre n&#39;exerce de contrôle individuel sur le système Bitcoin, qui fonctionne sur la base de principes mathématiques totalement transparents, d&#39;un code à source libre et d&#39;un consensus entre les participants. L&#39;invention elle-même est révolutionnaire et a déjà engendré une nouvelle science dans les domaines de l&#39;informatique distribuée, de l&#39;économie et de l&#39;économétrie.</simpara>
<sidebar>
<title>Une solution à un problème de calcul distribué</title>
<simpara><indexterm>
  <primary>&quot;Le problème des généraux byzantins&quot;</primary>
</indexterm>L&#39;invention de Satoshi Nakamoto est également une solution pratique et nouvelle à un problème d&#39;informatique distribuée, connu sous le nom de &quot;Problème des généraux byzantins&quot;. Brièvement, le problème consiste à essayer de s&#39;entendre sur une ligne de conduite ou sur l&#39;état d&#39;un système en échangeant des informations sur un réseau peu fiable et potentiellement compromis. <indexterm>
  <primary>&quot;autorité centrale de confiance&quot;</primary>
</indexterm>La solution de Satoshi Nakamoto, qui utilise le concept de preuve de travail pour parvenir à un consensus <emphasis>sans autorité centrale de confiance</emphasis>, représente une percée dans l&#39;informatique distribuée et a une large applicabilité au-delà de la monnaie. Il peut être utilisé pour parvenir à un consensus sur les réseaux décentralisés afin de prouver l&#39;équité des élections, des loteries, des registres d&#39;actifs, de la notarisation numérique, etc.</simpara>
</sidebar>
</section>
<section id="user-stories">
<title>Utilisations, utilisateurs et histoires de Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;bitcoin&quot;</primary><secondary>&quot;cas d&#39;utilisation&quot;</secondary><tertiary>id=&quot;GSuses01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>id=&quot;GSuses01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;GSuses01&quot;</primary>
</indexterm>Bitcoin est une innovation dans l&#39;ancienne technologie de l&#39;argent. À la base, l&#39;argent facilite simplement l&#39;échange de valeur entre les personnes. Par conséquent, afin de bien comprendre Bitcoin et ses utilisations, nous l&#39;examinerons du point de vue des personnes qui l&#39;utilisent. Chacune des personnes et de leurs histoires, telles qu&#39;énumérées ici, illustre un ou plusieurs cas d&#39;utilisation spécifiques. Nous les verrons tout au long du livre :</simpara>
<variablelist>
<varlistentry>
<term>
Vente au détail de faible valeur en Amérique du Nord
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;vente au détail&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;vente au détail&quot;</primary>
</indexterm>Alice vit dans la région de la baie de Californie du Nord. Elle a entendu parler de Bitcoin par ses amis technophiles et veut commencer à l&#39;utiliser. Nous suivrons son histoire au fur et à mesure qu&#39;elle découvre le Bitcoin, en acquiert, puis dépense une partie de son bitcoin pour acheter une tasse de café au Bob&#39;s Cafe à Palo Alto. Cette histoire nous présentera le logiciel, les échanges et les transactions de base du point de vue d&#39;un consommateur de détail.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Vente au détail de grande valeur en Amérique du Nord
</term>
<listitem>
<simpara>
Carol est propriétaire d&#39;une galerie d&#39;art à San Francisco. Elle vend des peintures chères pour Bitcoin. Cette histoire présentera les risques d&#39;une attaque de consensus &quot;51%&quot; pour les détaillants d&#39;articles de grande valeur.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Services contractuels extraterritorial
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;services contractuels extraterritoriaux&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;services contractuels extraterritoriaux&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;services contractuels extraterritoriaux&quot;</primary>
</indexterm>Bob, le propriétaire d&#39;un café à Palo Alto, est en train de créer un nouveau site Web. Il a passé un contrat avec un développeur Web indien, Gopesh, qui vit à Bangalore, en Inde. Gopesh a accepté d&#39;être payé en bitcoin. Cette histoire examinera l&#39;utilisation de Bitcoin pour l&#39;externalisation, les services contractuels et les virements internationaux.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Commerce en ligne
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;boutique en ligne&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;boutique en ligne&quot;</primary>
</indexterm>Gabriel est un jeune adolescent entreprenant à Rio de Janeiro, qui dirige une petite boutique en ligne qui vend des t-shirts, des tasses à café et des autocollants de marque Bitcoin. Gabriel est trop jeune pour avoir un compte bancaire, mais ses parents encouragent son esprit d&#39;entreprise.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Dons caritatifs
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;dons caritatifs&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;dons caritatifs&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;dons caritatifs&quot;</primary>
</indexterm>Eugenia est directrice d&#39;une association caritative pour enfants aux Philippines. Récemment, elle a découvert Bitcoin et souhaite l&#39;utiliser pour atteindre un tout nouveau groupe de donateurs étrangers et nationaux afin de collecter des fonds pour son association caritative. Elle étudie également les moyens d&#39;utiliser Bitcoin pour distribuer rapidement des fonds aux zones qui en ont besoin. Cette histoire montrera l&#39;utilisation de Bitcoin pour la collecte de fonds mondiale à travers les devises et les frontières et l&#39;utilisation d&#39;un registre ouvert pour la transparence dans les organisations caritatives.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Importation/Exportation
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;importation/exportation&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;importation/exportation&quot;</primary>
</indexterm>Mohammed est un importateur d&#39;électronique à Dubaï. Il essaie d&#39;utiliser Bitcoin pour acheter des appareils électroniques aux États-Unis et en Chine pour les importer aux Émirats arabes unis afin d&#39;accélérer le processus de paiement des importations. Cette histoire montrera comment Bitcoin peut être utilisé pour d&#39;importants paiements internationaux interentreprises liés à des biens physiques.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Miner des bitcoins
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;miner le bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;miner le bitcoin&quot;</primary>
</indexterm>Jing est un étudiant en génie informatique à Shanghai. Il a construit une plate-forme «minière» pour exploiter le bitcoin en utilisant ses compétences en ingénierie pour compléter ses revenus. Cette histoire examinera la base &quot;industrielle&quot; de Bitcoin : l&#39;équipement spécialisé utilisé pour sécuriser le réseau Bitcoin et émettre de nouvelles devises.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Chacune de ces histoires est basée sur de vraies personnes et de vraies industries utilisant actuellement Bitcoin pour créer de nouveaux marchés, de nouvelles industries et des solutions innovantes aux problèmes économiques mondiaux.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;GSuses01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;GSuses01&quot;</primary>
</indexterm></simpara>
</section>
<section id="_mise_en_route">
<title>Mise en route</title>
<simpara><indexterm>
  <primary>&quot;comment démarrer&quot;</primary><secondary>&quot;sélection du portefeuille&quot;</secondary><tertiary>id=&quot;GSwallet01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sélection du portefeuille&quot;</primary><secondary>id=&quot;GSwallet01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;GSwallet01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;sélectionner&quot;</secondary><tertiary>id=&quot;Wselect01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sélectionner&quot;</primary><secondary>id=&quot;Wselect01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Wselect01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;bitcoin&quot;</primary><secondary>&quot;commencer &quot;</secondary><tertiary>id=&quot;BCbasic01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;commencer &quot;</primary><secondary>id=&quot;BCbasic01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCbasic01&quot;</primary>
</indexterm>Bitcoin est un protocole accessible à l&#39;aide d&#39;une application cliente qui parle le protocole. Un &quot;portefeuille Bitcoin&quot; est l&#39;interface utilisateur la plus courante du système Bitcoin, tout comme un navigateur Web est l&#39;interface utilisateur la plus courante pour le protocole HTTP. Il existe de nombreuses implémentations et marques de portefeuilles Bitcoin, tout comme il existe de nombreuses marques de navigateurs Web (par exemple, Chrome, Safari, Firefox et Internet Explorer). Et tout comme nous avons tous nos navigateurs préférés (Mozilla Firefox, Yé !) et nos méchants (Internet Explorer, Beurk !), les portefeuilles Bitcoin varient en termes de qualité, de performances, de sécurité, de confidentialité et de fiabilité. Il existe également une implémentation de référence du protocole Bitcoin qui inclut un portefeuille, connu sous le nom de &quot;Satoshi Client&quot; ou &quot;Bitcoin Core&quot;, qui est dérivé de l&#39;implémentation originale écrite par Satoshi Nakamoto.</simpara>
<section id="_choisir_un_portefeuille_bitcoin">
<title>Choisir un portefeuille Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;sécurité&quot;</primary><secondary>&quot;sélection de portefeuille&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sélection de portefeuille&quot;</primary>
</indexterm>Les portefeuilles Bitcoin sont l&#39;une des applications les plus activement développées dans l&#39;écosystème Bitcoin. La concurrence est intense et, bien qu&#39;un nouveau portefeuille soit probablement en cours de développement, plusieurs portefeuilles de l&#39;année dernière ne sont plus activement maintenus. De nombreux portefeuilles se concentrent sur des plates-formes spécifiques ou des utilisations spécifiques et certains sont plus adaptés aux débutants tandis que d&#39;autres sont remplis de fonctionnalités pour les utilisateurs avancés. Le choix d&#39;un portefeuille est très subjectif et dépend de l&#39;utilisation et de l&#39;expertise de l&#39;utilisateur. Par conséquent, il serait inutile de recommander une marque ou un portefeuille spécifique. Cependant, nous pouvons classer les portefeuilles Bitcoin en fonction de leur plate-forme et de leur fonction et fournir des éclaircissements sur tous les différents types de portefeuilles qui existent. Mieux encore, déplacer des clés ou des valeurs d&#8217;amorçages (les "seeds") entre les portefeuilles Bitcoin est relativement facile, il vaut donc la peine d&#39;essayer plusieurs portefeuilles différents jusqu&#39;à ce que vous en trouviez un qui corresponde à vos besoins.</simpara>
<simpara role="pagebreak-before">Les portefeuilles Bitcoin peuvent être classés comme suit, selon la plateforme :</simpara>
<variablelist>
<varlistentry>
<term>
Portefeuille de bureau
</term>
<listitem>
<simpara>
Un portefeuille de bureau a été le premier type de portefeuille Bitcoin créé comme implémentation de référence et de nombreux utilisateurs utilisent des portefeuilles de bureau pour les fonctionnalités, l&#39;autonomie et le contrôle qu&#39;ils offrent. L&#39;exécution sur des systèmes d&#39;exploitation à usage général tels que Windows et Mac OS présente cependant certains inconvénients en matière de sécurité, car ces plates-formes sont souvent non sécurisées et mal configurées.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Portefeuille mobile
</term>
<listitem>
<simpara>
Un portefeuille mobile est le type le plus courant de portefeuille Bitcoin. Fonctionnant sur des systèmes d&#39;exploitation de téléphones intelligents tels qu&#39;Apple iOS et Android, ces portefeuilles sont souvent un excellent choix pour les nouveaux utilisateurs. Beaucoup sont conçus pour être simples et faciles à utiliser, mais il existe également des portefeuilles mobiles complets pour les utilisateurs expérimentés.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Portefeuille Web
</term>
<listitem>
<simpara>
Les portefeuilles Web sont accessibles via un navigateur Web et stockent le portefeuille de l&#39;utilisateur sur un serveur appartenant à un tiers. Ceci est similaire au webmail en ce sens qu&#39;il repose entièrement sur un serveur tiers. Certains de ces services fonctionnent à l&#39;aide d&#39;un code côté client exécuté dans le navigateur web de l&#39;utilisateur, qui garde le contrôle des clés Bitcoin entre les mains de l&#39;utilisateur. La plupart, cependant, présentent un compromis en prenant le contrôle des clés Bitcoin des utilisateurs en échange d&#39;une facilité d&#39;utilisation. Il est déconseillé de stocker de grandes quantités de bitcoins sur des systèmes tiers.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Portefeuille matériel (hardware)
</term>
<listitem>
<simpara>
Les portefeuilles matériels sont des appareils qui exploitent un portefeuille Bitcoin autonome sécurisé sur du matériel à usage spécial. Ils se connectent généralement à un ordinateur de bureau ou à un appareil mobile via un câble USB ou une communication en champ proche (NFC) et fonctionnent avec un navigateur Web ou un logiciel associé. En gérant toutes les opérations liées au Bitcoin sur le matériel spécialisé, ces portefeuilles sont considérés comme très sécurisés et adaptés au stockage de grandes quantités de Bitcoin.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Une autre façon de catégoriser les portefeuilles bitcoin est leur degré d&#39;autonomie et la façon dont ils interagissent avec le réseau Bitcoin :</simpara>
<variablelist>
<varlistentry>
<term>
Client de nœud complet
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;clients de nœud complet&quot;</primary>
</indexterm> Un client complet, ou &quot;nœud complet&quot;, est un client qui stocke l&#39;historique complet des transactions Bitcoin (chaque transaction par chaque utilisateur, toujours), gère les portefeuilles des utilisateurs et peuvent initier des transactions directement sur le réseau Bitcoin. Un nœud complet gère tous les aspects du protocole et peut valider indépendamment l&#39;ensemble de la chaîne de blocs et toute transaction. Un client à nœud complet consomme des ressources informatiques importantes (par exemple, plus de 125 Go de disque, 2 Go de RAM) mais offre une autonomie complète et une vérification indépendante des transactions.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Client léger
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;clients légers&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;vérification-de-paiement-simplifiée (SPV ou  simplified-payment-verification)&quot;</primary>
</indexterm>Un client léger, également connu sous le nom de client de vérification de paiement simplifié (SPV ou  simplified-payment-verification), se connecte aux nœuds complets Bitcoin (mentionnés précédemment) pour l&#39;accès aux informations de transaction Bitcoin, mais stocke le portefeuille de l&#39;utilisateur localement et crée, valide et transmet indépendamment les transactions. Les clients légers interagissent directement avec le réseau Bitcoin, sans intermédiaire.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Client API tiers
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;clients API tiers&quot;</primary>
</indexterm> Un client API tiers est un client qui interagit avec Bitcoin via un système tiers d&#39;interfaces de programmation d&#39;applications (API), plutôt qu&#39;en se connectant directement au réseau Bitcoin. Le portefeuille peut être stocké par l&#39;utilisateur ou par des serveurs tiers, mais toutes les transactions passent par un tiers.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>En combinant ces catégorisations, de nombreux portefeuilles Bitcoin se répartissent en quelques groupes, les trois plus courants étant le client complet de bureau, le portefeuille léger mobile et le portefeuille Web tiers. Les frontières entre les différentes catégories sont souvent floues, car de nombreux portefeuilles fonctionnent sur plusieurs plates-formes et peuvent interagir avec le réseau de différentes manières.</simpara>
<simpara>Pour les besoins de ce livre, nous démontrerons l&#39;utilisation d&#39;une variété de clients Bitcoin téléchargeables, de l&#39;implémentation de référence (Bitcoin Core) aux portefeuilles mobiles et Web. Certains des exemples nécessiteront l&#39;utilisation de Bitcoin Core, qui, en plus d&#39;être un client complet, expose également les API au portefeuille, au réseau et aux services de transaction. Si vous envisagez d&#39;explorer les interfaces de programmation dans le système Bitcoin, vous devrez exécuter Bitcoin Core ou l&#39;un des clients alternatifs.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;GSwallet01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;GSwallet01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref =&quot;Wselect01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref =&quot;Wselect01&quot;</primary>
</indexterm></simpara>
</section>
<section id="_démarrage_rapide">
<title>Démarrage rapide</title>
<simpara><indexterm>
  <primary>&quot;comment démarrer&quot;</primary><secondary>&quot;exemple de démarrage rapide&quot;</secondary><tertiary>id=&quot;GSquick01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;exemple de démarrage rapide&quot;</primary><secondary>id=&quot;GSquick01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;GSquick01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;exemple de démarrage rapide&quot;</secondary><tertiary>id=&quot;Wquick01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;exemple de démarrage rapide&quot;</primary><secondary>id=&quot;Wquick01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Wquick01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;acheter du café&quot;</secondary><tertiary>id=&quot;aliceone&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;acheter du café&quot;</primary><secondary>id=&quot;aliceone&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;aliceone&quot;</primary>
</indexterm>Alice, que nous avons présenté dans <xref linkend="user-stories"/>, n&#39;est pas une utilisatrice technique et n&#39;a entendu parler de Bitcoin que récemment par son ami Joe. Lors d&#39;une fête, Joe explique à nouveau avec enthousiasme Bitcoin à tout le monde et propose une démonstration. Intriguée, Alice demande comment elle peut démarrer avec Bitcoin. Joe dit qu&#39;un portefeuille mobile est ce qu&#39;il y a de mieux pour les nouveaux utilisateurs et il recommande quelques-uns de ses portefeuilles préférés. Alice télécharge &quot;Bluewallet&quot; (disponible pour iOS et Android) et l&#39;installe sur son téléphone.</simpara>
<simpara>Quand Alice exécute son application de portefeuille pour la première fois, elle choisit l&#39;option de créer un nouveau portefeuille Bitcoin et prend un moment <emphasis role="strong">loin de Joe et de toutes les autres parties</emphasis> pour écrire une phrase mnémonique secrète <emphasis>dans l&#39;ordre</emphasis> sur un morceau de papier. Comme expliqué par le portefeuille mobile et par Joe plus tôt, la phrase mnémotechnique permet à Alice de restaurer son portefeuille au cas où elle perdrait son appareil mobile et lui donne accès à ses fonds sur un autre appareil. Après avoir créé son portefeuille et sécurisé sa phrase mnémonique, Alice peut appuyer sur son portefeuille pour voir son montant en bitcoins, l&#39;historique des transactions, ainsi que deux boutons qui lui permettent de <emphasis>recevoir</emphasis> ou <emphasis>envoyer</emphasis> des bitcoins, illustrés dans <xref linkend="bluewallet-welcome"/>.</simpara>
</section>
<section id="_mots_mnémoniques">
<title>Mots Mnémoniques</title>
<simpara>Un portefeuille Bitcoin moderne fournira une <emphasis>phrase mnémonique</emphasis> (aussi parfois appelée &quot;valeur d&#8217;amorçage&quot; ou &quot;phrase de récupération&quot;) qu&#39;Alice pourra sauvegarder. La phrase mnémonique se compose de 12 à 24 mots anglais, sélectionnés au hasard par le logiciel, et utilisés comme base pour les clés générées par le portefeuille. La phrase mnémotechnique peut être utilisée par Alice pour restaurer toutes les transactions et tous les fonds de son portefeuille en cas d&#39;événement tel qu&#39;un appareil mobile perdu, un bogue logiciel ou une corruption de la mémoire.</simpara>
<tip>
<simpara>Le terme correct pour ces mots de sauvegarde est &quot;phrase mnémonique&quot;. Nous évitons d&#39;utiliser le terme &quot;valeur d&#8217;amorçage&quot; pour désigner une phrase mnémotechnique, car même si son utilisation est la même, son usage initial est différent.</simpara>
</tip>
</section>
<section id="mnemonic-storage">
<title>Stocker le mnémonique en toute sécurité</title>
<simpara>Alice doit faire attention à stocker la phrase mnémonique d&#39;une manière qui équilibre la nécessité d&#39;empêcher le vol et la perte accidentelle. Si elle ne le protège pas suffisamment, son mnémonique risque de se faire voler. Si elle le protège trop, son mnémonique risque d&#39;être définitivement perdu. La méthode recommandée pour équilibrer correctement ces risques est d&#39;écrire deux copies de la phrase mnémonique sur papier, avec chacun des mots numérotés selon l&#39;ordre.</simpara>
<simpara>Une fois qu&#39;Alice a enregistré la phrase mnémotechnique, elle doit prévoir de stocker chaque copie dans un endroit sécurisé séparé, tel qu&#39;un tiroir de bureau verrouillé ou un coffre-fort ignifuge.</simpara>
<warning>
<simpara>N&#39;essayez jamais un système de sécurité &quot;bricolage&quot; qui s&#39;écarte de quelque manière que ce soit de la recommandation des meilleures pratiques dans &lt;&lt;mnemonic-storage&gt; &gt;. Ne coupez pas votre mnémonique en deux, ne faites pas de captures d&#39;écran, ne stockez pas sur des clés USB, des e-mails ou des lecteurs cloud, ne le cryptez pas ou n&#39;essayez aucune autre méthode non standard. Vous ferez pencher la balance de manière à risquer une perte permanente ou un vol. De nombreuses personnes ont perdu de l&#39;argent, non pas à cause d&#39;un vol, mais parce qu&#39;elles ont essayé une solution non standard sans avoir l&#39;expertise pour équilibrer les risques encourus. La recommandation des meilleures pratiques est soigneusement équilibrée par des experts et adaptée à la grande majorité des utilisateurs.</simpara>
</warning>
<figure id="bluewallet-welcome"><title>Alice utilise l&#39;écran de réception sur son portefeuille Bitcoin mobile Bluewallet et affiche son adresse à Bob au format de code QR</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0101.png"/>
  </imageobject>
  <textobject><phrase>BluewalletWelcome</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;codes QR&quot;</primary><secondary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>see=&quot;aussi clés et adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi clés et adresses&quot;</primary>
</indexterm> La vue principale du portefeuille affiche le montant en bitcoins, l&#39;historique des transactions et les boutons <emphasis>Receive</emphasis> et <emphasis>Send</emphasis>. En outre, de nombreux portefeuilles offrent la possibilité d&#39;acheter des Bitcoins directement via un échange ou un service similaire où vous pouvez offrir de l&#39;argent fiduciaire en échange de cryptomonnaie, ce qui est fait par <xref linkend="bitcoin_price"/> et vendre à l&#39;utilisateur du portefeuille à ce prix ou au-dessus. Le bouton <emphasis>Buy Bitcoin</emphasis> permettrait à Alice d&#39;acheter des Bitcoins de cette manière.</simpara>
<simpara>Alice est maintenant prête à commencer à utiliser son nouveau portefeuille Bitcoin. <indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;GSquick01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;GSquick01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Wquick01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Wquick01&quot;</primary>
</indexterm> Son application de portefeuille a généré aléatoirement une clé privée (décrite plus en détail dans <xref linkend="private_keys"/>) qui sera utilisé pour dériver des adresses Bitcoin qui dirigent vers son portefeuille. À ce stade, ses adresses Bitcoin ne sont pas connues du réseau Bitcoin ou &quot;enregistrées&quot; auprès d&#39;une quelconque partie du système Bitcoin. Ses adresses Bitcoin sont simplement des nombres aléatoires qui correspondent à sa clé privée qu&#39;elle peut utiliser pour contrôler l&#39;accès aux fonds. Les adresses sont générées indépendamment par son portefeuille sans référence ni inscription à aucun service. En fait, dans la plupart des portefeuilles, il n&#39;y a aucune association entre une adresse Bitcoin et toute information d&#39;identification externe, y compris l&#39;identité de l&#39;utilisateur. Jusqu&#39;au moment où une adresse est référencée comme destinataire de la valeur dans une transaction publiée sur le grand livre bitcoin, l&#39;adresse Bitcoin fait simplement partie du grand nombre d&#39;adresses possibles valides en bitcoin. Ce n&#39;est qu&#39;une fois qu&#39;une adresse a été associée à une transaction qu&#39;elle fait partie des adresses connues du réseau.</simpara>
<simpara>Alice utilise le bouton <emphasis>Receive</emphasis>, qui affiche un code QR avec une adresse Bitcoin. Le code QR est le carré avec un motif de points noirs et blancs, servant de forme de code-barres contenant les mêmes informations dans un format pouvant être scanné par l&#39;appareil photo du smartphone de Joe. À côté du code QR du portefeuille se trouve l&#39;adresse Bitcoin qu&#39;il encode, et Alice peut choisir d&#39;envoyer manuellement son adresse à Joe en la copiant dans son presse-papiers d&#39;un simple toucher. Il convient de noter que lorsque vous recevez des fonds sur un nouveau portefeuille mobile pour la première fois, de nombreux portefeuilles revérifieront souvent que vous avez bien sécurisé votre phrase mnémonique. Cela peut aller d&#39;une simple invitation à demander à l&#39;utilisateur de ressaisir manuellement la phrase.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>&quot;sécurité de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sécurité de&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sécurité&quot;</primary><secondary>&quot;adresses Bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;adresses Bitcoin&quot;</primary>
</indexterm>Les adresses Bitcoin commencent par 1, 3 ou bc1. Comme les adresses e-mail, elles peuvent être partagées avec d&#39;autres utilisateurs de bitcoins qui peuvent les utiliser pour envoyer des bitcoins directement dans votre portefeuille. Il n&#39;y a rien de sensible, du point de vue de la sécurité, à propos de l&#39;adresse Bitcoin. Il peut être affiché n&#39;importe où sans risquer la sécurité du compte. Contrairement aux adresses e-mail, vous pouvez créer de nouvelles adresses aussi souvent que vous le souhaitez, qui dirigeront toutes les fonds vers votre portefeuille. En fait, de nombreux portefeuilles modernes créent automatiquement une nouvelle adresse pour chaque transaction afin de maximiser la confidentialité. Un portefeuille est simplement une collection d&#39;adresses et les clés qui débloquent les fonds à l&#39;intérieur.</simpara>
</tip>
</section>
<section id="getting_first_bitcoin">
<title>Obtenir son premier Bitcoin</title>
<simpara>Il existe plusieurs façons pour Alice d&#39;acquérir des bitcoins :</simpara>
<itemizedlist>
<listitem>
<simpara>
Elle peut échanger une partie de sa monnaie nationale (par exemple USD) à un échange de crypto-monnaie
</simpara>
</listitem>
<listitem>
<simpara>
Elle peut en acheter à un ami ou à une connaissance d&#39;un Meetup Bitcoin, en échange d&#39;argent
</simpara>
</listitem>
<listitem>
<simpara>
Elle peut trouver un <emphasis>guichet Bitcoin</emphasis> dans sa région, qui agit comme un distributeur automatique, vendant des bitcoins contre de l&#39;argent
</simpara>
</listitem>
<listitem>
<simpara>
Elle peut offrir ses compétences ou un produit qu&#39;elle vend et accepte le paiement en bitcoin
</simpara>
</listitem>
<listitem>
<simpara>
Elle peut demander à son employeur ou à ses clients de la payer en bitcoin
</simpara>
</listitem>
</itemizedlist>
<simpara>Toutes ces méthodes présentent des degrés de difficulté variables et nombre d&#39;entre elles impliquent le paiement de frais. Certaines institutions financières exigeront également qu&#39;Alice fournisse des documents d&#39;identification pour se conformer aux réglementations bancaires locales/aux pratiques de lutte contre le blanchiment d&#39;argent (AML), un processus connu sous le nom de Know Your Customer (KYC). Cependant, avec toutes ces méthodes, Alice pourra recevoir des bitcoins.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;confidentialité</primary><secondary>maintien&quot;</secondary>
</indexterm>
<indexterm>
  <primary>maintien&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sécurité&quot;</primary><secondary>&quot;maintien de la vie privée&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;maintien de la vie privée&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;monnaies numériques&quot;</primary><secondary>&quot;échanges de devises&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;échanges de devises&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;échanges de devises&quot;</primary>
</indexterm> <indexterm>
  <primary>&quot;monnaies numériques&quot;</primary><secondary>&quot;avantages du bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avantages du bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;bitcoin&quot;</primary><secondary>&quot;avantages de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avantages de&quot;</primary>
</indexterm>L&#39;un des avantages du bitcoin par rapport aux autres systèmes de paiement est que, lorsqu&#39;il est utilisé correctement, il offre aux utilisateurs beaucoup plus d&#39;intimité. Acquérir, détenir et dépenser des bitcoins ne vous oblige pas à divulguer des informations sensibles et personnellement identifiables à des tiers. Cependant, lorsque le bitcoin touche les systèmes traditionnels, tels que les échanges de devises, les réglementations nationales et internationales s&#39;appliquent souvent. Afin d&#39;échanger des bitcoins contre votre monnaie nationale, il vous sera souvent demandé de fournir une preuve d&#39;identité et des informations bancaires. Les utilisateurs doivent savoir qu&#39;une fois qu&#39;une adresse Bitcoin est associée à une identité, toutes les transactions Bitcoin associées sont également faciles à identifier et à suivre. C&#39;est l&#39;une des raisons pour lesquelles de nombreux utilisateurs choisissent de maintenir des comptes d&#39;échange dédiés non liés à leurs portefeuilles.</simpara>
</tip>
<simpara>Alice a été initiée au bitcoin par un ami, elle a donc un moyen facile d&#39;acquérir son premier bitcoin. Ensuite, nous verrons comment elle achète des bitcoins à son ami Joe et comment Joe envoie les bitcoins dans son portefeuille.</simpara>
</section>
<section id="bitcoin_price">
<title>Trouver le prix actuel du Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;commencer&quot;</primary><secondary>&quot;taux de change&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;taux de change&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;taux de change&quot;</primary><secondary>&quot;déterminer&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;déterminer&quot;</primary>
</indexterm>Avant qu&#39;Alice puisse acheter du bitcoin à Joe, ils doivent s&#39;entendre sur le <emphasis>taux de change</emphasis> entre le bitcoin et le dollar américain . Cela soulève une question courante pour ceux qui découvrent le bitcoin : &quot;Qui fixe le prix du bitcoin ?&quot; La réponse courte est que le prix est fixé par les marchés.</simpara>
<simpara><indexterm>
  <primary>&quot;taux de change&quot;</primary><secondary>&quot;flottant&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;flottant&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cours du change flottant&quot;</primary>
</indexterm>Le bitcoin, comme la plupart des autres devises, a un <emphasis>cours du change flottant</emphasis>. Cela signifie que la valeur du bitcoin vis-à-vis de toute autre devise fluctue en fonction de l&#39;offre et de la demande sur les différents marchés où il est négocié. Par exemple, le « prix » du bitcoin en dollars américains est calculé sur chaque marché en fonction de la transaction la plus récente de bitcoin et de dollars américains. En tant que tel, le prix a tendance à fluctuer minutieusement plusieurs fois par seconde. Un service de tarification regroupera les prix de plusieurs marchés et calculera une moyenne pondérée en fonction du volume représentant le taux de change général du marché d&#39;une paire de devises (par exemple, BTC/USD).</simpara>
<simpara>Il existe des centaines d&#39;applications et de sites Web qui peuvent fournir le taux actuel du marché. Voici quelques-uns des plus populaires :</simpara>
<variablelist>
<varlistentry>
<term>
<ulink url="https://bitcoinaverage.com/">Bitcoin Average</ulink> 
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;BitcoinAverage&quot;</primary>
</indexterm>Un site qui fournit une vue simple de la moyenne pondérée en fonction du volume pour chaque devise.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://coincap.io/">CoinCap</ulink> 
</term>
<listitem>
<simpara>
Un service répertoriant la capitalisation boursière et les taux de change de centaines de crypto-monnaies, dont le bitcoin.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://bit.ly/cmebrr">Chicago Mercantile Exchange Bitcoin Reference Rate</ulink> 
</term>
<listitem>
<simpara>
Un taux de référence qui peut être utilisé comme référence institutionnelle et contractuelle, fourni dans le cadre des flux de données d&#39;investissement par le CME.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>En plus de ces différents sites et applications, la plupart des portefeuilles bitcoin convertiront automatiquement les montants entre le bitcoin et d&#39;autres devises. Joe utilisera son portefeuille pour convertir automatiquement le prix avant d&#39;envoyer des bitcoins à Alice.</simpara>
</section>
<section id="sending_receiving">
<title>Envoi et réception de Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;commencer&quot;</primary><secondary>&quot;envoyer et recevoir des bitcoins&quot;</secondary><tertiary>id=&quot;GSsend01&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;envoyer et recevoir des bitcoins&quot;</primary><secondary>id=&quot;GSsend01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;GSsend01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;dépenser des bitcoins&quot;</primary><secondary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;dépenser des bitcoins&quot;</primary><secondary>see=&quot;également des transactions&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;également des transactions&quot;</primary>
</indexterm>Alice a décidé d&#39;échanger 10 dollars américains contre des bitcoins, afin de ne pas risquer trop d&#39;argent sur cette nouvelle technologie. Elle donne à Joe 10 $ en espèces, ouvre son application de portefeuille mobile Bluewallet et sélectionne Recevoir. Cela affiche un code QR avec la première adresse Bitcoin d&#39;Alice.</simpara>
<simpara>Joe sélectionne ensuite <emphasis>Envoyer</emphasis> sur son portefeuille de smartphone Bluewallet et un écran contenant les entrées suivantes s&#39;affiche :</simpara>
<itemizedlist>
<listitem>
<simpara>
Le montant à envoyer, en bitcoin (BTC) ou sa devise locale (USD)
</simpara>
</listitem>
<listitem>
<simpara>
Une adresse Bitcoin de destination
</simpara>
</listitem>
<listitem>
<simpara>
Une note de transaction (description)
</simpara>
</listitem>
<listitem>
<simpara>
Des frais de transaction
</simpara>
</listitem>
</itemizedlist>
<simpara>Dans le champ de saisie de l&#39;adresse Bitcoin, il y a un petit bouton <emphasis>Scan</emphasis>. Cela permet à Joe de scanner le code QR avec l&#39;appareil photo de son smartphone afin de ne pas avoir à taper l&#39;adresse Bitcoin d&#39;Alice, qui est assez longue et difficile à taper. Joe appuie sur le bouton <emphasis>Scan</emphasis> et il active la caméra du smartphone, scannant le code QR affiché sur le smartphone d&#39;Alice.</simpara>
<simpara>Joe a maintenant l&#39;adresse Bitcoin d&#39;Alice définie comme destinataire. Joe saisit le montant de 10 dollars américains et son portefeuille le convertit en accédant au taux de change le plus récent à partir d&#39;un service en ligne. Le taux de change à l&#39;époque est de 100 dollars américains par bitcoin, donc 10 dollars américains valent 0,10 bitcoin (BTC) ou 100 millibitcoin (mBTC) comme le montre la capture d&#39;écran du portefeuille de Joe (voir <xref linkend="bluewallet-mobile-send"/>).</simpara>
<simpara>Dans la saisie de la note/description de la transaction, Joe saisit « Alice ». Il peut utiliser ce champ pour ajouter des informations concernant sa transaction pour référence future. Cette fonction est pour sa tenue de dossiers uniquement. La note de transaction sera stockée dans son portefeuille et seul Joe pourra la voir. Il ne sera pas envoyé à Alice, ni stocké sur la blockchain.</simpara>
<simpara>Il sélectionne également des frais de transaction pour sa transaction. Plus les frais de transaction sont élevés, plus vite sa transaction sera confirmée (incluse dans un bloc par un mineur). Il sélectionne les frais de transaction minimum possibles à ce moment-là (0 satoshis/octet).</simpara>
<tip>
<simpara>Le prix du bitcoin a beaucoup changé au fil du temps, et une quantité incroyable depuis la rédaction de la première édition de ce livre. En mars 2021, une personne aurait besoin d&#39;environ 54 000 USD pour acheter un bitcoin entier. De nombreux exemples dans ce livre font référence à des transactions passées réelles, lorsque le prix du bitcoin était beaucoup plus bas et que des transactions sans frais étaient encore possibles. Pensez à quel point Joe aurait été un ami généreux s&#39;il avait conclu le même accord avec Alice aujourd&#39;hui !</simpara>
</tip>
<figure id="bluewallet-mobile-send"><title>Écran d&#39;envoi du portefeuille bitcoin mobile Bluewallet</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0102.png"/>
  </imageobject>
  <textobject><phrase>bluewallet mobile send screen</phrase></textobject>
</mediaobject>
</figure>
<simpara>À l&#39;aide de Bluewallet, Joe vérifie soigneusement qu&#39;il a saisi le bon montant, car il est sur le point de transmettre de l&#39;argent et les erreurs sont irréversibles. Par souci de simplicité, nous supposerons que Joe ne paie aucun frais de transaction. L&#39;objet et la fixation des frais de transaction sont traités dans les chapitres suivants. Après avoir revérifié l&#39;adresse et le montant, il appuie sur <emphasis>Envoyer</emphasis> pour transmettre la transaction. Le portefeuille bitcoin mobile de Joe construit une transaction qui attribue 0,10 BTC à l&#39;adresse fournie par Alice, puise les fonds dans le portefeuille de Joe et signe la transaction avec les clés privées de Joe. Cela indique au réseau Bitcoin que Joe a autorisé un transfert de valeur vers la nouvelle adresse d&#39;Alice. Comme la transaction est transmise via le protocole pair à pair, elle se propage rapidement sur le réseau Bitcoin. En moins d&#39;une seconde, la plupart des nœuds bien connectés du réseau reçoivent la transaction et voient l&#39;adresse d&#39;Alice pour la première fois.</simpara>
<simpara>Pendant ce temps, le portefeuille d&#39;Alice &quot;écoute&quot; constamment les transactions publiées sur le réseau Bitcoin, à la recherche de celles qui correspondent aux adresses qu&#39;il contient. Quelques secondes après que le portefeuille de Joe ait transmis la transaction, le portefeuille d&#39;Alice indiquera qu&#39;il reçoit 0,10 BTC.</simpara>
<tip>
<simpara>Chaque bitcoin peut être subdivisé en 100 millions d&#39;unités, chacune appelée &quot;satoshi&quot; (singulier) ou &quot;satoshis&quot; (pluriel). Nommé en l&#39;honneur du créateur du bitcoin, le Satoshi est la plus petite unité de bitcoin, équivalente à 0,00000001 BTC.</simpara>
</tip>
<formalpara id="confirmations"><title>Confirmations</title><para><indexterm>
  <primary>&quot;comment démarrer&quot;</primary><secondary>&quot;confirmations&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;confirmations&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;confirmations&quot;</primary><secondary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exemple de démarrage rapide du portefeuille bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;confirmations&quot;</primary><secondary>voir=&quot;aussi minage et consensus; transactions&quot;</secondary>
</indexterm>
<indexterm>
  <primary>voir=&quot;aussi minage et consensus; transactions&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;liquidation&quot;</primary><secondary>seealso=&quot;confirmations&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;confirmations&quot;</primary>
</indexterm>Au début, le portefeuille d&#39;Alice affichera la transaction de Joe comme &quot;Non confirmée&quot;. Cela signifie que la transaction a été propagée au réseau mais n&#39;a pas encore été enregistrée dans le registre des transactions bitcoin, connu sous le nom de blockchain ou la chaîne de blocs. Pour être confirmée, une transaction doit être incluse dans un bloc et ajoutée à la chaîne de blocs, ce qui se produit toutes les 10 minutes en moyenne. En termes financiers traditionnels, cela s&#39;appelle <emphasis>liquidation (ou clearing)</emphasis>. Ce livre couvrira en détail la propagation, la validation et la liquidation (ou la confirmation) des transactions bitcoin.</para></formalpara>
<simpara>Alice est maintenant l&#39;heureuse propriétaire de 0,10 BTC qu&#39;elle peut dépenser. Dans le chapitre suivant, nous examinerons son premier achat avec Bitcoin et examinerons plus en détail les technologies sous-jacentes de transaction et de propagation.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;BCbasic01&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;BCbasic01&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;use cases&quot;</primary><secondary>&quot;buying café&quot;</secondary><tertiary>startref=&quot;aliceone&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;buying café&quot;</primary><secondary>startref=&quot;aliceone&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;aliceone&quot;</primary>
</indexterm></simpara>
</section>
</section>
</section>
<section id="ch02_bitcoin_overview">
<title>Comment fonctionne Bitcoin</title>
<section id="_transactions_blocs_minage_et_la_chaîne_de_blocs">
<title>Transactions, blocs, minage et la chaîne de blocs</title>
<simpara><indexterm>
  <primary>&quot;bitcoin&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>id=&quot;BCover02&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>id=&quot;BCover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCover02&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;autorité centrale de confiance&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;systèmes décentralisés&quot;</primary><secondary>&quot;aperçu de bitcoin&quot;</secondary><tertiary>id=&quot;DCSover02&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de bitcoin&quot;</primary><secondary>id=&quot;DCSover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;DCSover02&quot;</primary>
</indexterm> Le système Bitcoin, contrairement aux systèmes bancaires et de paiement traditionnels, est basé sur la confiance décentralisée. Au lieu d&#39;une autorité centrale de confiance, dans le bitcoin, la confiance est obtenue en tant que propriété émergente à partir des interactions des différents participants au système Bitcoin. Dans ce chapitre, nous examinerons le bitcoin d&#39;un niveau élevé en suivant une seule transaction via le système Bitcoin et en observant qu&#39;elle devient &quot;de confiance&quot; et acceptée par le mécanisme de consensus distribué bitcoin et est finalement enregistrée sur la chaîne de blocs, le grand livre distribué de toutes transactions. Les chapitres suivants approfondiront la technologie derrière les transactions, le réseau et l&#39;exploitation minière.</simpara>
<section id="_présentation_de_bitcoin">
<title>Présentation de Bitcoin</title>
<simpara>Dans le schéma d&#39;ensemble présenté dans <xref linkend="bitcoin-overview"/>, nous voyons que le système Bitcoin se compose d&#39;utilisateurs avec des portefeuilles contenant des clés, des transactions qui se propagent à travers le réseau et des mineurs qui produisent (par le calcul concurrentiel) le consensus de la chaîne de blocs, qui est le registre faisant autorité de toutes les transactions.</simpara>
<simpara><indexterm>
  <primary>&quot;site explorateur de chaîne de blocs&quot;</primary>
</indexterm>Chaque exemple de ce chapitre est basé sur une transaction réelle effectuée sur le réseau Bitcoin, simulant les interactions entre les utilisateurs (Joe, Alice, Bob et Gopesh) en envoyant des fonds à partir d&#39;un portefeuille à un autre. Lors du suivi d&#39;une transaction via le réseau Bitcoin jusqu&#39;à la chaîne de blocs, nous utiliserons un site <emphasis>explorateur de chaîne de blocs</emphasis> pour visualiser chaque étape. Un explorateur de chaîne de blocs est une application Web qui fonctionne comme un moteur de recherche bitcoin, en ce sens qu&#39;il vous permet de rechercher des adresses, des transactions et des blocs et de voir les relations et les flux entre eux.</simpara>
<figure id="bitcoin-overview"><title>Présentation de Bitcoin</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0201.png"/>
  </imageobject>
  <textobject><phrase>Bitcoin Overview</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
  <primary>&quot;exporateur de block bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;BlockCypher Explorer&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Blockchain.com&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;BitPay Insight&quot;</primary>
</indexterm>Les explorateurs de blockchain populaires incluent :</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://live.blockcypher.com">Explorateur BlockCypher</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://blockchain.com">Blockchain.com</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://insight.bitpay.com">BitPay Insight</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://blockstream.info">Blockstream Explorer</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>Chacun d&#39;eux a une fonction de recherche qui peut prendre une adresse Bitcoin, un hachage de transaction, un numéro de bloc ou un hachage de bloc et récupérer les informations correspondantes du réseau Bitcoin. Avec chaque exemple de transaction ou de bloc, nous fournirons une URL afin que vous puissiez la rechercher vous-même et l&#39;étudier en détail.</simpara>
</section>
<section id="cup_of_coffee">
<title>Acheter une tasse de café</title>
<simpara><indexterm>
  <primary>&quot;cas d&#8217;usages&quot;</primary><secondary>&quot;acheter un café&quot;</secondary><tertiary>id=&quot;UCcoffee02&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;acheter un café&quot;</primary><secondary>id=&quot;UCcoffee02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;UCcoffee02&quot;</primary>
</indexterm>Alice, présentée dans le chapitre précédent, est une nouvelle utilisatrice qui vient d&#39;acquérir son premier bitcoin. Dans <xref linkend="getting_first_bitcoin"/>, Alice a rencontré son ami Joe pour échanger de l&#39;argent contre du bitcoin. La transaction créée par Joe a financé le portefeuille d&#39;Alice avec 0,10 BTC. Alice va maintenant faire sa première transaction de vente au détail en achetant une tasse de café au café de Bob à Palo Alto, en Californie.</simpara>
<simpara><indexterm>
  <primary>&quot;taux de change&quot;</primary><secondary>&quot;déterminant&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;déterminant&quot;</primary>
</indexterm>Bob&#39;s Cafe a récemment commencé à accepter les paiements en bitcoin en ajoutant une option bitcoin à son système de point de vente. Les prix au Bob&#39;s Cafe sont indiqués dans la devise locale (dollars américains), mais à la caisse, les clients ont la possibilité de payer en dollars ou en bitcoins. Alice passe sa commande pour une tasse de café et Bob l&#39;inscrit dans le registre, comme il le fait pour toutes les transactions. Le système de point de vente convertit automatiquement le prix total des dollars américains en bitcoins au taux du marché en vigueur et affiche le prix dans les deux devises :</simpara>
<screen>Total:
1,50 USD
0,015 BTC</screen>
<simpara><indexterm>
  <primary>&quot;millibits&quot;</primary>
</indexterm> Bob dit : &quot;C&#39;est un dollar cinquante, ou quinze millibits.&quot;</simpara>
<simpara><indexterm>
  <primary>&quot;demandes de paiement&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;codes QR&quot;</primary><secondary>&quot;demandes de paiement&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;demandes de paiement&quot;</primary>
</indexterm>Le système de point de vente de Bob créera également automatiquement un code QR spécial contenant une <emphasis>demande de paiement</emphasis> (voir <xref linkend="payment-request-QR"/>).</simpara>
<simpara>Contrairement à un code QR qui contient simplement une adresse Bitcoin de destination, une demande de paiement est une URL encodée QR qui contient une adresse de destination, un montant de paiement et une description générique telle que &quot;Bob&#39;s Cafe&quot;. Cela permet à une application de portefeuille bitcoin de pré-remplir les informations utilisées pour envoyer le paiement tout en affichant une description lisible par l&#39;utilisateur à l&#39;utilisateur. Vous pouvez scanner le code QR avec une application de portefeuille bitcoin pour voir ce qu&#39;Alice verrait.</simpara>
<figure id="payment-request-QR"><title>Code QR de la demande de paiement</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0202.png"/>
  </imageobject>
  <textobject><phrase>payment-request</phrase></textobject>
</mediaobject>
</figure>
<tip>
<simpara><indexterm>
  <primary>&quot;Codes QR&quot;</primary><secondary>&quot;avertissements et mises en garde&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avertissements et mises en garde&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;éviter d&#39;envoyer de l&#39;argent aux adresses figurant dans le livre&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;éviter d&#39;envoyer de l&#39;argent aux adresses figurant dans le livre&quot;</primary>
</indexterm> Essayez de scanner ceci avec votre portefeuille pour voir l&#39;adresse et le montant, mais N&#39;ENVOYEZ PAS D&#39;ARGENT.</simpara>
</tip>
<formalpara id="payment-request-URL"><title>Le QR code de demande de paiement encode l&#39;URL suivante, définie dans BIP-21 :</title><para>
<screen>bitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA?
amount=0.015&amp;
label=Bob%27s%20Cafe&amp;
message=Acheter%20chez%20Bob%27s%20Café

Composants de l&amp;#39;URL

Une adresse Bitcoin : &amp;quot;1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA&amp;quot;
Le montant du paiement: &amp;quot;0,015&amp;quot;
Une étiquette pour l&amp;#39;adresse du destinataire : « Bob&amp;#39;s Cafe »
Une description du paiement : &amp;quot;Acheter au Bob&amp;#39;s Cafe&amp;quot;</screen>
</para></formalpara>
<simpara>Alice utilise son smartphone pour scanner le code-barres affiché. Son smartphone affiche un paiement de <literal>0,0150 BTC</literal> à <literal>Bob&#39;s Cafe</literal> et elle sélectionne Envoyer pour autoriser le paiement. En quelques secondes (environ le même temps qu&#39;une autorisation de carte de crédit), Bob voit la transaction sur le registre, complétant la transaction.</simpara>
<simpara>Dans les sections suivantes, nous examinerons cette transaction plus en détail. Nous verrons comment le portefeuille d&#39;Alice l&#39;a construit, comment il s&#39;est propagé sur le réseau, comment il a été vérifié et enfin, comment Bob peut dépenser ce montant lors de transactions ultérieures.</simpara>
<note>
<simpara><indexterm>
  <primary>&quot;valeurs fractionnaires&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;milli-bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;satoshis&quot;</primary>
</indexterm>Le réseau Bitcoin peut effectuer des transactions en valeurs fractionnaires, par exemple à partir de millibitcoin (1/1000e de bitcoin ) jusqu&#39;à 1/100 000 000e de bitcoin, connu sous le nom de satoshi. Tout au long de ce livre, nous utiliserons le terme &quot;bitcoin&quot; pour désigner toute quantité de monnaie bitcoin, de la plus petite unité (1 satoshi) au nombre total (21 000 000) de tous les bitcoins qui seront extraits.</simpara>
</note>
<simpara>Vous pouvez examiner la transaction d&#39;Alice avec Bob&#39;s Cafe sur la blockchain en utilisant un site d&#39;exploration de blocs (<xref linkend="view_alice_transaction"/>):</simpara>
<example id="view_alice_transaction">
<title>Voir la transaction d&#39;Alice sur <ulink url="https://www.blockchain.com/btc/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2">blockchain.com</ulink></title>
<screen>https://www.blockchain.com/btc/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2</screen>
</example>
</section>
</section>
<section id="_transactions_en_bitcoins">
<title>Transactions en bitcoins</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm>En termes simples, une transaction indique au réseau que le propriétaire d&#39;une valeur bitcoin a autorisé le transfert de cette valeur à un autre propriétaire. Le nouveau propriétaire peut désormais dépenser le bitcoin en créant une autre transaction qui autorise le transfert à un autre propriétaire, et ainsi de suite, dans une chaîne de propriété.</simpara>
<section id="_entrées_et_sorties_de_transactions">
<title>Entrées et sorties de transactions</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;vue générale de&quot;</secondary><tertiary>id=&quot;Tover02&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;vue générale de&quot;</primary><secondary>id=&quot;Tover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Tover02&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;les bases de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;les bases de&quot;</primary>
</indexterm>Les transactions sont comme des lignes dans un livre comptable en partie double. Chaque transaction contient une ou plusieurs &quot;entrées&quot;, qui sont comme des débits sur un compte bitcoin. De l&#39;autre côté de la transaction, il y a une ou plusieurs &quot;sorties&quot;, qui sont comme des crédits ajoutés à un compte bitcoin. <indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;frais de transaction&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;frais de transaction&quot;</primary>
</indexterm>Les entrées et les sorties (débits et crédits) ne totalisent pas nécessairement le même montant. Au lieu de cela, les sorties s&#39;additionnent légèrement moins que les entrées et la différence représente des <emphasis>frais de transaction</emphasis> implicites, qui sont un petit paiement perçu par le mineur qui inclut la transaction dans le grand livre. Une transaction bitcoin s&#39;affiche sous la forme d&#39;une écriture comptable dans <xref linkend="transaction-double-entry"/>.</simpara>
<simpara>La transaction contient également une preuve de propriété pour chaque montant de bitcoin (entrées) dont la valeur est dépensée, sous la forme d&#39;une signature numérique du propriétaire, qui peut être validée indépendamment par n&#39;importe qui. <indexterm>
  <primary>&quot;dépenser le bitcoin&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm>En termes de bitcoin, &quot;dépenser&quot; consiste à signer une transaction qui transfère la valeur d&#39;une transaction précédente à un nouveau propriétaire identifié par une adresse Bitcoin.</simpara>
<figure id="transaction-double-entry"><title>Transaction comptable en double parties</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0203.png"/>
  </imageobject>
  <textobject><phrase>&quot;Transaction en double saisie&quot;</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_chaînes_de_transaction">
<title>Chaînes de transaction</title>
<simpara><indexterm>
  <primary>&quot;chaîne de transactions&quot;</primary>
</indexterm>Le paiement d&#39;Alice à Bob&#39;s Cafe utilise la sortie d&#39;une transaction précédente comme entrée. Dans le chapitre précédent, Alice a reçu des bitcoins de son ami Joe en échange d&#39;argent. Cette transaction a créé une valeur bitcoin verrouillée par la clé d&#39;Alice. Sa nouvelle transaction avec Bob&#39;s Cafe fait référence à la transaction précédente comme entrée et crée de nouvelles sorties pour payer la tasse de café et recevoir la monnaie. Les transactions forment une chaîne, où les entrées de la dernière transaction correspondent aux sorties des transactions précédentes. La clé d&#39;Alice fournit la signature qui déverrouille ces sorties de transaction précédentes, prouvant ainsi au réseau Bitcoin qu&#39;elle possède les fonds. Elle joint le paiement du café à l&#39;adresse de Bob, &quot;encombrant&quot; ainsi cette sortie avec l&#39;exigence que Bob produise une signature afin de dépenser ce montant. Cela représente un transfert de valeur entre Alice et Bob. Cette chaîne de transactions, de Joe à Alice à Bob, est illustrée dans <xref linkend="blockchain-mnemonic"/>.</simpara>
<figure id="blockchain-mnemonic"><title>Une chaîne de transactions, où la sortie d&#39;une transaction est l&#39;entrée de la transaction suivante</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0204.png"/>
  </imageobject>
  <textobject><phrase>Transaction chain</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_faire_du_change_ou_de_la_petite_monnaie">
<title>Faire du change (ou de la petite monnaie)</title>
<simpara><indexterm>
  <primary>&quot;change</primary><secondary>faire&quot;</secondary>
</indexterm>
<indexterm>
  <primary>faire&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;changer d&#39;adresses&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>&quot;changer d&#39;adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;changer d&#39;adresses&quot;</primary>
</indexterm>De nombreuses transactions bitcoin incluront des sorties qui référencent à la fois une adresse du nouveau propriétaire et une adresse du propriétaire actuel, appelée <emphasis>adresse de change</emphasis>. En effet, les entrées de transaction, comme les billets de banque, ne peuvent pas être divisées. Si vous achetez un article de 5 dollars américains dans un magasin mais que vous utilisez un billet de 20 dollars américains pour payer l&#39;article, vous vous attendez à recevoir 15 dollars américains en monnaie. Le même concept s&#39;applique aux entrées de transaction bitcoin. Si vous avez acheté un article qui coûte 5 bitcoins mais que vous n&#39;aviez qu&#39;une entrée de 20 bitcoins à utiliser, votre portefeuille créerait une seule transaction qui enverrait deux sorties, une sortie de 5 bitcoins au propriétaire du magasin et une sortie de 15 bitcoins à vous-même comme changement (moins les frais de transaction applicables). Il est important de noter que l&#39;adresse de change ne doit pas nécessairement être la même que celle de l&#39;entrée et, pour des raisons de confidentialité, il s&#39;agit souvent d&#39;une nouvelle adresse du portefeuille du propriétaire.</simpara>
<simpara>Différents portefeuilles peuvent utiliser différentes stratégies lors de l&#39;agrégation des entrées pour effectuer un paiement demandé par l&#39;utilisateur. Ils peuvent regrouper de nombreux petits intrants ou en utiliser un égal ou supérieur au paiement souhaité. À moins que le portefeuille ne puisse agréger les entrées de manière à correspondre exactement au paiement souhaité plus les frais de transaction, le portefeuille devra générer du change. C&#39;est très similaire à la façon dont les gens gèrent l&#39;argent liquide. Si vous utilisez toujours le plus gros billet dans votre poche, vous vous retrouverez avec une poche pleine de monnaie. Si vous n&#39;utilisez que la petite monnaie, vous n&#39;aurez toujours que de gros billets. Les gens trouvent inconsciemment un équilibre entre ces deux extrêmes, et les développeurs de portefeuilles Bitcoin s&#39;efforcent de programmer cet équilibre.</simpara>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;entrées&quot;</primary><secondary>voir=&quot;sorties et entrées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>voir=&quot;sorties et entrées&quot;</primary>
</indexterm>En résumé, les <emphasis>transactions</emphasis> déplacent des valeurs des <emphasis>entrées de transaction</emphasis> aux <emphasis>sorties de transaction</emphasis>. Une entrée est une référence à la sortie d&#39;une transaction précédente, indiquant d&#39;où provient la valeur. Une transaction comprend généralement une sortie qui dirige une valeur spécifique vers l&#39;adresse Bitcoin d&#39;un nouveau propriétaire et une sortie de modification vers le propriétaire d&#39;origine. Les sorties d&#39;une transaction peuvent être utilisées comme entrées dans une nouvelle transaction, créant ainsi une chaîne de propriété lorsque la valeur est déplacée d&#39;un propriétaire à l&#39;autre (voir <xref linkend="blockchain-mnemonic"/>).</simpara>
</section>
<section id="_formulaires_de_transaction_communs">
<title>Formulaires de transaction communs</title>
<simpara>La forme de transaction la plus courante est un simple paiement d&#39;une adresse à une autre, qui comprend souvent une « monnaie » rendue au propriétaire d&#39;origine. Ce type de transaction a une entrée et deux sorties et est affiché dans <xref linkend="transaction-common"/>.</simpara>
<figure id="transaction-common"><title>Transaction la plus courante</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0205.png"/>
  </imageobject>
  <textobject><phrase>&quot;Transaction commune&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara>Une autre forme courante de transaction est celle qui agrège plusieurs entrées en une seule sortie (voir &lt;&lt;transaction-aggregating&gt; &gt;). Cela représente l&#39;équivalent réel de l&#39;échange d&#39;une pile de pièces et de billets de banque contre un seul billet plus gros. Des transactions comme celles-ci sont parfois générées par des applications de portefeuille pour nettoyer de nombreux petits montants reçus en monnaie de paiement.</simpara>
<figure id="transaction-aggregating"><title>Transaction agrégeant des fonds</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0206.png"/>
  </imageobject>
  <textobject><phrase>Aggregating Transaction</phrase></textobject>
</mediaobject>
</figure>
<simpara>Enfin, une autre forme de transaction que l&#39;on voit souvent sur le grand livre bitcoin est une transaction par lots, qui distribue une entrée à plusieurs sorties représentant plusieurs destinataires, une technique appelée &quot;transactions par lot&quot; (voir <xref linkend="transaction-distributing"/>). Étant donné que ce type de transaction est utile pour économiser sur les frais de transaction, il est couramment utilisé par les entités commerciales pour distribuer des fonds, par exemple lorsqu&#39;une entreprise traite les paiements de paie à plusieurs employés ou lorsqu&#39;un échange de bitcoins traite les retraits de plusieurs clients en un seul. transaction.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Tover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Tover02&quot;</primary>
</indexterm></simpara>
<figure id="transaction-distributing"><title>Transaction distribuant des fonds</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0207.png"/>
  </imageobject>
  <textobject><phrase>Distributing Transaction</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="_construction_d_39_une_transaction">
<title>Construction d&#39;une transaction</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;construire&quot;</secondary><tertiary>id=&quot;Tconstruct02&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;construire&quot;</primary><secondary>id=&quot;Tconstruct02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Tconstruct02&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;construire des transactions&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;construire des transactions&quot;</primary>
</indexterm>L&#39;application de portefeuille d&#39;Alice contient toute la logique pour sélectionner les entrées et les sorties appropriées pour construire une transaction à la spécification d&#39;Alice. Alice n&#39;a qu&#39;à spécifier une destination et un montant, et le reste se passe dans l&#39;application portefeuille sans qu&#39;elle ne voie les détails. Il est important de noter qu&#39;une application de portefeuille peut créer des transactions même si elle est complètement hors ligne. Comme écrire un chèque à la maison et l&#39;envoyer plus tard à la banque dans une enveloppe, la transaction n&#39;a pas besoin d&#39;être construite et signée tout en étant connectée au réseau Bitcoin.</simpara>
<section id="_obtenir_les_bonnes_entrées">
<title>Obtenir les bonnes entrées</title>
<simpara><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;localisation et suivi des entrées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;localisation et suivi des entrées&quot;</primary>
</indexterm>L&#39;application de portefeuille d&#39;Alice devra d&#39;abord trouver des entrées qui peuvent payer le montant qu&#39;elle veut envoyer à Bob. La plupart des portefeuilles gardent une trace de toutes les sorties disponibles appartenant aux adresses du portefeuille. Par conséquent, le portefeuille d&#39;Alice contiendrait une copie de la sortie de transaction de la transaction de Joe, qui a été créée en échange d&#39;argent (voir <xref linkend="getting_first_bitcoin"/>). Une application de portefeuille bitcoin qui s&#39;exécute en tant que client à nœud complet contient en fait une copie de chaque sortie non dépensée de chaque transaction dans la chaîne de blocs. Cela permet à un portefeuille de construire des entrées de transaction ainsi que de vérifier rapidement les transactions entrantes comme ayant des entrées correctes. Cependant, comme un client à nœud complet occupe beaucoup d&#39;espace disque, la plupart des portefeuilles d&#39;utilisateurs exécutent des clients &quot;légers&quot; qui ne suivent que les sorties non dépensées de l&#39;utilisateur.</simpara>
<simpara>Si l&#39;application de portefeuille ne conserve pas une copie des sorties de transaction non dépensées, elle peut interroger le réseau Bitcoin pour récupérer ces informations à l&#39;aide d&#39;une variété d&#39;API disponibles par différents fournisseurs ou en demandant à un nœud complet via l&#39;aide d&#39;un appel d&#39;interface de programmation d&#39;application (API). <xref linkend="example_2-2"/> montre une requête API, construite comme une commande HTTP GET vers une URL spécifique. Cette URL renverra toutes les sorties de transaction non dépensées pour une adresse, donnant à toute application les informations dont elle a besoin pour construire des entrées de transaction pour les dépenses. Nous utilisons le simple client HTTP en ligne de commande <emphasis>cURL</emphasis> pour récupérer la réponse.</simpara>
<example id="example_2-2">
<title>Recherchez toutes les sorties non dépensées pour l&#39;adresse Bitcoin d&#39;Alice</title>
<programlisting language="bash" linenumbering="unnumbered">$ curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK</programlisting>
</example>
<programlisting language="json" linenumbering="unnumbered">{

        "unspent_outputs":[

                {
                        "tx_hash":"186f9f998a5...2836dd734d2804fe65fa35779",
                        "tx_index":104810202,
                        "tx_output_n": 0,
                        "script":"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
                        "value": 10000000,
                        "value_hex": "00989680",
                        "confirmations":0
                }

        ]
}</programlisting>
<simpara>La réponse en <xref linkend="example_2-2"/> montre une sortie non dépensée (une qui n&#39;a pas encore été échangée) sous la propriété de l&#39;adresse d&#39;Alice <literal>1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK</literal>. La réponse inclut la référence à la transaction dans laquelle cette sortie non dépensée est contenue (le paiement de Joe) et sa valeur en satoshis, à 10 millions, équivalent à 0,10 bitcoin. Avec ces informations, l&#39;application de portefeuille d&#39;Alice peut construire une transaction pour transférer cette valeur aux nouvelles adresses de propriétaire.</simpara>
<tip>
<simpara>Voir la <ulink url="https://www.blockchain.com/btc/tx/7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18">transaction de Joe à Alice</ulink>.</simpara>
</tip>
<simpara>Comme vous pouvez le voir, le portefeuille d&#39;Alice contient suffisamment de bitcoins en une seule sortie non dépensée pour payer la tasse de café. Si cela n&#39;avait pas été le cas, l&#39;application de portefeuille d&#39;Alice aurait peut-être dû &quot;fouiller&quot; dans une pile de petites sorties non dépensées, comme prendre des pièces dans un sac à main jusqu&#39;à ce qu&#39;elle puisse en trouver assez pour payer le café. Dans les deux cas, il peut être nécessaire de récupérer de la monnaie, ce que nous verrons dans la section suivante, car l&#39;application de portefeuille crée les sorties de transaction (paiements).</simpara>
</section>
<section id="_création_des_sorties">
<title>Création des sorties</title>
<simpara><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;création de sorties&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;création de sorties&quot;</primary>
</indexterm>Une sortie de transaction est créée sous la forme d&#39;un script qui crée une charge sur la valeur et ne peut être rachetée que par l&#39;introduction d&#39;une solution au script. En termes plus simples, la sortie de transaction d&#39;Alice contiendra un script qui dit quelque chose comme &quot;Cette sortie est payable à quiconque peut présenter une signature à partir de la clé correspondant à l&#39;adresse de Bob.&quot; Étant donné que seul Bob possède le portefeuille avec les clés correspondant à cette adresse, seul le portefeuille de Bob peut présenter une telle signature pour racheter cette sortie. Alice « encombrera » donc la valeur de sortie avec une demande de signature de Bob.</simpara>
<simpara>Cette transaction comprendra également une deuxième sortie, car les fonds d&#39;Alice se présentent sous la forme d&#39;une sortie à 0,10 BTC, trop d&#39;argent pour la tasse de café à 0,015 BTC. Alice aura besoin de 0,085 BTC en monnaie. Le paiement de monnaie d&#39;Alice est créé par le portefeuille d&#39;Alice en tant que sortie dans la même transaction que le paiement à Bob. Essentiellement, le portefeuille d&#39;Alice divise ses fonds en deux paiements : un à Bob et un à elle-même. Elle peut ensuite utiliser (dépenser) la sortie de monnaie dans une transaction ultérieure.</simpara>
<simpara>Enfin, pour que la transaction soit traitée par le réseau en temps opportun, l&#39;application de portefeuille d&#39;Alice ajoutera une somme modique. Ce n&#39;est pas explicite dans la transaction ; il est impliqué par la différence entre les entrées et les sorties. Si au lieu de prendre 0,085 en monnaie, Alice ne crée que 0,0845 comme deuxième sortie, il restera 0,0005 BTC (un demi-millibitcoin). Le 0,10 BTC de l&#39;entrée n&#39;est pas entièrement dépensé avec les deux sorties, car elles totaliseront moins de 0,10. La différence qui en résulte est le <emphasis>frais de transaction</emphasis> qui est perçu par le mineur en tant que frais de validation et d&#39;inclusion de la transaction dans un bloc à enregistrer sur la chaîne de blocs.</simpara>
<simpara>La transaction résultante peut être vue à l&#39;aide d&#39;une application Web d&#39;exploration de chaîne de blocs, comme indiqué dans <xref linkend="transaction-alice"/>.</simpara>
<figure id="transaction-alice"><title>Transaction d&#39;Alice au Bob&#39;s Cafe</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0208.png"/>
  </imageobject>
  <textobject><phrase>Alice Coffee Transaction</phrase></textobject>
</mediaobject>
</figure>
<tip id="transaction-alice-url">
<simpara>Voir la <ulink url="https://www.blockchain.com/btc/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2">transaction d&#39;Alice à Bob&#39;s Cafe</ulink>.</simpara>
</tip>
</section>
<section id="_ajout_de_la_transaction_au_grand_livre">
<title>Ajout de la transaction au grand livre</title>
<simpara>La transaction créée par l&#39;application du portefeuille d&#39;Alice fait 258 octets et contient tout le nécessaire pour confirmer la propriété des fonds et attribuer à de nouveaux propriétaires. Désormais, la transaction doit être transmise au réseau Bitcoin où elle fera partie de la chaîne de blocs. Dans la section suivante, nous verrons comment une transaction devient partie intégrante d&#39;un nouveau bloc et comment le bloc est « miné ». Enfin, nous verrons comment le nouveau bloc, une fois ajouté à la chaîne de blocs, est de plus en plus approuvé par le réseau au fur et à mesure que de nouveaux blocs sont ajoutés.</simpara>
<section id="_transmission_de_la_transaction">
<title>Transmission de la transaction</title>
<simpara><indexterm>
  <primary>&quot;propagation&quot;</primary><secondary>&quot;processus de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;processus de&quot;</primary>
</indexterm>La transaction contient toutes les informations nécessaires au traitement, et ce peu importe comment et où elle est transmise au réseau Bitcoin. Le réseau Bitcoin est un réseau pair à pair, chaque client Bitcoin participant en se connectant à plusieurs autres clients Bitcoin. Le but du réseau Bitcoin est de propager les transactions et les blocages à tous les participants.</simpara>
</section>
<section id="_comment_ça_se_propage">
<title>Comment ça se propage</title>
<simpara><indexterm>
  <primary>&quot;noeuds Bitcoin&quot;</primary><secondary>&quot;defini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;defini&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;noeuds&quot;</primary><secondary>see=&quot;noeuds Bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;noeuds Bitcoin&quot;</primary>
</indexterm>Tout système, tel qu&#39;un serveur, une application de bureau ou un portefeuille, qui participe au réseau Bitcoin en &quot;parlant&quot;, le protocole Bitcoin est appelé un <emphasis>nœud Bitcoin</emphasis>. L&#39;application de portefeuille d&#39;Alice peut envoyer la nouvelle transaction à n&#39;importe quel nœud Bitcoin auquel elle est connectée via n&#39;importe quel type de connexion : filaire, Wi-Fi, mobile, etc. Son portefeuille Bitcoin n&#39;a pas besoin d&#39;être connecté directement au portefeuille Bitcoin de Bob et elle n&#39;a pas à nécessairement utiliser la connexion Internet offerte par le café, bien que ces deux options soient également possibles. <indexterm>
  <primary>&quot;propagation&quot;</primary><secondary>&quot;technique d&#8217;inondation&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;technique d&#8217;inondation&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;technique d&#8217;inondation&quot;</primary>
</indexterm>Tout nœud Bitcoin qui reçoit une transaction valide qu&#39;il n&#39;a pas vue auparavant la transmettra immédiatement à tous les autres nœuds auxquels il est connecté , une technique de propagation connue sous le nom d'<emphasis>inondation</emphasis>. Ainsi, la transaction se propage (en inondant ou distribuant) rapidement à travers le réseau pair à pair, atteignant un grand pourcentage de nœuds en quelques secondes.</simpara>
</section>
<section id="_le_point_de_vue_de_bob">
<title>Le point de vue de Bob</title>
<simpara>Si l&#39;application de portefeuille bitcoin de Bob est directement connectée à l&#39;application de portefeuille d&#39;Alice, l&#39;application de portefeuille de Bob peut être le premier nœud à recevoir la transaction. Cependant, même si le portefeuille d&#39;Alice envoie la transaction via d&#39;autres nœuds, elle atteindra le portefeuille de Bob en quelques secondes. Le portefeuille de Bob identifiera immédiatement la transaction d&#39;Alice comme un paiement entrant car il contient des sorties remboursables par les clés de Bob. L&#39;application de portefeuille de Bob peut également vérifier de manière indépendante que la transaction est bien formée, utilise des sorties précédemment non dépensées et contient des frais de transaction suffisants pour être inclus dans le bloc suivant. À ce stade, Bob peut supposer, avec peu de risques, que la transaction sera bientôt incluse dans un bloc et confirmée.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;confirmations&quot;</primary><secondary>&quot;des transactions de petite valeur&quot;</secondary><tertiary>secondary-sortas=&quot;transactions de petite valeur&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;des transactions de petite valeur&quot;</primary><secondary>secondary-sortas=&quot;transactions de petite valeur&quot;</secondary>
</indexterm>
<indexterm>
  <primary>secondary-sortas=&quot;transactions de petite valeur&quot;</primary>
</indexterm> Une idée fausse courante à propos des transactions bitcoin est qu&#39;elles doivent être &quot;confirmées&quot; en attendant 10 minutes pour un nouveau bloc, ou jusqu&#39;à 60 minutes pour six confirmations complètes. Bien que les confirmations garantissent que la transaction a été acceptée par l&#39;ensemble du réseau, un tel délai n&#39;est pas nécessaire pour les articles de petite valeur comme une tasse de café. Un commerçant peut accepter une transaction valide de petite valeur sans confirmation, sans plus de risque qu&#39;un paiement par carte de crédit effectué sans pièce d&#39;identité ni signature, comme les commerçants l&#39;acceptent couramment aujourd&#39;hui.(((&quot;&quot;, startref=&quot;Tconstruct02&quot;)) )</simpara>
</tip>
</section>
</section>
</section>
<section id="_extraction_de_bitcoins">
<title>Extraction de bitcoins</title>
<simpara><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;vue générale de&quot;</secondary><tertiary>id=&quot;MACover02&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;vue générale de&quot;</primary><secondary>id=&quot;MACover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;MACover02&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;chaîne de blocs (la)&quot;</primary><secondary>&quot;vue générale du minage&quot;</secondary><tertiary>id=&quot;BToverview02&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;vue générale du minage&quot;</primary><secondary>id=&quot;BToverview02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BToverview02&quot;</primary>
</indexterm>La transaction d&#39;Alice est maintenant propagé sur le réseau Bitcoin. Il ne fait pas partie de la <emphasis>chaîne de blocs</emphasis> tant qu&#39;il n&#39;est pas vérifié et inclus dans un bloc par un processus appelé <emphasis>minage</emphasis>. Voir <xref linkend="mining"/> pour une explication détaillée.</simpara>
<simpara>Le système de confiance Bitcoin est basé sur le calcul. Les transactions sont regroupées en <emphasis>blocs</emphasis>, qui nécessitent une énorme quantité de calculs pour prouver, mais seulement une petite quantité de calculs pour vérifier comme prouvé. Le processus de minage sert à deux fins dans le bitcoin :</simpara>
<itemizedlist>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;règles de consensus&quot;</secondary><tertiary>&quot;sécurité fournie par&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;règles de consensus&quot;</primary><secondary>&quot;sécurité fournie par&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sécurité fournie par&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;consensus&quot;</primary><secondary>see=&quot;minage et consensus&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;minage et consensus&quot;</primary>
</indexterm>Les nœuds de minage valident toutes les transactions en se référant au <emphasis>consensus des règles de bitcoin</emphasis>. Par conséquent, le minage assure la sécurité des transactions bitcoin en rejetant les transactions invalides ou malformées.
</simpara>
</listitem>
<listitem>
<simpara>
L&#39;exploitation minière crée de nouveaux bitcoins dans chaque bloc, presque comme une banque centrale imprimant de la nouvelle monnaie. La quantité de bitcoin créée par bloc est limitée et diminue avec le temps, suivant un calendrier d&#39;émission fixe.
</simpara>
</listitem>
</itemizedlist>
<simpara>L&#39;exploitation minière atteint un bon équilibre entre le coût et la récompense. L&#39;exploitation minière utilise l&#39;électricité pour résoudre un problème mathématique. Un mineur qui réussit recevra une <emphasis>récompense</emphasis> sous la forme de nouveaux bitcoins et de frais de transaction. Cependant, la récompense ne sera perçue que si le mineur a correctement validé toutes les transactions, à la satisfaction des règles de <emphasis>consensus</emphasis>. Cet équilibre délicat assure la sécurité du bitcoin sans autorité centrale.</simpara>
<simpara>Une bonne façon de décrire l&#39;exploitation minière est comme un jeu compétitif géant de sudoku qui se réinitialise chaque fois que quelqu&#39;un trouve une solution et dont la difficulté s&#39;ajuste automatiquement de sorte qu&#39;il faut environ 10 minutes pour trouver une solution. Imaginez un puzzle sudoku géant, de plusieurs milliers de lignes et de colonnes. Si je vous montre un puzzle terminé, vous pouvez le vérifier assez rapidement. Cependant, si le puzzle a quelques cases remplies et que les autres sont vides, cela demande beaucoup de travail à résoudre ! La difficulté du sudoku peut être ajustée en modifiant sa taille (plus ou moins de lignes et de colonnes), mais elle peut toujours être vérifiée assez facilement même si elle est très grande. Le &quot;casse-tête&quot; utilisé dans le bitcoin est basé sur un hachage cryptographique et présente des caractéristiques similaires : il est asymétriquement difficile à résoudre mais facile à vérifier, et sa difficulté peut être ajustée.</simpara>
<simpara><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;fermes et groupes de minage&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;fermes et groupes de minage&quot;</primary>
</indexterm>In <xref linkend="user-stories"/>, nous avons présenté <indexterm>
  <primary>&quot;cas d&#8217;usage&quot;</primary><secondary>&quot;minage pour bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;minage pour bitcoin&quot;</primary>
</indexterm>Jing est un entrepreneur à Shanghai. Jing dirige une <emphasis>ferme minière</emphasis>, qui est une entreprise qui gère des milliers d&#39;ordinateurs miniers spécialisés, en compétition pour la récompense. Toutes les 10 minutes environ, les ordinateurs miniers de Jing rivalisent avec des milliers de systèmes similaires dans une course mondiale pour trouver une solution à un bloc de transactions. <indexterm>
  <primary>&quot;algorithme de preuve de travail&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;algorithme de preuve de travail&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;algorithme de preuve de travail&quot;</primary>
</indexterm>Trouver une telle solution, la soi-disant <emphasis>Proof-of-Work (ou Preuve de travail)</emphasis> (PoW), nécessite des quadrillions d&#39;opérations de hachage par seconde sur l&#39;ensemble du réseau Bitcoin. L&#39;algorithme de preuve de travail implique de hacher à plusieurs reprises l&#39;en-tête du bloc et un nombre aléatoire avec l&#39;algorithme cryptographique SHA256 jusqu&#39;à ce qu&#39;une solution correspondant à un modèle prédéterminé émerge. Le premier mineur à trouver une telle solution remporte la compétition et publie ce bloc dans la chaîne de blocs.</simpara>
<simpara>Jing a commencé l&#39;exploitation minière en 2010 en utilisant un ordinateur de bureau très rapide pour trouver une preuve de travail appropriée pour les nouveaux blocs. Au fur et à mesure que de plus en plus de mineurs rejoignaient le réseau Bitcoin, la difficulté du problème augmentait rapidement. Bientôt, Jing et d&#39;autres mineurs sont passés à du matériel plus spécialisé, avec des unités de traitement graphique (GPU) dédiées de haute de gamme, souvent utilisées dans les ordinateurs de bureau ou les consoles de jeu. Au moment d&#39;écrire ces lignes, la difficulté est si élevée qu&#39;il n&#39;est rentable de miner qu&#39;avec des <indexterm>
  <primary>&quot;circuits intégrés à application spécifique (ASIC)&quot;</primary>
</indexterm>circuits intégrés à application spécifique (ASIC), essentiellement des centaines d&#39;algorithmes de minage imprimé en matériel, fonctionnant en parallèle sur une seule puce de silicium. <indexterm>
  <primary>&quot;groupe de mineurs&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm>La société de Jing participe également à un <emphasis>groupe ou bassin de mineurs</emphasis>, qui, tout comme un groupe de loterie, permet à plusieurs participants de partager leurs efforts et leurs récompenses. La société de Jing gère désormais un entrepôt contenant des milliers de mineurs ASIC pour extraire du bitcoin 24 heures sur 24. L&#39;entreprise paie ses frais d&#39;électricité en vendant le bitcoin qu&#39;elle est capable de générer à partir de l&#39;exploitation minière, créant ainsi des revenus à partir des bénéfices.</simpara>
</section>
<section id="_transactions_minières_en_blocs">
<title>Transactions minières en blocs</title>
<simpara><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;miner des transaction dans&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;miner des transaction dans&quot;</primary>
</indexterm> De nouvelles transactions affluent constamment sur le réseau à partir des portefeuilles des utilisateurs et d&#39;autres applications. Comme ceux-ci sont vus par les nœuds du réseau Bitcoin, ils sont ajoutés à un bassin temporaire de transactions non vérifiées maintenues par chaque nœud. Lorsque les mineurs construisent un nouveau bloc, ils ajoutent des transactions non vérifiées de ce bassin au nouveau bloc, puis tentent de prouver la validité de ce nouveau bloc, avec l&#39;algorithme de minage (la preuve de travail). Le processus d&#39;extraction est expliqué en détail dans <xref linkend="mining"/>.</simpara>
<simpara>Les transactions sont ajoutées au nouveau bloc, classées par ordre de priorité par les transactions les plus payantes en premier et quelques autres critères. Chaque mineur commence le processus d&#39;extraction d&#39;un nouveau bloc de transactions dès qu&#39;il reçoit le bloc précédent du réseau, sachant qu&#39;il a perdu le tour de compétition précédent. Ils créent immédiatement un nouveau bloc, le remplissent avec les transactions et l&#39;empreinte numérique du bloc précédent, et commencent à calculer la preuve de travail pour le nouveau bloc. Chaque mineur inclut une transaction spéciale dans son bloc, une transaction qui paie à sa propre adresse Bitcoin la récompense du bloc (actuellement 6,25 bitcoins nouvellement créés) plus la somme des frais de transaction de toutes les transactions incluses dans le bloc. S&#39;ils trouvent une solution qui rend ce bloc valide, ils &quot;gagnent&quot; cette récompense car leur bloc réussi est ajouté à la chaîne de blocs mondiale et la transaction de récompense qu&#39;ils ont incluse devient dépensable. <indexterm>
  <primary>&quot;groupes de minage&quot;</primary><secondary>&quot;fonctionnement de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;fonctionnement de&quot;</primary>
</indexterm>Jing, qui participe à un groupe de minage, a mis en place son logiciel pour créer de nouveaux blocs qui attribuent la récompense à une adresse de pool. À partir de là, une part de la récompense est distribuée à Jing et aux autres mineurs proportionnellement à la quantité de travail qu&#39;ils ont apportée lors du dernier tour.</simpara>
<simpara><indexterm>
  <primary>&quot;blocs candidats&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;blocs candidats&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;blocs candidats&quot;</primary>
</indexterm>La transaction d&#39;Alice a été récupérée par le réseau et incluse dans le groupe de transactions non vérifiées. Une fois validé par le logiciel de minage, il a été inclus dans un nouveau bloc, appelé <emphasis>bloc candidat</emphasis>, généré par le pool de minage de Jing. Tous les mineurs participant à ce pool de minage commencent immédiatement à calculer la preuve de travail pour le bloc candidat. Environ cinq minutes après la première transmission de la transaction par le portefeuille d&#39;Alice, l&#39;un des mineurs ASIC de Jing a trouvé une solution pour le bloc candidat et l&#39;a annoncée au réseau. Une fois que les autres mineurs ont validé le bloc gagnant, ils ont commencé la course pour générer le bloc suivant.</simpara>
<simpara>Le bloc gagnant de Jing est devenu une partie de la blockchain en tant que bloc # 277316, contenant 419 transactions, y compris la transaction d&#39;Alice. Le bloc contenant la transaction d&#39;Alice est compté comme une &quot;confirmation&quot; de cette transaction.</simpara>
<tip>
<simpara>Vous pouvez voir le bloc qui inclut <ulink url="https://www.blockchain.com/btc/block/277316">Transaction d&#8217;Alice</ulink>.</simpara>
</tip>
<simpara><indexterm>
  <primary>&quot;confirmations&quot;</primary><secondary>&quot;rôle dans les transactions&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;rôle dans les transactions&quot;</primary>
</indexterm> Environ 20 minutes plus tard, un nouveau bloc, #277317, est miné par un autre mineur. Parce que ce nouveau bloc est construit au-dessus du bloc #277316 qui contenait la transaction d&#39;Alice, il a ajouté encore plus de calculs à la chaîne de blocs, renforçant ainsi la confiance dans ces transactions. Chaque bloc miné en plus de celui contenant la transaction compte comme une confirmation supplémentaire pour la transaction d&#39;Alice. Au fur et à mesure que les blocs s&#39;empilent les uns sur les autres, il devient exponentiellement plus difficile d&#39;inverser la transaction, ce qui la rend de plus en plus fiable par le réseau.</simpara>
<simpara><indexterm>
  <primary>&quot;bloc d&#8217;origine&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;bloc de d&#8217;origine&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;bloc de d&#8217;origine&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;chaîne de blocs (la)&quot;</primary><secondary>&quot;bloc d&#8217;origine&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;bloc d&#8217;origine&quot;</primary>
</indexterm>Dans le diagramme en <xref linkend="block-alice1"/>, nous pouvons voir le bloc #277316, qui contient la transaction d&#39;Alice. En dessous se trouvent 277 316 blocs (y compris le bloc #0), liés les uns aux autres dans une chaîne de blocs (blockchain) jusqu&#39;au bloc #0, connu sous le nom de <emphasis>bloc d&#8217;origine</emphasis>. Au fil du temps, à mesure que la &quot;hauteur&quot; des blocs augmente, la difficulté de calcul de chaque bloc et de la chaîne dans son ensemble augmente également. Les blocs extraits après celui qui contient la transaction d&#39;Alice agissent comme une assurance supplémentaire, car ils accumulent plus de calculs dans une chaîne de plus en plus longue. Par convention, tout bloc avec plus de six confirmations est considéré comme irrévocable, car il faudrait une immense quantité de calculs pour invalider et recalculer six blocs. Nous examinerons plus en détail le processus d&#39;exploitation minière et la manière dont il renforce la confiance dans <xref linkend="mining"/>.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;BToverview02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;BToverview02&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;MACover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;MACover02&quot;</primary>
</indexterm></simpara>
<figure id="block-alice1"><title>Transaction d&#39;Alice incluse dans le bloc #277316</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0209.png"/>
  </imageobject>
  <textobject><phrase>Alice's transaction included in a block</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_dépenser_la_transaction">
<title>Dépenser la transaction</title>
<simpara><indexterm>
  <primary>&quot;dépenser le bitcoin&quot;</primary><secondary>&quot;vérification-simplifiée-de-paiement (SPV)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;vérification-simplifiée-de-paiement (SPV)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;vérification-simplifiée-de-paiement (SPV)&quot;</primary>
</indexterm> Maintenant que la transaction d&#39;Alice a été intégrée à la chaîne de blocs dans le cadre d&#8217;un bloc, il fait partie du grand livre distribué de Bitcoin et est visible par toutes les applications Bitcoin. Chaque client Bitcoin peut indépendamment vérifier que la transaction est valide et utilisable. Les clients du nœud complet peuvent suivre la source des fonds à partir du moment où les bitcoins ont été générés pour la première fois dans un bloc, progressivement d&#39;une transaction à l&#39;autre, jusqu&#39;à ce qu&#39;ils atteignent l&#39;adresse de Bob. Les clients légers peuvent faire ce qu&#39;on appelle une vérification de paiement simplifiée (voir <xref linkend="spv_nodes"/>) en confirmant que la transaction est dans la chaîne de blocs et qu&#39;elle a plusieurs blocs extraits après elle, fournissant ainsi l&#39;assurance que les mineurs l&#39;ont acceptée comme valide.</simpara>
<simpara>Bob peut maintenant dépenser le résultat de cette transaction et d&#39;autres transactions. Par exemple, Bob peut payer un entrepreneur ou un fournisseur en transférant la valeur du paiement de la tasse de café d&#39;Alice à ces nouveaux propriétaires. Très probablement, le logiciel Bitcoin de Bob regroupera de nombreux petits paiements en un paiement plus important, concentrant peut-être tous les revenus Bitcoin de la journée en une seule transaction. Cela regrouperait les différents paiements en un seul résultat (et une seule adresse). Pour un diagramme d&#39;une transaction d&#39;agrégation, voir <xref linkend="transaction-aggregating"/>.</simpara>
<simpara>Au fur et à mesure que Bob dépense les paiements reçus d&#39;Alice et d&#39;autres clients, il étend la chaîne des transactions. Supposons que Bob paie son concepteur Web Gopesh<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;services contractuels extraterritorial&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;services contractuels extraterritorial&quot;</primary>
</indexterm> à Bangalore pour une nouvelle page Web. Maintenant, la chaîne de transactions ressemblera à <xref linkend="block-alice2"/>.</simpara>
<figure id="block-alice2"><title>La transaction d&#39;Alice dans le cadre d&#39;une chaîne de transactions de Joe à Gopesh, où la sortie d&#39;une transaction est utilisée comme entrée de la transaction suivante</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0210.png"/>
  </imageobject>
  <textobject><phrase>Alice's transaction as part of a transaction chain</phrase></textobject>
</mediaobject>
</figure>
<simpara>Dans ce chapitre, nous avons vu comment les transactions construisent une chaîne qui déplace la valeur d&#39;un propriétaire à l&#39;autre. Nous avons également suivi la transaction d&#39;Alice, à partir du moment où elle a été créée dans son portefeuille, via le réseau Bitcoin et jusqu&#39;aux mineurs qui l&#39;ont enregistrée sur la chaîne de blocs. Dans le reste de ce livre, nous examinerons les technologies spécifiques derrière les portefeuilles, les adresses, les signatures, les transactions, le réseau et enfin le minage.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;BCover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;BCover02&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref =&quot;DCSover02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref =&quot;DCSover02&quot;</primary>
</indexterm> <indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;UCcoffee02&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;UCcoffee02&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="ch03_bitcoin_client">
<title>Bitcoin Core : La référence d&#39;implémentation</title>
<simpara><indexterm>
  <primary>&quot;licences source libre&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Nakamoto</primary><secondary>Satoshi&quot;</secondary>
</indexterm>
<indexterm>
  <primary>Satoshi&quot;</primary>
</indexterm>Bitcoin est un projet <emphasis>source libre</emphasis> et le code source est disponible sous une licence ouverte (MIT), téléchargeable et utilisable à n&#39;importe quelle fin. Source libre signifie plus que simplement libre d&#39;utilisation. Cela signifie également que le bitcoin est développé par une communauté ouverte de bénévoles. Au début, cette communauté se composait uniquement de Satoshi Nakamoto. En 2016, le code source de Bitcoin comptait plus de 400 contributeurs avec une douzaine de développeurs travaillant sur le code presque à temps plein et plusieurs dizaines d&#39;autres à temps partiel. Tout le monde peut contribuer au code, y compris vous !</simpara>
<simpara><indexterm>
  <primary>&quot;livre blanc bitcoin&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;client Satoshi&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;implémentation de référence&quot;</primary><secondary>see=&quot;Bitcoin Core&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;Bitcoin Core&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;implémentation de référence&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;implémentation de référence&quot;</primary>
</indexterm>Lorsque bitcoin a été créé par Satoshi Nakamoto, le logiciel était en fait terminé avant le livre blanc reproduit dans <xref linkend="satoshi_whitepaper"/>. Satoshi voulait s&#39;assurer que cela fonctionnait avant d&#39;écrire à ce sujet. Cette première implémentation, alors simplement connue sous le nom de &quot;Bitcoin&quot; ou &quot;client Satoshi&quot;, a été fortement modifiée et améliorée. Il a évolué vers ce qu&#39;on appelle <emphasis>Bitcoin Core</emphasis>, pour le différencier des autres implémentations compatibles. Bitcoin Core est la <emphasis>mise en œuvre de référence</emphasis> du système Bitcoin, ce qui signifie qu&#39;il s&#39;agit de la référence faisant autorité sur la manière dont chaque partie de la technologie doit être mise en œuvre. Bitcoin Core implémente tous les aspects du bitcoin, y compris les portefeuilles, un moteur de validation des transactions et des blocs et un nœud de réseau complet dans le réseau Bitcoin pair à pair.</simpara>
<warning>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;meilleures pratiques pour&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;meilleures pratiques pour&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration du bitcoin&quot;</primary><secondary>&quot;mots de code mnémonique (BIP-39)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;mots de code mnémonique (BIP-39)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration du bitcoin&quot;</primary><secondary>&quot;portefeuilles déterministes hiérarchiques (BIP-32/BIP-44)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;portefeuilles déterministes hiérarchiques (BIP-32/BIP-44)&quot;</primary>
</indexterm>Même si Bitcoin Core inclut une implémentation de référence d&#39;un portefeuille, celui-ci n&#39;est pas destiné à être utilisé comme portefeuille de production pour les utilisateurs ou pour les applications. Il est conseillé aux développeurs d&#39;applications de créer des portefeuilles en utilisant des normes modernes telles que BIP-39 et BIP-32 (voir <xref linkend="mnemonic_code_words"/> et <xref linkend="hd_wallets"/>). BIP signifie <emphasis>Bitcoin Improvement Proposal</emphasis>.</simpara>
</warning>
<simpara><xref linkend="bitcoin_core_architecture"/> montre l&#39;architecture de Bitcoin Core.<indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;architecture&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;architecture&quot;</primary>
</indexterm></simpara>
<figure id="bitcoin_core_architecture"><title>Architecture Bitcoin Core (Source : Eric Lombrozo)</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0301.png"/>
  </imageobject>
  <textobject><phrase>&quot;Architecture de base Bitcoin&quot;</phrase></textobject>
</mediaobject>
</figure>
<section id="_environnement_de_développement_bitcoin">
<title>Environnement de développement Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;environnement de développement&quot;</primary><secondary>&quot;configuration&quot;</secondary><tertiary>see=&quot;Bitcoin Core&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;configuration&quot;</primary><secondary>see=&quot;Bitcoin Core&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;Bitcoin Core&quot;</primary>
</indexterm> Si vous êtes un développeur, vous souhaiterez configurer un environnement de développement avec tous les outils, bibliothèques et logiciels de support pour le développement d&#8217;applications bitcoin. Dans ce chapitre très technique, nous allons parcourir ce processus étape par étape. Si le matériel devient trop dense (et que vous n&#39;êtes pas en train de mettre en place un environnement de développement), n&#39;hésitez pas à passer au chapitre suivant, qui est moins technique.</simpara>
</section>
<section id="compiling_core">
<title>Compilation de Bitcoin Core à partir du code source</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;compilation à partir du code source&quot;</secondary><tertiary>id=&quot;BCsource03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;compilation à partir du code source&quot;</primary><secondary>id=&quot;BCsource03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCsource03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;compilation à partir du code source&quot;</secondary><tertiary>&quot;téléchargement&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;compilation à partir du code source&quot;</primary><secondary>&quot;téléchargement&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;téléchargement&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;exemples de code</primary><secondary>obtenir et utiliser&quot;</secondary>
</indexterm>
<indexterm>
  <primary>obtenir et utiliser&quot;</primary>
</indexterm>Le code source de Bitcoin Core peut être téléchargé sous forme d&#39;archive ou en clonant le référentiel source faisant autorité à partir de GitHub. <indexterm>
  <primary>&quot;téléchargement de Bitcoin Core&quot;</primary>
</indexterm>Sur la <ulink url="https://bitcoincore.org/bin/">page de téléchargement de Bitcoin Core</ulink>, sélectionnez la version la plus récente et téléchargez l&#39;archive compressée du code source, par exemple, <literal>bitcoin-0.15.0.2.tar.gz</literal>. <indexterm>
  <primary>&quot;page GitHub bitcoin&quot;</primary>
</indexterm>Vous pouvez également utiliser la ligne de commande git pour créer une copie locale du code source à partir de la <ulink url="https://github.com/bitcoin/bitcoin">page GitHub de bitcoin</ulink>.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;symbole $&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;commandes interface système&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;applications de terminal&quot;</primary>
</indexterm>Dans de nombreux exemples de ce chapitre, nous utiliserons l&#39;interface de de commande du système d&#39;exploitation ( également appelé &quot;shell&quot; ou &quot;interface système&quot; ou &quot;coque logicielle&quot;), accessible via une application &quot;terminal&quot;. L&#8217;interface système affichera une invite; vous tapez une commande; et l&#8217;interface système répond avec du texte et une nouvelle invite pour votre prochaine commande. L&#39;invite peut sembler différente sur votre système, mais dans les exemples suivants, elle est indiquée par un symbole <literal>$</literal>. Dans les exemples, lorsque vous voyez du texte après un symbole <literal>$</literal>, ne tapez pas le symbole <literal>$</literal> mais tapez la commande qui le suit immédiatement, puis appuyez sur Entrée pour exécuter la commande. Dans les exemples, les lignes sous chaque commande sont les réponses du système d&#39;exploitation à cette commande. Lorsque vous verrez le prochain préfixe <literal>$</literal>, vous saurez qu&#39;il s&#39;agit d&#39;une nouvelle commande et vous devrez répéter le processus.</simpara>
</tip>
<simpara><indexterm>
  <primary>&quot;clonage du code source&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;code source</primary><secondary>clonage&quot;</secondary><tertiary>seealso=&quot;Bitcoin Core&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>clonage&quot;</primary><secondary>seealso=&quot;Bitcoin Core&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;Bitcoin Core&quot;</primary>
</indexterm> Dans cet exemple, nous utilisons la commande <literal>git</literal> pour créer une copie locale (un &quot;clone&quot;) du code source :</simpara>
<screen>$ git clone https://github.com/bitcoin/bitcoin.git
Cloning into 'bitcoin'...
remote: Counting objects: 102071, done.
remote: Compressing objects: 100% (10/10), done.
Receiving objects: 100% (102071/102071), 86.38 MiB | 730.00 KiB/s, done.
remote: Total 102071 (delta 4), reused 5 (delta 1), pack-reused 102060
Resolving deltas: 100% (76168/76168), done.
Checking connectivity... done.
$</screen>
<tip>
<simpara><indexterm>
  <primary>&quot;systèmes de contrôle de version distribués&quot;</primary>
</indexterm>Git est le système de contrôle de version distribué le plus largement utilisé et un élément essentiel de la boîte à outils de tout développeur de logiciels. Vous devrez peut-être installer la commande <literal>git</literal>, ou une interface utilisateur graphique pour git, sur votre système d&#39;exploitation si vous ne l&#39;avez pas déjà.</simpara>
</tip>
<simpara>Une fois l&#39;opération de clonage git terminée, vous aurez une copie locale complète du référentiel de code source dans le répertoire <emphasis>bitcoin</emphasis>. Accédez à ce répertoire en tapant <literal><emphasis role="strong">cd bitcoin</emphasis></literal> à l&#39;invite :</simpara>
<screen>$ cd bitcoin</screen>
<section id="_sélection_d_39_une_version_de_bitcoin_core">
<title>Sélection d&#39;une version de Bitcoin Core</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;compilation à partir du code source&quot;</secondary><tertiary>&quot;sélection de version&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;compilation à partir du code source&quot;</primary><secondary>&quot;sélection de version&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sélection de version&quot;</primary>
</indexterm>Par défaut, la copie locale sera synchronisée avec le code le plus récent, qui peut être une version instable ou bêta de bitcoin. Avant de compiler le code, sélectionnez une version spécifique en consultant une version avec la commande Git <emphasis>tag</emphasis>. Cela synchronisera la copie locale avec un instantané (snapshot) spécifique du référentiel de code identifié par une balise de mot-clé (le <emphasis>tag</emphasis>.) Les balises sont utilisées par les développeurs pour marquer des versions spécifiques du code par numéro de version. Tout d&#39;abord, pour trouver les balises disponibles, nous utilisons la commande <literal>git tag</literal> :</simpara>
<screen>$ git tag
v0.1.5
v0.1.6test1
v0.10.0
...
v0.11.2
v0.11.2rc1
v0.12.0rc1
v0.12.0rc2
...</screen>
<simpara>La liste des balises montre toutes les versions publiées de bitcoin. Par convention, les <emphasis>release candidates</emphasis> (ou <emphasis>versions d&#8217;évaluations</emphasis>), qui sont destinées aux tests, ont le suffixe &quot;rc&quot;. Les versions stables pouvant être exécutées sur des systèmes de production n&#39;ont pas de suffixe. Dans la liste précédente, sélectionnez la version la plus élevée, qui au moment de la rédaction était v0.15.0. Pour synchroniser le code local avec cette version, utilisez la commande <literal>git checkout</literal> :</simpara>
<screen>$ git checkout v0.15.0
HEAD is now at 3751912... Merge #11295: doc: Old fee_estimates.dat are discarded by 0.15.0</screen>
<simpara>Vous pouvez confirmer que vous avez la version souhaitée &quot;extraite&quot; en lançant la commande <literal>git status</literal> :</simpara>
<screen>$ git status
HEAD detached at v0.15.0
nothing to commit, working directory clean</screen>
</section>
<section id="_configuration_de_la_construction_de_bitcoin_core">
<title>Configuration de la construction de Bitcoin Core</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;compilation à partir du code source&quot;</secondary><tertiary>&quot;build configuration&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;compilation à partir du code source&quot;</primary><secondary>&quot;build configuration&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;build configuration&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;documentation&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;contruire documentation&quot;</primary><secondary>seealso=&quot;Bitcoin Core&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;Bitcoin Core&quot;</primary>
</indexterm>Le code source inclut la documentation, qui peut être trouvée dans un certain nombre de fichiers. Passez en revue la documentation principale située dans <emphasis>README.md</emphasis> dans le répertoire <emphasis>bitcoin</emphasis> en tapant <literal><emphasis role="strong">more README.md</emphasis></literal> à l&#39;invite et en utilisant la barre d&#39;espace pour passer à la page suivante. Dans ce chapitre, nous allons construire le client Bitcoin en ligne de commande, également connu sous le nom de <literal>bitcoind</literal> sous Linux. Passez en revue les instructions pour compiler le client de ligne de commande <literal>bitcoind</literal> sur votre plate-forme en tapant <literal><emphasis role="strong">more doc/build-unix.md</emphasis></literal>. Des instructions alternatives pour macOS et Windows peuvent être trouvées dans le répertoire <emphasis>doc</emphasis>, comme <emphasis>build-osx.md</emphasis> ou <emphasis>build-windows.md</emphasis>, respectivement.</simpara>
<simpara>Examinez attentivement les prérequis de construction, qui se trouvent dans la première partie de la documentation de construction. Ce sont des bibliothèques qui doivent être présentes sur votre système avant de pouvoir commencer à compiler Bitcoin. Si ces conditions préalables sont manquantes, le processus de génération échouera avec une erreur. Si cela se produit parce que vous avez manqué une condition préalable, vous pouvez l&#39;installer, puis reprendre le processus de génération là où vous l&#39;avez laissé. En supposant que les prérequis sont installés, vous démarrez le processus de génération en générant un ensemble de scripts de génération à l&#39;aide du script <emphasis>autogen.sh</emphasis>.</simpara>
<screen>$ ./autogen.sh
...
glibtoolize: copying file 'build-aux/m4/libtool.m4'
glibtoolize: copying file 'build-aux/m4/ltoptions.m4'
glibtoolize: copying file 'build-aux/m4/ltsugar.m4'
glibtoolize: copying file 'build-aux/m4/ltversion.m4'
...
configure.ac:10: installing 'build-aux/compile'
configure.ac:5: installing 'build-aux/config.guess'
configure.ac:5: installing 'build-aux/config.sub'
configure.ac:9: installing 'build-aux/install-sh'
configure.ac:9: installing 'build-aux/missing'
Makefile.am: installing 'build-aux/depcomp'
...</screen>
<simpara>Le script <emphasis>autogen.sh</emphasis> crée un ensemble de scripts de configuration automatique qui interrogeront votre système pour découvrir les paramètres corrects et s&#39;assurer que vous disposez de toutes les bibliothèques nécessaires pour compiler le code. Le plus important d&#39;entre eux est le script <literal>configure</literal> qui offre un certain nombre d&#39;options différentes pour personnaliser le processus de construction. Tapez <literal><emphasis role="strong">./configure --help</emphasis></literal> pour voir les différentes options:</simpara>
<screen>$ ./configure --help
`configure' configures Bitcoin Core 0.15.0 to adapt to many kinds of systems.

Usage: ./configure [OPTION]... [VAR=VALUE]...

...
Optional Features:
  --disable-option-checking  ignore unrecognized --enable/--with options
  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]

  --enable-wallet         enable wallet (default is yes)

  --with-gui[=no|qt4|qt5|auto]
...</screen>
<simpara>Le script <literal>configure</literal> vous permet d&#39;activer ou de désactiver certaines fonctionnalités de <literal>bitcoind</literal> grâce à l&#39;utilisation des drapeaux <literal>--enable-FEATURE</literal> et <literal>--disable-FEATURE</literal>, où <span class="keep-together"><code>FEATURE</code></span> est remplacé par le nom de la fonctionnalité, comme indiqué dans la sortie d&#39;aide. Dans ce chapitre, nous allons construire le client <literal>bitcoind</literal> avec toutes les fonctionnalités par défaut. Nous n&#39;utiliserons pas les indicateurs de configuration, mais vous devriez les consulter pour comprendre quelles fonctionnalités facultatives font partie du client. Si vous êtes dans un environnement universitaire, les restrictions du laboratoire informatique peuvent vous obliger à installer des applications dans votre répertoire personnel (par exemple, en utilisant <literal>--prefix=$HOME</literal>).</simpara>
<simpara>Voici quelques options utiles qui remplacent le comportement par défaut du script configure:</simpara>
<dl>
<dt><code>--prefix=$HOME</code></dt>
<dd><p>Cela remplace l&#39;emplacement d&#39;installation par défaut (qui est <em>/usr/local/</em> ) pour l&#39;exécutable résultant. Utilisez <code>$HOME</code> pour tout mettre dans votre répertoire personnel, ou un chemin différent.</p></dd>

<dt><code>--disable-wallet</code></dt>
<dd><p>Ceci est utilisé pour désactiver l&#39;implémentation du portefeuille de référence.</p></dd>

<dt><code>--with-incompatible-bdb</code></dt>
<dd><p>Si vous construisez un portefeuille, autorisez l&#39;utilisation d&#39;une version incompatible de la bibliothèque Berkeley DB.</p></dd>

<dt><code>--with-gui=no</code></dt>
<dd><p>Ne construisez pas l&#39;interface utilisateur graphique, qui nécessite la bibliothèque Qt. Cela construit uniquement le bitcoin du serveur et de la ligne de commande.</p></dd>
</dl>
<simpara>Ensuite, exécutez le script <literal>configure</literal> pour découvrir automatiquement toutes les bibliothèques nécessaires et créer un script de construction personnalisé pour votre système :</simpara>
<screen>$ ./configure
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
...
[de nombreuses pages de tests de configuration suivent]
...
$</screen>
<simpara>Si tout s&#39;est bien passé, la commande <literal>configure</literal> se terminera par la création des scripts de construction personnalisés qui nous permettront de compiler <literal>bitcoind</literal>. S&#39;il y a des bibliothèques manquantes ou des erreurs, la commande <literal>configure</literal> se terminera par une erreur au lieu de créer les scripts de construction. Si une erreur se produit, elle est probablement due à une bibliothèque manquante ou incompatible. Relisez à nouveau la documentation de build et assurez-vous d&#39;installer les prérequis manquants. Ensuite, exécutez à nouveau <literal>configure</literal> et voyez si cela corrige l&#39;erreur.</simpara>
</section>
<section id="_construire_les_exécutables_bitcoin_core">
<title>Construire les exécutables Bitcoin Core</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;compiling from source code&quot;</secondary><tertiary>&quot;core executables&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;compiling from source code&quot;</primary><secondary>&quot;core executables&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;core executables&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;core executables&quot;</primary><secondary>seealso=&quot;Bitcoin Core&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;Bitcoin Core&quot;</primary>
</indexterm> Ensuite, vous allez compiler le code source, un processus qui peut prendre jusqu&#39;à une heure, en fonction de la vitesse de votre processeur et de la mémoire disponible. Pendant le processus de compilation, vous devriez voir une sortie toutes les quelques secondes ou toutes les quelques minutes, ou une erreur si quelque chose ne va pas. Si une erreur se produit ou si le processus de compilation est interrompu, il peut être repris à tout moment en tapant à nouveau <literal>make</literal>. Tapez <literal><emphasis role="strong">make</emphasis></literal> pour lancer la compilation de l&#39;application exécutable :</simpara>
<screen>$ make
Making all in src
  CXX      crypto/libbitcoinconsensus_la-hmac_sha512.lo
  CXX      crypto/libbitcoinconsensus_la-ripemd160.lo
  CXX      crypto/libbitcoinconsensus_la-sha1.lo
  CXX      crypto/libbitcoinconsensus_la-sha256.lo
  CXX      crypto/libbitcoinconsensus_la-sha512.lo
  CXX      libbitcoinconsensus_la-hash.lo
  CXX      primitives/libbitcoinconsensus_la-transaction.lo
  CXX      libbitcoinconsensus_la-pubkey.lo
  CXX      script/libbitcoinconsensus_la-bitcoinconsensus.lo
  CXX      script/libbitcoinconsensus_la-interpreter.lo

[... de nombreux autres messages de compilation suivent ...]

$</screen>
<simpara>Sur un système rapide avec plusieurs processeurs, vous souhaiterez peut-être définir le nombre de tâches de compilation parallèles. Par exemple, <literal>make -j 2</literal> utilisera deux cœurs s&#39;ils sont disponibles. Si tout se passe bien, Bitcoin Core est maintenant compilé. Vous devez exécuter la suite de tests unitaires avec <literal>make check</literal> pour vous assurer que les bibliothèques liées ne sont pas cassées de manière évidente. La dernière étape consiste à installer les différents exécutables sur votre système à l&#39;aide de la commande <literal>make install</literal>. Vous serez peut-être invité à saisir votre mot de passe utilisateur, car cette étape nécessite des privilèges d&#39;administrateur:</simpara>
<screen>$ make check &amp;&amp; sudo make install
Password:
Making install in src
 ../build-aux/install-sh -c -d '/usr/local/lib'
libtool: install: /usr/bin/install -c bitcoind /usr/local/bin/bitcoind
libtool: install: /usr/bin/install -c bitcoin-cli /usr/local/bin/bitcoin-cli
libtool: install: /usr/bin/install -c bitcoin-tx /usr/local/bin/bitcoin-tx
...
$</screen>
<simpara><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;BCsource03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;BCsource03&quot;</primary>
</indexterm>L&#39;installation par défaut de <literal>bitcoind</literal> le place dans <emphasis>/usr/local/bin</emphasis>. Vous pouvez confirmer que Bitcoin Core est correctement installé en demandant au système le chemin des exécutables, comme suit:</simpara>
<screen>$ which bitcoind
/usr/local/bin/bitcoind

$ which bitcoin-cli
/usr/local/bin/bitcoin-cli</screen>
</section>
</section>
<section id="_exécution_d_39_un_nœud_bitcoin_core">
<title>Exécution d&#39;un nœud Bitcoin Core</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;running core nodes&quot;</secondary><tertiary>id=&quot;BCnode03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;running core nodes&quot;</primary><secondary>id=&quot;BCnode03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCnode03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Bitcoin nodes&quot;</primary><secondary>&quot;running core nodes&quot;</secondary><tertiary>id=&quot;BNcore03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;running core nodes&quot;</primary><secondary>id=&quot;BNcore03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BNcore03&quot;</primary>
</indexterm>Le réseau pair à pair de Bitcoin est composé de &quot;nœuds&quot; de réseau, gérés principalement par des bénévoles et certaines des entreprises qui créent des applications bitcoin. Ceux qui exécutent des nœuds Bitcoin ont une vue directe et faisant autorité sur la chaîne de blocs Bitcoin, avec une copie locale de toutes les transactions, validées indépendamment par leur propre système. En exécutant un nœud, vous n&#39;avez pas besoin de faire appel à un tiers pour valider une transaction. De plus, en exécutant un nœud Bitcoin, vous contribuez au réseau Bitcoin en le rendant plus robuste et sécuritaire.</simpara>
<simpara>Cependant, l&#39;exécution d&#39;un nœud nécessite un système connecté en permanence avec suffisamment de ressources pour traiter toutes les transactions bitcoin. Selon que vous choisissez d&#39;indexer toutes les transactions et de conserver une copie complète de la chaîne de blocs, vous pouvez également avoir besoin de beaucoup d&#39;espace disque et de mémoire RAM. Au début de 2021, un nœud à index complet a besoin de 2 Go de RAM et d&#39;un minimum de 360 Go d&#39;espace disque (voir <ulink url="https://www.blockchain.com/charts/blocks-size">https://www.blockchain.com/charts/blocks-size</ulink>). Les nœuds Bitcoin transmettent et reçoivent également des transactions et des blocs Bitcoin, consommant de la bande passante Internet. Si votre connexion Internet est limitée, a un faible plafond de données ou est mesurée (facturée au gigabit), vous ne devriez probablement pas exécuter un nœud Bitcoin, ou l&#39;exécuter d&#39;une manière qui limite sa bande passante (voir <xref linkend="constrained_resources"/>).</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;besoins en ressources du nœud principal&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;besoins en ressources du nœud principal&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;besoins en ressources&quot;</primary>
</indexterm>Bitcoin Core conserve une copie complète de la chaîne de blocs par défaut, avec chaque transaction qui s&#39;est déjà produite sur le Bitcoin réseau depuis sa création en 2009. Cet ensemble de données a une taille de dizaines de gigaoctets et est téléchargé de manière incrémentielle sur plusieurs jours ou semaines, en fonction de la vitesse de votre CPU et de votre connexion Internet. Bitcoin Core ne pourra pas traiter les transactions ou mettre à jour les soldes des comptes tant que l&#39;ensemble de données complet de la chaîne de blocs n&#39;aura pas été téléchargé. Assurez-vous que vous disposez de suffisamment d&#39;espace disque, de bande passante et de temps pour effectuer la synchronisation initiale. Vous pouvez configurer Bitcoin Core pour réduire la taille de la chaîne de blocs en supprimant les anciens blocs (voir <xref linkend="constrained_resources"/>), mais il téléchargera tout de même l&#39;intégralité de l&#39;ensemble de données avant de les supprimer.</simpara>
</tip>
<simpara>Malgré ces besoins en ressources, des milliers de bénévoles gèrent des nœuds Bitcoin. Certains fonctionnent sur des systèmes aussi simples qu&#39;un Raspberry Pi (un ordinateur à 35$ US de la taille d&#39;un paquet de cartes). De nombreux volontaires exécutent également des nœuds Bitcoin sur des serveurs loués, généralement une variante de Linux. Une instance de <emphasis>Virtual Private Server</emphasis> (VPS ou serveur virtuel privé) ou <emphasis>Cloud Computing Server</emphasis> (ou serveur en infonuagique) peut être utilisée pour exécuter un nœud Bitcoin. Ces serveurs peuvent être loués pour 25$ à 50$ US par mois auprès de divers fournisseurs.</simpara>
<simpara>Pourquoi voudriez-vous exécuter un nœud ? Voici quelques-unes des raisons les plus courantes :</simpara>
<itemizedlist>
<listitem>
<simpara>
Si vous développez un logiciel bitcoin et que vous devez vous fier à un nœud Bitcoin pour un accès programmable (API) au réseau et à la blockchain.
</simpara>
</listitem>
<listitem>
<simpara>
Si vous créez des applications qui doivent valider les transactions selon les règles de consensus de bitcoin. En règle générale, les éditeurs de logiciels Bitcoin exécutent plusieurs nœuds.
</simpara>
</listitem>
<listitem>
<simpara>
Si vous souhaitez prendre en charge le bitcoin. L&#39;exécution d&#39;un nœud rend le réseau plus robuste et capable de servir plus de portefeuilles, plus d&#39;utilisateurs et plus de transactions.
</simpara>
</listitem>
<listitem>
<simpara>
Si vous ne souhaitez pas vous fier à un tiers pour traiter ou valider vos transactions.
</simpara>
</listitem>
</itemizedlist>
<simpara>Si vous lisez ce livre et êtes intéressé par le développement d&#39;un logiciel Bitcoin, vous devriez exécuter votre propre nœud.</simpara>
<section id="_configuration_du_nœud_bitcoin_core">
<title>Configuration du nœud Bitcoin Core</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;exécution des nœuds principaux&quot;</secondary><tertiary>&quot;configuration&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;exécution des nœuds principaux&quot;</primary><secondary>&quot;configuration&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;configuration&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;création de mot de passe&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;création de mot de passe&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;mots de passe&quot;</primary><secondary>&quot;création&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;création&quot;</primary>
</indexterm>( <indexterm><primary>&quot;sécurité&quot;</primary></indexterm>&quot;sécurité&quot;Bitcoin Core recherchera un fichier de configuration dans son répertoire de données à chaque démarrage. Dans cette section, nous examinerons les différentes options de configuration et créerons un fichier de configuration. Pour localiser le fichier de configuration, exécutez <literal>bitcoind -printtoconsole</literal> dans votre terminal et recherchez les deux premières lignes.</simpara>
<screen>$ bitcoind -printtoconsole
Bitcoin version v0.15.0
Using the 'standard' SHA256 implementation
Using data directory /home/ubuntu/.bitcoin/
Using config file /home/ubuntu/.bitcoin/bitcoin.conf
...
[beaucoup plus de sortie de débogage]
...</screen>
<simpara>Vous pouvez appuyer sur Ctrl-C pour fermer le nœud une fois que vous avez déterminé l&#39;emplacement du fichier de configuration. Habituellement, le fichier de configuration se trouve dans le répertoire de données <emphasis>.bitcoin</emphasis> sous le répertoire personnel de votre utilisateur. Il n&#39;est pas créé automatiquement, mais vous pouvez créer un fichier de configuration de démarrage en copiant et collant à partir de l&#39;exemple &lt;&lt;#full_index_node&gt;&gt; ci-dessous. Vous pouvez créer ou modifier le fichier de configuration dans votre éditeur préféré.</simpara>
<simpara>Bitcoin Core propose plus de 100 options de configuration qui modifient le comportement du nœud de réseau, le stockage de la chaîne de blocs et de nombreux autres aspects de son fonctionnement. Pour voir une liste de ces options, exécutez <literal>bitcoind --help</literal> :</simpara>
<screen>$ bitcoind --help
Bitcoin Core Daemon version v0.15.0

Usage:
  bitcoind [options]                     Start Bitcoin Core Daemon

Options:

  -?
       Print this help message and exit

  -version
       Print version and exit

  -alertnotify=&lt;cmd&gt;
       Execute command when a relevant alert is received or we see a really
       long fork (%s in cmd is replaced by message)
...
[beaucoup plus d&amp;#39;options]
...

  -rpcthreads=&lt;n&gt;
       Set the number of threads to service RPC calls (default: 4)</screen>
<simpara><indexterm>
  <primary>&quot;configuration d&#8217;options&quot;</primary><secondary>seealso=&quot;Bitcoin Core&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;Bitcoin Core&quot;</primary>
</indexterm>Voici quelques-unes des options les plus importantes que vous pouvez définir dans le fichier de configuration, ou en tant que paramètres de ligne de commande pour <literal>bitcoind</literal> :</simpara>
<variablelist>
<varlistentry>
<term>
alertnotify
</term>
<listitem>
<simpara>
Exécute une commande ou un script spécifié pour envoyer des alertes d&#39;urgence au propriétaire de ce nœud, généralement par courriel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
conf
</term>
<listitem>
<simpara>
Un emplacement alternatif pour le fichier de configuration. Cela n&#39;a de sens qu&#39;en tant que paramètre de ligne de commande pour <literal>bitcoind</literal>, car il ne peut pas se trouver dans le fichier de configuration auquel il se réfère.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
datadir
</term>
<listitem>
<simpara>
Sélectionnez le répertoire et le système de fichiers dans lesquels vous placer toutes les données de la chaîne de blocs. Par défaut, il s&#39;agit d&#8217;un sous-répertoire de <emphasis>.bitcoin</emphasis> de votre répertoire personnel. Assurez-vous que ce système de fichiers dispose de plusieurs gigaoctets d&#39;espace libre.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
prune
</term>
<listitem>
<simpara>
Réduisez les besoins en espace disque à ce nombre de mégaoctets, en supprimant les anciens blocs. Utilisez ceci sur un nœud à ressources limitées qui ne peut pas contenir la chaîne de blocs complète.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
txindex
</term>
<listitem>
<simpara>
Maintient un index de toutes les transactions. Cela signifie une copie complète de la chaîne de blocs. Cela vous permet de récupérer par programmation toute transaction par identifiant (ID).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
dbcache
</term>
<listitem>
<simpara>
La taille du cache UTXO. La valeur par défaut est 450 Mio. Augmentez cette valeur sur le matériel haut de gamme et réduisez la taille sur le matériel bas de gamme pour économiser de la mémoire au détriment des entrées-sorties des disques lents.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
maxconnections
</term>
<listitem>
<simpara>
Définissez le nombre maximal de nœuds à partir desquels accepter les connexions. Le réduire par défaut réduira votre consommation de bande passante. À utiliser si vous avez un plafond de données ou si vous payez au gigaoctet.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
maxmempool
</term>
<listitem>
<simpara>
Limite le bassin de mémoire de transaction à ce nombre de mégaoctets. Utilisez-le pour réduire l&#39;utilisation de la mémoire sur les nœuds à mémoire limitée.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
maxreceivebuffer/maxsendbuffer
</term>
<listitem>
<simpara>
Limite la mémoire tampon par connexion à ce nombre de multiples de 1000 octets. À utiliser sur les nœuds à mémoire limitée.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
minrelaytxfee
</term>
<listitem>
<simpara>
Définissez le taux de frais minimum pour la transaction que vous relayerez. En dessous de cette valeur, la transaction est traitée non standard, rejetée du bassin de transactions et non relayée.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<sidebar id="txindex">
<title>Index de la base de données des transactions et option txindex</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;fonction des noeuds coeurs&quot;</secondary><tertiary>&quot;database options&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;fonction des noeuds coeurs&quot;</primary><secondary>&quot;database options&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;database options&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;configuration d&#8217;options de base de données&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;configuration d&#8217;options de base de données&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;option txindex&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;option d&#39;indexation complète&quot;</primary>
</indexterm>Par défaut, Bitcoin Core construit une base de données contenant <emphasis>uniquement</emphasis> les transactions liées au portefeuille de l&#39;utilisateur. Si vous voulez pouvoir accéder à <emphasis>n&#39;importe quelle</emphasis> transaction avec des commandes comme <literal>getrawtransaction</literal> (voir <xref linkend="exploring_and_decoding_transanctions"/>), vous devez configurer Bitcoin Core pour créer un index de transaction complet, ce qui peut être réalisé avec l&#39;option <literal>txindex</literal>. Définissez <literal>txindex=1</literal> dans le fichier de configuration de Bitcoin Core. Si vous ne définissez pas cette option au début et que vous la réglez ensuite sur l&#39;indexation complète, vous devez redémarrer <literal>bitcoind</literal> avec l&#39;option <literal>-reindex</literal> et attendre qu&#39;elle reconstruise l&#39;index.</simpara>
</sidebar>
<simpara><xref linkend="full_index_node"/> montre comment vous pouvez combiner les options précédentes, avec un nœud entièrement indexé, fonctionnant comme un backend API pour une application bitcoin.</simpara>
<example id="full_index_node">
<title>Exemple de configuration d&#39;un nœud à index complet</title>
<screen>alertnotify=myemailscript.sh &amp;quot;Alerte : %s&amp;quot;
datadir=/lotsofspace/bitcoin
index_tx=1</screen>
</example>
<simpara><xref linkend="constrained_resources"/> montre un nœud à ressources limitées s&#39;exécutant sur un serveur plus petit.</simpara>
<example id="constrained_resources">
<title>Exemple de configuration d&#39;un système à ressources limitées</title>
<screen>alertnotify=myemailscript.sh &amp;quot;Alerte : %s&amp;quot;
maxconnexions=15
prune=5000
dbcache=150
maxmempool=150
maxreceivebuffer=2500
maxsendbuffer=500</screen>
</example>
<simpara>Une fois que vous avez modifié le fichier de configuration et défini les options qui représentent le mieux vos besoins, vous pouvez tester <literal>bitcoind</literal> avec cette configuration. Exécutez Bitcoin Core avec l&#39;option <literal>printtoconsole</literal> pour s&#39;exécuter au premier plan avec une sortie vers la console :</simpara>
<screen>$ bitcoind -printtoconsole

Bitcoin version v0.15.0
InitParameterInteraction: parameter interaction: -whitelistforcerelay=1 -&gt; setting -whitelistrelay=1
Assuming ancestors of block 0000000000000000003b9ce759c2a087d52abc4266f8f4ebd6d768b89defa50a have valid signatures.
Using the 'standard' SHA256 implementation
Default data directory /home/ubuntu/.bitcoin
Using data directory /lotsofspace/.bitcoin
Using config file /home/ubuntu/.bitcoin/bitcoin.conf
Using at most 125 automatic connections (1048576 file descriptors available)
Using 16 MiB out of 32/2 requested for signature cache, able to store 524288 elements
Using 16 MiB out of 32/2 requested for script execution cache, able to store 524288 elements
Using 2 threads for script verification
HTTP: creating work queue of depth 16
No rpcpassword set - using random cookie authentication
Generated RPC authentication cookie /lotsofspace/.bitcoin/.cookie
HTTP: starting 4 worker threads
init message: Verifying wallet(s)...
Using BerkeleyDB version Berkeley DB 4.8.30: (April  9, 2010)
Using wallet wallet.dat
CDBEnv::Open: LogDir=/lotsofspace/.bitcoin/database ErrorFile=/lotsofspace/.bitcoin/db.log
scheduler thread start
Cache configuration:
* Using 250.0MiB for block index database
* Using 8.0MiB for chain state database
* Using 1742.0MiB for in-memory UTXO set (plus up to 286.1MiB of unused mempool space)
init message: Loading block index...
Opening LevelDB in /lotsofspace/.bitcoin/blocks/index
Opened LevelDB successfully

[... plus de messages de démarrage ...]</screen>
<simpara>Vous pouvez appuyer sur Ctrl-C pour interrompre le processus une fois que vous êtes convaincu qu&#39;il charge les paramètres correctement et s&#39;exécute comme prévu.</simpara>
<simpara>Pour exécuter Bitcoin Core en arrière-plan en tant que processus, démarrez-le avec l&#39;option <literal>daemon</literal>, en tant que <literal>bitcoind -daemon</literal>.</simpara>
<simpara>Pour surveiller la progression et l&#39;état d&#39;exécution de votre nœud Bitcoin, utilisez la commande <literal>bitcoin-cli getblockchaininfo</literal> :</simpara>
<screen>$ bitcoin-cli getblockchaininfo</screen>
<programlisting language="json" linenumbering="unnumbered">{
  "chain": "main",
  "blocks": 0,
  "headers": 83999,
  "bestblockhash": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  "difficulty": 1,
  "mediantime": 1231006505,
  "verificationprogress": 3.783041623201835e-09,
  "chainwork": "0000000000000000000000000000000000000000000000000000000100010001",
  "pruned": false,
  [...]
}</programlisting>
<simpara>Cela montre un nœud avec une hauteur de blockchain de 0 blocs et 83999 en-têtes. Le nœud récupère actuellement les en-têtes de bloc de la meilleure chaîne et continue ensuite à télécharger les blocs complets.</simpara>
<simpara>Une fois que vous êtes satisfait des options de configuration que vous avez sélectionnées, vous devez ajouter <emphasis>bitcoin</emphasis> aux scripts de démarrage de votre système d&#39;exploitation, afin qu&#39;il s&#39;exécute en continu et au redémarrage du système d&#39;exploitation. Vous trouverez un certain nombre d&#39;exemples de scripts de démarrage pour différents systèmes d&#39;exploitation dans le répertoire source de bitcoin sous <emphasis>contrib/init</emphasis> et un fichier <emphasis>README.md</emphasis> indiquant quel système utilise quel script.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;BCnode03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;BCnode03&quot;</primary>
</indexterm>(( (&quot;&quot;, startref=&quot;BNcore03&quot;)))</simpara>
</section>
</section>
<section id="_interface_de_programmation_d_39_application_api_de_base_bitcoin">
<title>Interface de programmation d&#39;application (API) de base Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;Bitcoin Core API&quot;</secondary><tertiary>id=&quot;BCapi03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Bitcoin Core API&quot;</primary><secondary>id=&quot;BCapi03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCapi03&quot;</primary>
</indexterm>Le client Bitcoin Core implémente une interface JSON-RPC accessible également à l&#39;aide de l&#39;assistant de ligne de commande <literal>bitcoin-cli</literal>. La ligne de commande nous permet d&#39;expérimenter de manière interactive les fonctionnalités qui sont également disponibles par programmation via l&#39;API. <indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;Bitcoin Core API&quot;</secondary><tertiary>&quot;Commandes RPC&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Bitcoin Core API&quot;</primary><secondary>&quot;Commandes RPC&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Commandes RPC&quot;</primary>
</indexterm>Pour commencer, appelez la commande <literal>help</literal> pour voir une liste des commandes RPC bitcoin disponibles :</simpara>
<screen id="bitcoind_commands">$ bitcoin-cli help
addmultisigaddress nrequired ["key",...] ( "account" )
addnode "node" "add|remove|onetry"
backupwallet "destination"
createmultisig nrequired ["key",...]
createrawtransaction [{"txid":"id","vout":n},...] {"address":amount,...}
decoderawtransaction "hexstring"
...
...
verifymessage "bitcoinaddress" "signature" "message"
walletlock
walletpassphrase "passphrase" timeout
walletpassphrasechange "oldpassphrase" "newpassphrase"</screen>
<simpara>Chacune de ces commandes peut prendre un certain nombre de paramètres. Pour obtenir une aide supplémentaire, une description détaillée et des informations sur les paramètres, ajoutez le nom de la commande après <literal>help</literal>. Par exemple, pour voir l&#39;aide sur la commande <literal>getblockhash</literal> RPC :</simpara>
<screen>$ bitcoin-cli help getblockhash
getblockhash height

Returns hash of block in best-block-chain at height provided.

Arguments:
1. height         (numeric, required) The height index

Result:
"hash"         (string) The block hash

Examples:
&gt; bitcoin-cli getblockhash 1000
&gt; curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getblockhash", "params": [1000] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/</screen>
<simpara>À la fin des informations d&#39;aide, vous verrez deux exemples de la commande RPC, utilisant l&#39;assistant <literal>bitcoin-cli</literal> ou le client HTTP <literal>curl</literal>. Ces exemples montrent comment vous pouvez appeler la commande. Copiez le premier exemple et voyez le résultat :</simpara>
<screen>$ bitcoin-cli getblockhash 1000
00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09</screen>
<simpara>Le résultat est un hachage de bloc, qui est décrit plus en détail dans les chapitres suivants. Mais pour l&#39;instant, cette commande devrait renvoyer le même résultat sur votre système, démontrant que votre nœud Bitcoin Core est en cours d&#39;exécution, accepte les commandes et dispose d&#39;informations sur le bloc 1000 à vous renvoyer.</simpara>
<simpara>Dans les sections suivantes, nous allons démontrer quelques commandes RPC très utiles et leur sortie attendue.</simpara>
<section id="_obtenir_des_informations_sur_l_39_état_du_client_bitcoin_core">
<title>Obtenir des informations sur l&#39;état du client Bitcoin Core</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;Bitcoin Core API&quot;</secondary><tertiary>&quot;informations d&#39;état&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Bitcoin Core API&quot;</primary><secondary>&quot;informations d&#39;état&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;informations d&#39;état&quot;</primary>
</indexterm>Bitcoin Core fournit des rapports d&#39;état sur différents modules via l&#39;interface JSON-RPC. Les commandes les plus importantes incluent <literal>getblockchaininfo</literal>, <literal>getmempoolinfo</literal>, <literal>getnetworkinfo</literal> et <literal>getwalletinfo</literal>.</simpara>
<simpara>La commande <literal>getblockchaininfo</literal> RPC de Bitcoin a été introduite plus tôt. La commande <literal>getnetworkinfo</literal> affiche des informations de base sur l&#39;état du nœud de réseau Bitcoin. Utilisez <literal>bitcoin-cli</literal> pour l&#39;exécuter :</simpara>
<screen>$ bitcoin-cli getnetworkinfo</screen>
<programlisting language="json" linenumbering="unnumbered">  "version": 150000,
  "subversion": "/Satoshi:0.15.0/",
  "protocolversion": 70015,
  "localservices": "000000000000000d",
  "localrelay": true,
  "timeoffset": 0,
  "networkactive": true,
  "connections": 8,
  "networks": [
    ...
    detailed information about all networks (ipv4, ipv6 or onion)
    ...
  ],
  "relayfee": 0.00001000,
  "incrementalfee": 0.00001000,
  "localaddresses": [
  ],
  "warnings": ""
}</programlisting>
<simpara>Les données sont renvoyées en JavaScript Object Notation (JSON), un format qui peut facilement être &quot;consommé&quot; par tous les langages de programmation mais qui est également assez lisible par l&#39;homme. Parmi ces données, nous voyons les numéros de version du client logiciel bitcoin (150000) et du protocole Bitcoin (70015). On y voit le nombre actuel de connexions (8) et diverses informations sur le réseau Bitcoin et les paramètres liés à ce client.</simpara>
<tip>
<simpara>Il faudra un certain temps, peut-être plus d&#39;une journée, pour que le client <literal>bitcoind</literal> &quot;rattrape&quot; la hauteur actuelle de la chaîne de blocs lorsqu&#39;il télécharge des blocs d&#39;autres clients Bitcoin. Vous pouvez vérifier sa progression en utilisant <literal>getblockchaininfo</literal> pour voir le nombre de blocs connus.</simpara>
</tip>
</section>
<section id="exploring_and_decoding_transanctions">
<title>Explorer et décoder les transactions</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;Bitcoin Core API&quot;</secondary><tertiary>&quot;explorer et décoder les transactions&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Bitcoin Core API&quot;</primary><secondary>&quot;explorer et décoder les transactions&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;explorer et décoder les transactions&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;explorer avec l&#39;API Bitcoin Core&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;explorer avec l&#39;API Bitcoin Core&quot;</primary>
</indexterm>Commandes : <literal>getrawtransaction</literal>, <literal>decoderawtransaction</literal></simpara>
<simpara>Dans <xref linkend="cup_of_coffee"/>, <indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;acheter du café&quot;</secondary><tertiary>id=&quot;alicethree&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;acheter du café&quot;</primary><secondary>id=&quot;alicethree&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;alicethree&quot;</primary>
</indexterm>Alice a acheté une tasse de café au Bob&#39;s Cafe. Sa transaction a été enregistrée sur la blockchain avec l&#39;identifiant de transaction (<literal>txid</literal>) <literal>0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2</literal>. Utilisons l&#39;API pour récupérer et examiner cette transaction en transmettant l&#39;identifiant de transaction en tant que paramètre :</simpara>
<pre data-type="programlisting">
$ bitcoin-cli getrawtransaction 0627052b6f28912f2703066a912ea577f2ce4da4caa5a&#x21b5;
5fbd8a57286c345c2f2

0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd734d2804fe65fa35779000&#x21b5;
000008b483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4&#x21b5;
ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813014&#x21b5;
10484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc54123363767&#x21b5;
89d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adfffffffff0260e3160000000&#x21b5;
0001976a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef8000000000001976a9&#x21b5;
147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000000
</pre>
<tip>
<simpara><indexterm>
  <primary>&quot;identifiant de transaction (txd)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;malléabilité&quot;</primary>
</indexterm>Un identifiant de transaction ne fait pas autorité tant qu&#39;une transaction n&#39;a pas été confirmée. L&#39;absence d&#39;un hachage de transaction dans la blockchain ne signifie pas que la transaction n&#39;a pas été traitée. C&#39;est ce qu&#39;on appelle la &quot;malléabilité des transactions&quot;, car les hachages de transaction peuvent être modifiés avant la confirmation dans un bloc. Après confirmation, le <literal>txid</literal> est immuable et fait autorité.</simpara>
</tip>
<simpara>La commande <literal>getrawtransaction</literal> renvoie une transaction sérialisée en notation hexadécimale. Pour décoder cela, nous utilisons la commande <literal>decoderawtransaction</literal>, en passant les données hexadécimales en paramètre. Vous pouvez copier l&#39;hex renvoyé par <literal>getrawtransaction</literal> et le coller en tant que paramètre dans <literal>decoderawtransaction</literal> :</simpara>
<pre data-type="programlisting">
$ bitcoin-cli decoderawtransaction 0100000001186f9f998a5aa6f048e51dd8419a14d8&#x21b5;
a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba474&#x21b5;
6ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298&#x21b5;
cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fd&#x21b5;
e0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa&#x21b5;
336a8d752adfffffffff0260e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5&#x21b5;
d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8&#x21b5;
88ac00000000

</pre>
<pre data-type="programlisting" data-code-language="json">
{
  "txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
  "size": 258,
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2...8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig": {
        "asm":"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1decc...",
        "hex":"483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1de..."
      },
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 ab68...5f654e7 OP_EQUALVERIFY OP_CHECKSIG",
        "hex": "76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac",
        "reqSigs": 1,
        "type": "pubkeyhash",
        "addresses": [
          "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"
        ]
      }
    },
    {
      "value": 0.08450000,
      "n": 1,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 7f9b1a...025a8 OP_EQUALVERIFY OP_CHECKSIG",
        "hex": "76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
        "reqSigs": 1,
        "type": "pubkeyhash",
        "addresses": [
          "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK"
        ]
      }
    }
  ]
}

</pre>
<simpara>Le décodage de la transaction montre tous les composants de cette transaction, y compris les entrées et les sorties de la transaction. Dans ce cas, nous voyons que la transaction qui a crédité notre nouvelle adresse de 15 millibits a utilisé une entrée et généré deux sorties. L&#39;entrée de cette transaction était la sortie d&#39;une transaction précédemment confirmée (indiquée par <literal>txid</literal> commençant par <literal>7957a35fe</literal>). Les deux sorties correspondent au crédit de 15 millibits et une sortie avec retour à l&#39;expéditeur.</simpara>
<simpara>Nous pouvons explorer davantage la chaîne de blocs en examinant la transaction précédente référencée par son <literal>txid</literal> dans cette transaction en utilisant les mêmes commandes (par exemple, <literal>getrawtransaction</literal>). En sautant d&#39;une transaction à l&#39;autre, nous pouvons suivre une chaîne de transactions à mesure que les pièces sont transmises d&#39;adresse de propriétaire à adresse de propriétaire.</simpara>
</section>
<section id="_explorer_les_blocs">
<title>Explorer les blocs</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;Bitcoin Core API&quot;</secondary><tertiary>&quot;exploration de blocs&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Bitcoin Core API&quot;</primary><secondary>&quot;exploration de blocs&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exploration de blocs&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;exploration avec Bitcoin Core API&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exploration avec Bitcoin Core API&quot;</primary>
</indexterm>Commandes : <literal>getblock</literal>, <literal>getblockhash</literal></simpara>
<simpara><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;hauteur de bloc&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;hauteur de bloc&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;blocs&quot;</primary><secondary>&quot;hachage de bloc&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;hachage de bloc&quot;</primary>
</indexterm>L&#39;exploration de blocs est similaire à l&#39;exploration de transactions. Cependant, les blocs peuvent être référencés soit par la <emphasis>hauteur</emphasis> du bloc (<emphasis>height</emphasis>), soit par le résultat de <emphasis>hachage</emphasis> (ou <emphasis>hash</emphasis>) du bloc. Tout d&#39;abord, trouvons un bloc par sa hauteur. Dans <xref linkend="cup_of_coffee"/>, nous avons vu que la transaction d&#39;Alice était incluse dans le bloc 277316.</simpara>
<simpara>Nous utilisons la commande <literal>getblockhash</literal>, qui prend la hauteur du bloc comme paramètre et renvoie le hachage pour ce bloc :</simpara>
<pre data-type="programlisting">
$ bitcoin-cli getblockhash 277316
0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4
</pre>
<simpara>Maintenant que nous savons dans quel bloc la transaction d&#39;Alice était incluse, nous pouvons interroger ce bloc. Nous utilisons la commande <literal>getblock</literal> avec le hachage de bloc comme paramètre :</simpara>
<pre data-type="programlisting">
$ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b3&#x21b5;
1b2cc7bdc4
</pre>
<pre data-type="programlisting" data-code-language="json">
{
  "hash": "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
  "confirmations": 37371,
  "size": 218629,
  "height": 277316,
  "version": 2,
  "merkleroot": "c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e",
  "tx": [
    "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
    "b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe",
    "04905ff987ddd4cfe603b03cfb7ca50ee81d89d1f8f5f265c38f763eea4a21fd",
    "32467aab5d04f51940075055c2f20bbd1195727c961431bf0aff8443f9710f81",
    "561c5216944e21fa29dd12aaa1a45e3397f9c0d888359cb05e1f79fe73da37bd",
[... des centaines de transactions ...]
    "78b300b2a1d2d9449b58db7bc71c3884d6e0579617e0da4991b9734cef7ab23a",
    "6c87130ec283ab4c2c493b190c20de4b28ff3caf72d16ffa1ce3e96f2069aca9",
    "6f423dbc3636ef193fd8898dfdf7621dcade1bbe509e963ffbff91f696d81a62",
    "802ba8b2adabc5796a9471f25b02ae6aeee2439c679a5c33c4bbcee97e081196",
    "eaaf6a048588d9ad4d1c092539bd571dd8af30635c152a3b0e8b611e67d1a1af",
    "e67abc6bd5e2cac169821afc51b207127f42b92a841e976f9b752157879ba8bd",
    "d38985a6a1bfd35037cb7776b2dc86797abbb7a06630f5d03df2785d50d5a2ac",
    "45ea0a3f6016d2bb90ab92c34a7aac9767671a8a84b9bcce6c019e60197c134b",
    "c098445d748ced5f178ef2ff96f2758cbec9eb32cb0fc65db313bcac1d3bc98f"
  ],
  "time": 1388185914,
  "mediantime": 1388183675,
  "nonce": 924591752,
  "bits": "1903a30c",
  "difficulty": 1180923195.258026,
  "chainwork": "000000000000000000000000000000000000000000000934695e92aaf53afa1a",
  "previousblockhash": "0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569",
  "nextblockhash": "000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"
}
</pre>
<simpara>Le bloc contient 419 transactions et la 64ème transaction répertoriée (<literal>0627052b&#8230;</literal>) est le paiement du café d&#39;Alice. L&#39;entrée + hauteur + nous indique qu&#39;il s&#39;agit du 277316e bloc de la blockchain.</simpara>
</section>
<section id="_utilisation_de_l_39_interface_de_programmation_de_bitcoin_core">
<title>Utilisation de l&#39;interface de programmation de Bitcoin Core</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;Bitcoin Core API&quot;</secondary><tertiary>&quot;utiliser une interface de programmation&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Bitcoin Core API&quot;</primary><secondary>&quot;utiliser une interface de programmation&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;utiliser une interface de programmation&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;interface de programmation&quot;</primary><secondary>id=&quot;progint03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;progint03&quot;</primary>
</indexterm>L&#39;assistant <literal>bitcoin-cli</literal> est très utile pour explorer la bibliothèue (API) Bitcoin Core et les fonctions de test. Mais tout l&#39;intérêt d&#39;une interface de programmation d&#39;application est d&#39;accéder aux fonctions par programmation. Dans cette section, nous montrerons comment accéder à Bitcoin Core à partir d&#39;un autre programme.</simpara>
<simpara>L&#39;API de Bitcoin Core est une interface JSON-RPC. JSON signifie JavaScript Object Notation et c&#39;est un moyen très pratique de présenter des données que les humains et les programmes peuvent facilement lire. RPC signifie Remote Procedure Call (ou appel de procédure à distance), ce qui signifie que nous appelons des procédures (fonctions) distantes (sur le nœud Bitcoin Core) via un protocole réseau. Dans ce cas, le protocole réseau est HTTP ou HTTPS (pour les connexions cryptées).</simpara>
<simpara>Lorsque nous avons utilisé la commande <literal>bitcoin-cli</literal> pour obtenir de l&#39;aide sur une commande, elle nous a montré un exemple d&#39;utilisation de <literal>curl</literal>, le client HTTP polyvalent en ligne de commande pour construire l&#39;un de ces appels JSON-RPC :</simpara>
<screen>$ curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getblockchaininfo", "params": [] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/</screen>
<simpara>Cette commande montre que <literal>curl</literal> soumet une requête HTTP à l&#39;hôte local (127.0.0.1), se connecte au port bitcoin par défaut (8332) et soumet une requête <literal>jsonrpc</literal> pour la méthode <literal>getblockchaininfo</literal> en utilisant l&#39;encodage <literal>text/plain</literal>.</simpara>
<simpara>Vous remarquerez peut-être que curl demandera que les informations d&#39;identification soient envoyées avec la demande. Bitcoin Core créera un mot de passe aléatoire à chaque démarrage et le placera dans le répertoire de données sous le nom <literal>.cookie</literal>. L&#39;assistant <literal>bitcoin-cli</literal> peut lire ce fichier de mots de passe étant donné le répertoire de données. De même, vous pouvez copier le mot de passe et le transmettre à curl (ou à tout wrapper Bitcoin Core RPC de niveau supérieur). Alternativement, vous pouvez créer un mot de passe statique avec le script d&#39;assistance fourni dans <emphasis>./share/rpcauth/rpcauth.py</emphasis> dans le répertoire source de Bitcoin Core.</simpara>
<simpara>Si vous implémentez un appel JSON-RPC dans votre propre programme, vous pouvez utiliser une bibliothèque HTTP générique pour construire l&#39;appel, similaire à ce qui est montré dans l&#39;exemple <literal>curl</literal> précédent.</simpara>
<simpara>Cependant, il existe des bibliothèques dans la plupart des langages de programmation qui &quot;enveloppent&quot; l&#39;API Bitcoin Core d&#39;une manière qui rend cela beaucoup plus simple. Nous utiliserons la bibliothèque <literal>python-bitcoinlib</literal> pour simplifier l&#39;accès à l&#39;API. N&#39;oubliez pas que cela nécessite que vous disposiez d&#39;une instance Bitcoin Core en cours d&#39;exécution, qui sera utilisée pour effectuer des appels JSON-RPC.</simpara>
<simpara>Le script Python dans <xref linkend="rpc_example"/> effectue un simple appel <literal>getblockchaininfo</literal> et imprime le paramètre <literal>blocks</literal> à partir des données renvoyées par Bitcoin Core (nœud complet requis).</simpara>
<example id="rpc_example">
<title>Exécution de getblockchaininfo via l&#39;API JSON-RPC de Bitcoin Core</title>
<programlisting language="python" linenumbering="unnumbered">from bitcoin.rpc import RawProxy

# Create a connection to local Bitcoin Core node
p = RawProxy()

# Run the getinfo command, store the resulting data in info
info = p.getinfo()

# Retrieve the 'blocks' element from the info
print(info['blocks'])</programlisting>
</example>
<simpara>Son exécution nous donne le résultat suivant:</simpara>
<screen>$ python rpc_example.py
394075</screen>
<simpara>Il nous indique que notre nœud local Bitcoin Core a 394075 blocs dans sa chaîne de blocs. Ce n&#39;est pas un résultat spectaculaire, mais cela démontre l&#39;utilisation de base de la bibliothèque en tant qu&#39;interface simplifiée avec l&#39;API JSON-RPC de Bitcoin Core.</simpara>
<simpara>Ensuite, utilisons les appels <literal>getrawtransaction</literal> et <literal>decodetransaction</literal> pour récupérer les détails du paiement du café d&#39;Alice. Dans <xref linkend="rpc_transaction"/>, nous récupérons la transaction d&#39;Alice et listons les sorties de la transaction. Pour chaque sortie, nous affichons l&#39;adresse et la valeur du destinataire. Pour rappel, la transaction d&#39;Alice avait une sortie pour payer Bob&#39;s Cafe et une sortie pour rendre la monnaie à Alice.</simpara>
<example id="rpc_transaction">
<title>Récupérer une transaction et itérer ses sorties</title>
<programlisting language="python" linenumbering="unnumbered">from bitcoin.rpc import RawProxy

p = RawProxy()

# Alice's transaction ID
txid = "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2"

# First, retrieve the raw transaction in hex
raw_tx = p.getrawtransaction(txid)

# Decode the transaction hex into a JSON object
decoded_tx = p.decoderawtransaction(raw_tx)

# Retrieve each of the outputs from the transaction
for output in decoded_tx['vout']:
    print(output['scriptPubKey']['addresses'], output['value'])</programlisting>
</example>
<simpara>En exécutant ce code, nous obtenons :</simpara>
<screen>$ python rpc_transaction.py
([u'1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA'], Decimal('0.01500000'))
([u'1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK'], Decimal('0.08450000'))</screen>
<simpara>Les deux exemples précédents sont assez simples. Vous n&#39;avez pas vraiment besoin d&#39;un programme pour les exécuter ; vous pouvez tout aussi bien utiliser l&#39;assistant <literal>bitcoin-cli</literal>. L&#39;exemple suivant, cependant, nécessite plusieurs centaines d&#39;appels RPC et démontre plus clairement l&#39;utilisation d&#39;une interface de programmation.</simpara>
<simpara>Dans <xref linkend="rpc_block"/>, nous récupérons d&#39;abord le bloc 277316, puis récupérons chacune des 419 transactions en référence à chaque identifiant de transaction. Ensuite, nous parcourons chacune des sorties de la transaction et additionnons la valeur.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;alicethree&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;alicethree&quot;</primary>
</indexterm></simpara>
<example id="rpc_block">
<title>Récupération d&#39;un bloc et ajout de toutes les sorties de transaction</title>
<programlisting language="python" linenumbering="unnumbered">from bitcoin.rpc import RawProxy

p = RawProxy()

# The block height where Alice's transaction was recorded
blockheight = 277316

# Get the block hash of block with height 277316
blockhash = p.getblockhash(blockheight)

# Retrieve the block by its hash
block = p.getblock(blockhash)

# Element tx contains the list of all transaction IDs in the block
transactions = block['tx']

block_value = 0

# Iterate through each transaction ID in the block
for txid in transactions:
    tx_value = 0
    # Retrieve the raw transaction by ID
    raw_tx = p.getrawtransaction(txid)
    # Decode the transaction
    decoded_tx = p.decoderawtransaction(raw_tx)
    # Iterate through each output in the transaction
    for output in decoded_tx['vout']:
        # Add up the value of each output
        tx_value = tx_value + output['value']

    # Add the value of this transaction to the total
    block_value = block_value + tx_value

print("Total value in block: ", block_value)</programlisting>
</example>
<simpara>En exécutant ce code, nous obtenons :</simpara>
<screen>$ python rpc_block.py

('Total value in block: ', Decimal('10322.07722534'))</screen>
<simpara>Notre exemple de code calcule que la valeur totale des transactions dans ce bloc est de 10 322,07722534 BTC (dont 25 BTC de récompense et 0,0909 BTC de frais). Comparez cela au montant rapporté par un site d&#39;exploration de blocs en recherchant le hachage ou la hauteur du bloc. Certains explorateurs de blocs rapportent la valeur totale hors récompense et hors frais. Voyez si vous pouvez repérer la différence.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;BCapi03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;BCapi03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;progint03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;progint03&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="alt_libraries">
<title>Clients, bibliothèques et boîtes à outils alternatifs</title>
<simpara><indexterm>
  <primary>&quot;Bitcoin Core&quot;</primary><secondary>&quot;alternatives à&quot;</secondary><tertiary>id=&quot;BCalt03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;alternatives à&quot;</primary><secondary>id=&quot;BCalt03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BCalt03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clients</primary><secondary>bibliothèques et boîtes à outils&quot;</secondary><tertiary>id=&quot;clients03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>bibliothèques et boîtes à outils&quot;</primary><secondary>id=&quot;clients03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;clients03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;bibliothèques</primary><secondary>clients et trousses d&#39;outils&quot;</secondary><tertiary>id=&quot;librar03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>clients et trousses d&#39;outils&quot;</primary><secondary>id=&quot;librar03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;librar03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;trousses d&#39;outils</primary><secondary>bibliothèques et clients&quot;</secondary><tertiary>id=&quot;toolkit03&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>bibliothèques et clients&quot;</primary><secondary>id=&quot;toolkit03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;toolkit03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clients API tiers&quot;</primary><secondary>id=&quot;thirdpart03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;thirdpart03&quot;</primary>
</indexterm> Il existe de nombreux clients alternatifs, bibliothèques, boîtes à outils et même des implémentations de nœuds complets dans l&#39;écosystème bitcoin. Ceux-ci sont implémentés dans une variété de langages de programmation, offrant aux programmeurs des interfaces natives dans leur langue préférée.</simpara>
<simpara>Les sections suivantes répertorient certaines des meilleures bibliothèques, clients et kits d&#39;outils, organisés par langages de programmation.</simpara>
<section id="_c_c">
<title>C/C++</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoin/bitcoin">Bitcoin Core</ulink>
</term>
<listitem>
<simpara>
L&#39;implémentation de référence de bitcoin
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/libbitcoin/libbitcoin-system">libbitcoin</ulink>
</term>
<listitem>
<simpara>
Boîte à outils de développement C++ multiplateforme, nœud et bibliothèque de consensus
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/libbitcoin/libbitcoin-explorer">bitcoin explorer</ulink>
</term>
<listitem>
<simpara>
L&#39;outil de ligne de commande de Libbitcoin
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/jgarzik/picocoin">picocoin</ulink>
</term>
<listitem>
<simpara>
Bibliothèque cliente légère en langage C pour bitcoin par Jeff Garzik
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_javascript">
<title>JavaScript</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://bcoin.io/">bcoin</ulink>
</term>
<listitem>
<simpara>
Une implémentation modulaire et évolutive de nœud complet avec API
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://bitcore.io/">Bitcore</ulink>
</term>
<listitem>
<simpara>
Noeud complet, API et bibliothèque par Bitpay
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoinjs/bitcoinjs-lib">BitcoinJS</ulink>
</term>
<listitem>
<simpara>
Une pure bibliothèque Bitcoin en JavaScript pour node.js et les navigateurs
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_java">
<title>Java</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://bitcoinj.github.io">bitcoinj</ulink> 
</term>
<listitem>
<simpara>
Une bibliothèque client Java à nœud complet
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>====PHP
<ulink url="https://github.com/bit-wasp/bitcoin-php">bitwasp/bitcoin</ulink>:: Une bibliothèque Bitcoin en PHP et des projets associés</simpara>
<simpara>====Python
<ulink url="https://github.com/petertodd/python-bitcoinlib">python-bitcoinlib</ulink>:: Une bibliothèque Bitcoin en Python dont une bibliothèque de consensus et un nœud par Peter Todd
<ulink url="https://github.com/richardkiss/pycoin">pycoin</ulink>:: Une bibliothèque Bitcoin en Python par Richard Kiss
<ulink url="https://github.com/primal100/pybitcointools">pybitcointools</ulink>:: Une fourche archivé de la bibliothèque Bitcoin en Python par Vitalik Buterin</simpara>
</section>
<section id="_ruby">
<title>Ruby</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/sinisterchipmunk/bitcoin-client">bitcoin-client</ulink>
</term>
<listitem>
<simpara>
Un wrapper de bibliothèque Ruby pour l&#39;API JSON-RPC
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_go">
<title>Go</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/btcsuite/btcd">btcd</ulink>
</term>
<listitem>
<simpara>
Un client Bitcoin à nœud complet en langage Go
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_rust">
<title>Rust</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/rust-bitcoin/rust-bitcoin">rust-bitcoin</ulink>
</term>
<listitem>
<simpara>
Bibliothèque Bitcoin Rust pour la sérialisation, l&#39;analyse et les appels d&#39;API
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_c">
<title>C#</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/MetacoSA/NBitcoin">NBitcoin</ulink>
</term>
<listitem>
<simpara>
Bibliothèque Bitcoin complète pour le framework .NET
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_objective_c">
<title>Objective-C</title>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/oleganza/CoreBitcoin">CoreBitcoin</ulink> 
</term>
<listitem>
<simpara>
Boîte à outils Bitcoin pour ObjC et Swift
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>De nombreuses autres bibliothèques existent dans une variété d&#39;autres langages de programmation et d&#39;autres sont créées tout le temps.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;BCalt03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;BCalt03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;clients03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;clients03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;thirdpart03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;thirdpart03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;toolkit03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;toolkit03&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;librar03&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;librar03&quot;</primary>
</indexterm></simpara>
</section>
</section>
</section>
<section id="ch04_keys_addresses">
<title>Clés, Adresses</title>
<simpara><indexterm>
  <primary>&quot;cryptographie&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cryptographie&quot;</primary><secondary>see=&quot;aussi clés et adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi clés et adresses&quot;</primary>
</indexterm>Vous avez peut-être entendu dire que le bitcoin est basé sur la <emphasis>cryptographie</emphasis>, qui est une branche des mathématiques largement utilisée en sécurité informatique. La cryptographie signifie &quot;écriture secrète&quot; en grec, mais la science de la cryptographie englobe plus que la simple écriture secrète, appelée cryptage. La cryptographie peut également être utilisée pour prouver la connaissance d&#39;un secret sans révéler ce secret (signature numérique), ou prouver l&#39;authenticité des données (empreinte numérique). Ces types de preuves cryptographiques sont les outils mathématiques essentiels au bitcoin et largement utilisés dans les applications bitcoin. <indexterm>
  <primary>&quot;cryptage&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cryptage&quot;</primary><secondary>see=&quot;aussi clés et adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi clés et adresses&quot;</primary>
</indexterm>Ironiquement, le cryptage n&#39;est pas une partie importante du bitcoin, car ses communications et ses données de transaction ne sont pas cryptées et ne doivent être chiffrés pour protéger les fonds. Dans ce chapitre, nous présenterons une partie de la cryptographie utilisée dans le bitcoin pour contrôler la propriété des fonds, sous la forme de clés, d&#39;adresses et de portefeuilles.</simpara>
<section id="_présentation">
<title>Présentation</title>
<simpara><indexterm>
  <primary>&quot;clés numériques&quot;</primary><secondary>see=&quot;clés et adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;clés et adresses&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu&quot;</secondary><tertiary>id=&quot;KAover04&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu&quot;</primary><secondary>id=&quot;KAover04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;KAover04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;objet de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;objet de&quot;</primary>
</indexterm> La propriété du bitcoin est établie par le biais de <emphasis>clés numériques</emphasis>, <emphasis>adresses Bitcoin</emphasis> et <emphasis>signatures numériques</emphasis>. Les clés numériques ne sont pas réellement stockées dans le réseau, mais sont plutôt créées et stockées par les utilisateurs dans un fichier, ou une simple base de données, appelée <emphasis>wallet</emphasis>. Les clés numériques du portefeuille d&#39;un utilisateur sont totalement indépendantes du protocole Bitcoin et peuvent être générées et gérées par le logiciel du portefeuille de l&#39;utilisateur sans référence à la chaîne de blocs ni accès à Internet. Les clés permettent de nombreuses propriétés intéressantes du bitcoin, notamment la confiance et le contrôle décentralisés, l&#39;attestation de propriété et le modèle de sécurité à l&#39;épreuve de la cryptographie.</simpara>
<simpara>La plupart des transactions bitcoin nécessitent une signature numérique valide à inclure dans la chaîne de blocs, qui ne peut être générée qu&#39;avec une clé secrète ; par conséquent, toute personne possédant une copie de cette clé a le contrôle du bitcoin. <indexterm>
  <primary>&quot;témoins&quot;</primary>
</indexterm> La signature numérique utilisée pour dépenser des fonds est également appelée <emphasis>témoin</emphasis>, un terme utilisé en cryptographie. Les données témoins dans une transaction bitcoin témoignent de la véritable propriété des fonds dépensés.</simpara>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;paires de clés&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;paires de clés&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>see=&quot;aussi clés et adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi clés et adresses&quot;</primary>
</indexterm>Les clés sont fournies par paires constituées d&#39;une clé privée (secrète) et une clé publique. Considérez la clé publique comme similaire à un numéro de compte bancaire et la clé privée comme similaire au code PIN secret, ou à la signature d&#39;un chèque, qui permet de contrôler le compte. Ces clés numériques sont très rarement vues par les utilisateurs de bitcoin. Pour la plupart, ils sont stockés dans le fichier du portefeuille et gérés par le logiciel du portefeuille bitcoin.</simpara>
<simpara>Dans la partie paiement d&#39;une transaction bitcoin, la clé publique du destinataire est représentée par son empreinte numérique, appelée <emphasis>adresse Bitcoin</emphasis>, qui est utilisée de la même manière que le nom du bénéficiaire sur un chèque (c&#39;est-à-dire &quot;Payer à l&#39;ordre de&quot;) . Dans la plupart des cas, une adresse Bitcoin correspond et est générée à partir d&#8217;une clé publique. Cependant, toutes les adresses Bitcoin ne représentent pas des clés publiques ; ils peuvent également représenter d&#39;autres bénéficiaires tels que des scripts, comme nous le verrons plus loin dans ce chapitre. De cette manière, les adresses Bitcoin font abstraction du destinataire des fonds, ce qui rend les destinations de transaction flexibles, similaires aux chèques papier : un instrument de paiement unique qui peut être utilisé pour payer les comptes des personnes, payer les comptes de l&#39;entreprise, payer des factures ou payer en espèces. L&#39;adresse Bitcoin est la seule représentation des clés que les utilisateurs verront régulièrement, car c&#39;est la partie qu&#39;ils doivent partager avec le monde.</simpara>
<simpara>Tout d&#39;abord, nous présenterons la cryptographie et expliquerons les mathématiques utilisées dans le bitcoin. Ensuite, nous verrons comment les clés sont générées, stockées et gérées. Nous passerons en revue les différents formats de codage utilisés pour représenter les clés privées et publiques, les adresses et les adresses de script. Enfin, nous nous pencherons sur l&#39;utilisation avancée des clés et des adresses : adresses personnalisées, multisignatures, scripts et portefeuilles papier.</simpara>
<section id="_cryptographie_à_clé_publique_et_cryptomonnaie">
<title>Cryptographie à clé publique et cryptomonnaie</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>&quot;cryptographie à clé publique&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>&quot;cryptographie à clé publique&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;cryptographie à clé publique&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;monnaies numériques&quot;</primary><secondary>&quot;cryptomonnaie&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;cryptomonnaie&quot;</primary>
</indexterm>La cryptographie à clé publique a été inventée dans les années 1970 et constitue une base mathématique pour informatique et sécurité de l&#39;information.</simpara>
<simpara>Depuis l&#39;invention de la cryptographie à clé publique, plusieurs fonctions mathématiques appropriées, telles que l&#39;exponentiation des nombres premiers et la multiplication des courbes elliptiques, ont été découvertes. Ces fonctions mathématiques sont pratiquement irréversibles, ce qui signifie qu&#39;elles sont faciles à calculer dans un sens et impossibles à calculer dans le sens opposé. Sur la base de ces fonctions mathématiques, la cryptographie permet la création de secrets numériques et de signatures numériques infalsifiables. Bitcoin utilise la multiplication de courbes elliptiques comme base de sa cryptographie.</simpara>
<simpara>En bitcoin, nous utilisons la cryptographie à clé publique pour créer une paire de clés qui contrôle l&#39;accès au bitcoin. La paire de clés se compose d&#39;une clé privée et - dérivée de celle-ci - d&#39;une clé publique unique. La clé publique est utilisée pour recevoir des fonds et la clé privée est utilisée pour signer des transactions afin de dépenser les fonds.</simpara>
<simpara>Il existe une relation mathématique entre la clé publique et la clé privée qui permet d&#39;utiliser la clé privée pour générer des signatures sur les messages. Ces signatures peuvent être validées par rapport à la clé publique sans révéler la clé privée.</simpara>
<simpara>Lorsqu&#39;il dépense des bitcoins, le propriétaire actuel de bitcoins présente sa clé publique et une signature (différente à chaque fois, mais créée à partir de la même clé privée) dans une transaction pour dépenser ces bitcoins. Grâce à la présentation de la clé publique et de la signature, tous les membres du réseau Bitcoin peuvent vérifier et accepter la transaction comme valide, confirmant que la personne transférant le bitcoin en était propriétaire au moment du transfert.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>&quot;paires de clés&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>&quot;paires de clés&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;paires de clés&quot;</primary>
</indexterm> Dans la plupart des implémentations de portefeuille, les clés privées et publiques sont stockées ensemble sous la forme d&#39;une <emphasis>paire de clés</emphasis> pour plus de commodité. Cependant, la clé publique peut être calculée à partir de la clé privée, de sorte qu&#39;il est également possible de ne stocker que la clé privée.</simpara>
</tip>
</section>
<section id="private_public_keys">
<title>Clés privées et publiques</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>&quot;paires de clés privées et publiques&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>&quot;paires de clés privées et publiques&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;paires de clés privées et publiques&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cryptographie à courbe elliptique&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cryptographie&quot;</primary><secondary>&quot;cryptographie à courbe elliptique&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;cryptographie à courbe elliptique&quot;</primary>
</indexterm> Un portefeuille bitcoin contient une collection de paires de clés, chacune composée d&#39;une clé privée et d&#39;une clé publique. La clé privée (k) est un nombre, généralement choisi au hasard. A partir de la clé privée, nous utilisons la multiplication par courbe elliptique, une fonction cryptographique à sens unique, pour générer une clé publique (K). A partir de la clé publique (K), nous utilisons une fonction de hachage cryptographique unidirectionnelle pour générer une adresse Bitcoin (A). Dans cette section, nous commencerons par générer la clé privée, examinerons les mathématiques de la courbe elliptique utilisées pour la transformer en clé publique, et enfin, générerons une adresse Bitcoin à partir de la clé publique. La relation entre la clé privée, la clé publique et l&#39;adresse Bitcoin est indiquée dans <xref linkend="k_to_K_to_A"/>.</simpara>
<figure id="k_to_K_to_A"><title>Clé privée, clé publique et adresse Bitcoin</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0401.png"/>
  </imageobject>
  <textobject><phrase>privk_to_pubK_to_addressA</phrase></textobject>
</mediaobject>
</figure>
<sidebar>
<title>Pourquoi utiliser la cryptographie asymétrique (clés publiques/privées) ?</title>
<simpara><indexterm>
  <primary>&quot;cryptographie&quot;</primary><secondary>&quot;asymétrique&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;asymétrique&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;cryptographie asymétrique et&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;cryptographie asymétrique et&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cryptographie asymétrique&quot;</primary>
</indexterm>Pourquoi la cryptographie asymétrique est-elle utilisée dans le bitcoin ? Elle n&#39;est pas utilisée pour &quot;crypter&quot; (rendre secrètes) les transactions. Au contraire, la propriété utile de la cryptographie asymétrique est la capacité à générer des <emphasis>signatures numériques</emphasis>. Une clé privée peut être appliquée à l&#39;empreinte numérique d&#39;une transaction pour produire une signature numérique. Cette signature ne peut être produite que par une personne connaissant la clé privée. Cependant, toute personne ayant accès à la clé publique et à l&#39;empreinte digitale de la transaction peut les utiliser pour <emphasis>vérifier</emphasis> la signature. Cette propriété utile de la cryptographie asymétrique permet à quiconque de vérifier chaque signature sur chaque transaction, tout en garantissant que seuls les propriétaires de clés privées peuvent produire des signatures valides.</simpara>
</sidebar>
</section>
<section id="private_keys">
<title>Clés privées</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>&quot;génération de clé privée&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>&quot;génération de clé privée&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de clé privée&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;protection de clé privée&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;protection de clé privée&quot;</primary>
</indexterm>Une clé privée est simplement un nombre, choisi au hasard . La propriété et le contrôle de la clé privée sont à la base du contrôle de l&#39;utilisateur sur tous les fonds associés à l&#39;adresse Bitcoin correspondante. La clé privée est utilisée pour créer des signatures nécessaires pour dépenser des bitcoins en prouvant la propriété des fonds utilisés dans une transaction. La clé privée doit rester secrète à tout moment, car la révéler à des tiers équivaut à leur donner le contrôle sur le bitcoin sécurisé par cette clé. La clé privée doit également être sauvegardée et protégée contre toute perte accidentelle, car si elle est perdue, elle ne peut pas être récupérée et les fonds qu&#39;elle garantit sont également perdus à jamais.</simpara>
<tip>
<simpara>La clé privée bitcoin n&#39;est qu&#39;un nombre. Vous pouvez choisir vos clés privées au hasard en utilisant simplement une pièce de monnaie, un crayon et du papier : lancez une pièce 256 fois et vous avez les chiffres binaires d&#39;une clé privée aléatoire que vous pouvez utiliser dans un portefeuille bitcoin. La clé publique peut alors être générée à partir de la clé privée.</simpara>
</tip>
<section id="_générer_une_clé_privée_à_partir_d_39_un_nombre_aléatoire">
<title>Générer une clé privée à partir d&#39;un nombre aléatoire</title>
<simpara>La première et la plus importante étape de la génération de clés consiste à trouver une source sécurisée d&#39;entropie ou de caractère aléatoire. La création d&#39;une clé bitcoin est essentiellement la même que &quot;Choisissez un nombre entre 1 et 2 <superscript> 256 </superscript>&quot;. La méthode exacte que vous utilisez pour choisir ce nombre n&#39;a pas d&#39;importance tant qu&#39;elle n&#39;est pas prévisible ou reproductible. Le logiciel Bitcoin utilise les générateurs de nombres aléatoires du système d&#39;exploitation sous-jacent pour produire 256 bits d&#39;entropie (aléatoire). Habituellement, le générateur de nombres aléatoires du système d&#39;exploitation est initialisé par une source humaine d&#39;aléatoire, c&#39;est pourquoi il peut vous être demandé de remuer votre souris pendant quelques secondes.</simpara>
<simpara>Plus précisément, la clé privée peut être n&#39;importe quel nombre compris entre <literal>0</literal> et <literal>n - 1</literal> inclus, où n est une constante (n = 1,1578 * 10<superscript>77</superscript>, légèrement inférieure à 2<superscript>256</superscript>) définie comme l&#39;ordre de la courbe elliptique utilisée dans le bitcoin (voir <xref linkend="elliptic_curve"/>). Pour créer une telle clé, nous choisissons au hasard un nombre de 256 bits et vérifions qu&#39;il est inférieur à <literal>n</literal>. En termes de programmation, cela est généralement réalisé en alimentant une plus grande chaîne de bits aléatoires, collectés à partir d&#39;une source aléatoire sécurisée par cryptographie, dans l&#39;algorithme de hachage SHA256, qui produira commodément un nombre de 256 bits. Si le résultat est inférieur à <literal>n</literal>, nous avons une clé privée appropriée. Sinon, nous réessayons simplement avec un autre nombre aléatoire.</simpara>
<warning>
<simpara><indexterm>
  <primary>&quot;nombres aléatoires&quot;</primary><secondary>&quot;génération de nombres aléatoires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de nombres aléatoires&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;entropie&quot;</primary><secondary>&quot;génération de nombres aléatoires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de nombres aléatoires&quot;</primary>
</indexterm>N&#39;écrivez pas votre propre code pour créer un nombre aléatoire ou n&#8217;utilisez pas un nombre aléatoire &quot;simple&quot; généré par votre langage de programmation. Utilisez un générateur de nombres pseudo-aléatoires cryptographiquement sécurisé (CSPRNG) avec une valeur d&#8217;amorçage provenant d&#39;une source d&#39;entropie suffisante. Étudiez la documentation de la bibliothèque de générateurs de nombres aléatoires que vous choisissez pour vous assurer qu&#39;elle est cryptographiquement sécurisée. La mise en œuvre correcte du CSPRNG est essentielle à la sécurité des clés.</simpara>
</warning>
<simpara>Ce qui suit est une clé privée générée aléatoirement (k) affichée au format hexadécimal (256 bits affichés sous la forme de 64 chiffres hexadécimaux, chacun de 4 bits) :</simpara>
<screen>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</screen>
<tip>
<simpara>La taille de l&#39;espace de clé privée de bitcoin, (2 <superscript> 256</superscript>) est un nombre insondable. Il est d&#39;environ 10<superscript>77</superscript> en décimal. À titre de comparaison, on estime que l&#39;univers visible contient 10<superscript>80</superscript> atomes.</simpara>
</tip>
<simpara><indexterm>
  <primary>&quot;commande dumpprivkey&quot;</primary>
</indexterm>Pour générer une nouvelle clé avec le client Bitcoin Core (voir <xref linkend="ch03_bitcoin_client"/>), utilisez la commande <literal>getnewaddress</literal>. Pour des raisons de sécurité, il affiche uniquement l&#39;adresse, pas la clé privée. Pour demander à <literal>bitcoind</literal> d&#39;exposer la clé privée, utilisez la commande <literal>dumpprivkey</literal>. La commande <literal>dumpprivkey</literal> affiche la clé privée dans un format de somme de contrôle Base58 appelé <emphasis>Wallet Import Format</emphasis> (WIF ou format d&#8217;importation de portefeuille), que nous examinerons plus en détail dans <xref linkend="priv_formats"/>. Voici un exemple de génération et d&#39;affichage d&#39;une clé privée à l&#39;aide de ces deux commandes :</simpara>
<screen>$ bitcoin-cli getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</screen>
<simpara>La commande <literal>dumpprivkey</literal> ouvre le portefeuille et extrait la clé privée qui a été générée par la commande <literal>getnewaddress</literal>. Il n&#39;est pas possible pour <literal>bitcoind</literal> de connaître la clé privée à partir de l&#39;adresse à moins qu&#39;elles ne soient toutes deux stockées dans le portefeuille.</simpara>
<tip>
<simpara>La commande <literal>dumpprivkey</literal> ne génère pas de clé privée à partir d&#39;une adresse, car cela est impossible. La commande révèle simplement la clé privée qui est déjà connue du portefeuille et qui a été générée par la commande <literal>getnewaddress</literal>.</simpara>
</tip>
<simpara role="pagebreak-before">Vous pouvez également utiliser l&#39;outil de ligne de commande Bitcoin Explorer (voir <xref linkend="appdx_bx"/>) pour générer et afficher des clés privées avec les commandes <literal>seed</literal>, <literal>ec-new</literal> et <literal>ec-to-wif</literal> :</simpara>
<screen>$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</screen>
</section>
</section>
<section id="pubkey">
<title>Clés publiques</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>&quot;calcul de la clé publique&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>&quot;calcul de la clé publique&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;calcul de la clé publique&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;point générateur&quot;</primary>
</indexterm>La clé publique est calculée à partir de la clé privée en utilisant la multiplication par courbe elliptique, qui est irréversible : <emphasis>K</emphasis> = <emphasis>k</emphasis> * <emphasis>G</emphasis>, où <emphasis>k</emphasis> est la clé privée, <emphasis>G</emphasis> est un point constant appelé <emphasis>point générateur</emphasis> et <emphasis>K</emphasis> est la clé publique résultante. L&#39;opération inverse, connue sous le nom de &quot;trouver le logarithme discret&quot; - calculer <emphasis>k</emphasis> si vous connaissez <emphasis>K</emphasis> - est aussi difficile que d&#39;essayer toutes les valeurs possibles de <emphasis>k</emphasis>, c&#39;est-à-dire par une recherche par force brute. Avant de montrer comment générer une clé publique à partir d&#39;une clé privée, examinons un peu plus en détail la cryptographie à courbe elliptique.</simpara>
<tip>
<simpara>La multiplication de courbe elliptique est un type de fonction que les cryptographes appellent une fonction « à sens unique » : elle est facile à faire dans un sens (multiplication) et impossible à faire dans le sens inverse (« division », ou trouver le logarithme discret). Le propriétaire de la clé privée peut facilement créer la clé publique, puis la partager avec le monde entier, sachant que personne ne peut inverser la fonction et calculer la clé privée à partir de la clé publique. Cette astuce mathématique devient la base de signatures numériques infalsifiables et sécurisées qui prouvent la propriété des fonds bitcoin.</simpara>
</tip>
</section>
<section id="elliptic_curve">
<title>La cryptographie à courbe elliptique expliquée</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>&quot;cryptographie à courbe elliptique&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>&quot;cryptographie à courbe elliptique&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;cryptographie à courbe elliptique&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cryptographie à courbe elliptique&quot;</primary><secondary>id=&quot;eliptic04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;eliptic04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cryptographie&quot;</primary><secondary>&quot;cryptographie à courbe elliptique &quot;</secondary><tertiary>id=&quot;Celliptic04&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;cryptographie à courbe elliptique &quot;</primary><secondary>id=&quot;Celliptic04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Celliptic04&quot;</primary>
</indexterm> La cryptographie à courbe elliptique est un type de cryptographie asymétrique ou à clé publique basée sur le problème du logarithme discret exprimé par addition et multiplication sur les points d&#39;une courbe elliptique.</simpara>
<simpara><xref linkend="ecc-curve"/> est un exemple de courbe elliptique, similaire à celle utilisée par le bitcoin.</simpara>
<figure id="ecc-curve" role="smallerthirty"><title>Une courbe elliptique</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0402.png"/>
  </imageobject>
  <textobject><phrase>ecc-curve</phrase></textobject>
</mediaobject>
</figure>
<simpara>Bitcoin utilise une courbe elliptique spécifique et un ensemble de constantes mathématiques, telles que définies dans une norme appelée <literal>secp256k1</literal>, établie par le National Institute of Standards and Technology (NIST). La courbe <literal>secp256k1</literal> est définie par la fonction suivante, qui produit une courbe elliptique :</simpara>
<informalequation>
<alt><![CDATA[\[\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}\]]]></alt>
<mediaobject><textobject><phrase></phrase></textobject></mediaobject>
</informalequation>
<simpara>ou</simpara>
<informalequation>
<alt><![CDATA[\[\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}\]]]></alt>
<mediaobject><textobject><phrase></phrase></textobject></mediaobject>
</informalequation>
<simpara></simpara>
<simpara>Parce que cette courbe est définie sur un champ fini d&#39;ordre premier au lieu de sur les nombres réels, elle ressemble à un motif de points dispersés en deux dimensions, ce qui la rend difficile à visualiser. Cependant, le calcul est identique à celui d&#39;une courbe elliptique sur des nombres réels. A titre d&#39;exemple, <xref linkend="ecc-over-F17-math"/> montre la même courbe elliptique sur un champ fini beaucoup plus petit d&#39;ordre premier 17, montrant un motif de points sur une grille. La courbe elliptique du bitcoin <literal>secp256k1</literal> peut être considérée comme un motif beaucoup plus complexe de points sur une grille insondable.</simpara>
<figure id="ecc-over-F17-math" role="smallersixty"><title>Cryptographie sur courbe elliptique : visualisation d&#39;une courbe elliptique sur F(p), avec p=17</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0403.png"/>
  </imageobject>
  <textobject><phrase>ecc-over-F17-math</phrase></textobject>
</mediaobject>
</figure>
<simpara>Ainsi, par exemple, ce qui suit est un point P de coordonnées (x,y) qui est un point sur la courbe <literal>secp256k1</literal> :</simpara>
<screen>P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)</screen>
<simpara><xref linkend="example_4_1"/> montre comment vous pouvez vérifier cela vous-même en utilisant Python :</simpara>
<example id="example_4_1">
<title>Utiliser Python pour confirmer que ce point est sur la courbe elliptique</title>
<programlisting language="pycon" linenumbering="unnumbered">Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
&gt;&gt;&gt; x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
&gt;&gt;&gt; y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
&gt;&gt;&gt; (x ** 3 + 7 - y**2) % p
0</programlisting>
</example>
<simpara>Dans les mathématiques des courbes elliptiques, il existe un point appelé le &quot;point à l&#39;infini&quot;, qui correspond à peu près au rôle de zéro. Sur les ordinateurs, il est parfois représenté par x = y = 0 (ce qui ne satisfait pas l&#39;équation de la courbe elliptique, mais c&#39;est un cas séparé facile qui peut être vérifié).</simpara>
<simpara>Il existe également un opérateur +, appelé &quot;addition&quot;, qui possède certaines propriétés similaires à l&#39;addition traditionnelle de nombres réels apprise par les élèves du primaire. Étant donné deux points P<subscript>1</subscript> et P<subscript>2</subscript> sur la courbe elliptique, il existe un troisième point P<subscript>3</subscript> = P<subscript>1</subscript> + P<subscript>2</subscript>, également sur la courbe elliptique.</simpara>
<simpara>Géométriquement, ce troisième point P<subscript>3</subscript> est calculé en traçant une ligne entre P<subscript>1</subscript> et P<subscript>2</subscript>. Cette ligne coupera la courbe elliptique exactement à un endroit supplémentaire. Appelons ce point P<subscript>3</subscript> = (x, y). Renvoyé ensuite sur l&#39;axe des x pour obtenir P<subscript>3</subscript> = (x, –y).</simpara>
<simpara>Il y a quelques cas particuliers qui expliquent la nécessité du &quot;point à l&#39;infini&quot;.</simpara>
<simpara>Si P<subscript>1</subscript> et P<subscript>2</subscript> sont le même point, la ligne &quot;entre&quot; P<subscript>1</subscript> et P<subscript>2</subscript> doit s&#39;étendre pour être la tangente sur la courbe en ce point P<subscript>1</subscript>. Cette tangente coupera la courbe en exactement un nouveau point. Vous pouvez utiliser des techniques de calcul pour déterminer la pente de la ligne tangente. Ces techniques fonctionnent curieusement, même si nous restreignons notre intérêt aux points de la courbe à deux coordonnées entières !</simpara>
<simpara>Dans certains cas (par exemple, si P<subscript>1</subscript> et P<subscript>2</subscript> ont les mêmes valeurs x mais des valeurs y différentes), la ligne entre P<subscript>1</subscript> et P<subscript>2</subscript> sera exactement verticale, auquel cas P<subscript>3 </subscript> = &quot;point à l&#39;infini.&quot;</simpara>
<simpara>Si P<subscript>1</subscript> est le &quot;point à l&#39;infini&quot;, alors P<subscript>1</subscript> + P<subscript>2</subscript> = P<subscript>2</subscript>. De même, si P<subscript>2</subscript> est le point à l&#39;infini, alors P<subscript>1</subscript> + P<subscript>2</subscript> = P<subscript>1</subscript>. Cela montre comment le point à l&#39;infini joue le rôle de zéro.</simpara>
<simpara>Il s&#39;avère que + est associatif, ce qui signifie que (A + B) + C = A + (B + C). Cela signifie que nous pouvons écrire A + B + C sans parenthèses et sans ambiguïté.</simpara>
<simpara>Maintenant que nous avons défini l&#39;addition, nous pouvons définir la multiplication de la manière standard qui extensionne l&#39;addition. Pour un point P sur la courbe elliptique, si k est un nombre entier, alors kP = P + P + P + &#8230; + P (k fois). Notez que k est parfois appelé un &quot;exposant&quot; dans ce cas.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;eliptic04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;eliptic04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Celliptic04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Celliptic04&quot;</primary>
</indexterm></simpara>
</section>
<section id="public_key_derivation">
<title>Génération d&#39;une clé publique</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;aperçu de&quot;</secondary><tertiary>&quot;génération de clé publique&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;aperçu de&quot;</primary><secondary>&quot;génération de clé publique&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de clé publique&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;point générateur&quot;</primary>
</indexterm>En partant d&#39;une clé privée sous la forme d&#39;un nombre généré aléatoirement <emphasis>k</emphasis>, nous la multiplions par un point prédéterminé sur la courbe appelé <emphasis>point générateur</emphasis> <emphasis>G</emphasis> pour produire un autre point ailleurs sur la courbe, qui est la clé publique correspondante <emphasis>K</emphasis>. Le point générateur est spécifié dans le cadre de la norme <literal>secp256k1</literal> et est toujours le même pour toutes les clés en bitcoin :</simpara>
<informalequation>
<alt><![CDATA[\[\begin{equation}
{K = k * G}
\end{equation}\]]]></alt>
<mediaobject><textobject><phrase></phrase></textobject></mediaobject>
</informalequation>
<simpara>où <emphasis>k</emphasis> est la clé privée, <emphasis>G</emphasis> est le point générateur et <emphasis>K</emphasis> est la clé publique résultante, un point sur la courbe. Comme le point générateur est toujours le même pour tous les utilisateurs de bitcoins, une clé privée <emphasis>k</emphasis> multipliée par <emphasis>G</emphasis> donnera toujours la même clé publique <emphasis>K</emphasis>. La relation entre <emphasis>k</emphasis> et <emphasis>K</emphasis> est fixe, mais ne peut être calculée que dans un sens, de <emphasis>k</emphasis> vers <emphasis>K</emphasis>. C&#39;est pourquoi une adresse Bitcoin (dérivée de <emphasis>K</emphasis>) peut être partagée avec n&#39;importe qui et ne révèle pas la clé privée de l&#39;utilisateur (<emphasis>k</emphasis>).</simpara>
<tip>
<simpara>Une clé privée peut être convertie en clé publique, mais une clé publique ne peut pas être reconvertie en clé privée car le calcul ne fonctionne que dans un sens.</simpara>
</tip>
<simpara>En implémentant la multiplication par courbe elliptique, nous prenons la clé privée <emphasis>k</emphasis> générée précédemment et la multiplions avec le point générateur G pour trouver la clé publique <emphasis>K</emphasis> :</simpara>
<screen>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</screen>
<simpara>La clé publique <emphasis>K</emphasis> est définie comme un point <literal>K = (x,y)</literal> :</simpara>
<screen>K = (x, y)

où,

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</screen>
<simpara>Pour visualiser la multiplication d&#39;un point avec un nombre entier, nous utiliserons la courbe elliptique plus simple sur des nombres réels - rappelez-vous, le calcul est le même. Notre objectif est de trouver le multiple <emphasis>kG</emphasis> du point générateur <emphasis>G</emphasis>, ce qui revient à ajouter <emphasis>G</emphasis> à lui-même, <emphasis>k</emphasis> fois de suite. Dans les courbes elliptiques, l&#39;ajout d&#39;un point à lui-même équivaut à tracer une ligne tangente sur le point et à trouver à nouveau l&#39;endroit où il coupe la courbe, puis à refléter ce point sur l&#39;axe des x.</simpara>
<simpara><xref linkend="ecc_illustrated"/> montre le processus de dérivation de <emphasis>G</emphasis>, <emphasis>2G</emphasis>, <emphasis>4G</emphasis> et <emphasis>8G</emphasis> en tant qu&#39;opération géométrique sur la courbe.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;bibliothèque C optimisée secp256k1&quot;</primary>
</indexterm>Bitcoin utilise la <ulink url="https://github.com/bitcoin-core/secp256k1">bibliothèque C optimisée secp256k1</ulink> pour effectuer les calculs de la courbe elliptique.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;KAover04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;KAover04&quot;</primary>
</indexterm></simpara>
</tip>
<figure id="ecc_illustrated"><title>Cryptographie sur courbe elliptique : visualisation de la multiplication d&#39;un point G par un entier k sur une courbe elliptique</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0404.png"/>
  </imageobject>
  <textobject><phrase>ecc_illustrated</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="_adresses_bitcoin">
<title>Adresses Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;adresses Bitcoin&quot;</secondary><tertiary>id=&quot;KAaddress04&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;adresses Bitcoin&quot;</primary><secondary>id=&quot;KAaddress04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;KAaddress04&quot;</primary>
</indexterm>Une adresse Bitcoin est une chaîne de chiffres et de caractères qui peut être partagée avec toute personne souhaitant vous envoyer de l&#39;argent. Les adresses produites à partir de clés publiques consistent en une chaîne de chiffres et de lettres commençant par le chiffre &quot;1&quot;. Voici un exemple d&#39;adresse Bitcoin :</simpara>
<screen>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</screen>
<simpara>L&#39;adresse Bitcoin est ce qui apparaît le plus souvent dans une transaction en tant que &quot;destinataire&quot; des fonds. Si nous comparons une transaction bitcoin à un chèque papier, l&#39;adresse Bitcoin est le bénéficiaire, c&#39;est ce que nous écrivons sur la ligne après &quot;Payer à l&#39;ordre de&quot;. Sur un chèque papier, ce bénéficiaire peut parfois être le nom d&#39;un titulaire de compte bancaire, mais peut également inclure des sociétés, des institutions ou même des espèces. Étant donné que les chèques papier n&#39;ont pas besoin de spécifier un compte, mais utilisent plutôt un nom abstrait en tant que destinataire des fonds, ce sont des instruments de paiement très flexibles. Les transactions Bitcoin utilisent une abstraction similaire, l&#39;adresse Bitcoin, pour les rendre très flexibles. Une adresse Bitcoin peut représenter le propriétaire d&#39;une paire de clés privée/publique, ou elle peut représenter autre chose, comme un script de paiement, comme nous le verrons dans <xref linkend="p2sh"/>. Pour l&#39;instant, examinons le cas simple; une adresse Bitcoin qui représente et est dérivée d&#39;une clé publique.</simpara>
<simpara><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>&quot;algorithmes utilisés pour créer&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;algorithmes utilisés pour créer&quot;</primary>
</indexterm>L&#39;adresse Bitcoin est dérivée de la clé publique grâce à l&#39;utilisation d&#39;un hachage cryptographique unidirectionnel. Un &quot;algorithme de hachage&quot; ou simplement &quot;algorithme de hachage&quot; est une fonction à sens unique qui produit une empreinte digitale ou un &quot;hachage&quot; (ou un &quot;résultat de hachage&quot;) d&#39;une entrée de taille arbitraire. Les fonctions de hachage cryptographiques sont largement utilisées dans le bitcoin : dans les adresses Bitcoin, dans les adresses de script et dans l&#39;algorithme de minage de preuve de travail. Les algorithmes utilisés pour créer une adresse Bitcoin à partir d&#39;une clé publique sont le Secure Hash Algorithm (SHA) et le RACE Integrity Primitives Evaluation Message Digest (RIPEMD), ou plus précisément SHA256 et RIPEMD160.</simpara>
<simpara>En commençant par la clé publique <emphasis>K</emphasis>, nous calculons le hachage SHA256, puis calculons le hachage RIPEMD160 du résultat, produisant un nombre de 160 bits (20 octets) :</simpara>
<informalequation>
<alt><![CDATA[\[\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}\]]]></alt>
<mediaobject><textobject><phrase></phrase></textobject></mediaobject>
</informalequation>
<simpara>où <emphasis>K</emphasis> est la clé publique et <emphasis>A</emphasis> est l&#39;adresse Bitcoin résultante.</simpara>
<tip>
<simpara>Une adresse Bitcoin n&#39;est <emphasis>pas</emphasis> la même chose qu&#39;une clé publique. Les adresses Bitcoin sont dérivées d&#39;une clé publique à l&#39;aide d&#39;une fonction unidirectionnelle.</simpara>
</tip>
<simpara>Les adresses Bitcoin sont presque toujours encodées en &quot;Base58Check&quot; (voir <xref linkend="base58"/>), qui utilise 58 caractères (un système de numérotation Base58) et une somme de contrôle pour faciliter la lisibilité humaine, éviter toute ambiguïté et protéger contre les erreurs de transcription et de saisie d&#39;adresse. Base58Check est également utilisé de nombreuses autres manières dans Bitcoin, par exemple lorsque chaque fois qu&#39;un utilisateur a besoin de lire et de transcrire correctement un numéro, tel qu&#39;une adresse Bitcoin, une clé privée, une clé cryptée ou un hachage de script. Dans la section suivante, nous examinerons les mécanismes d&#39;encodage et de décodage Base58Check et les représentations qui en résultent. <xref linkend="pubkey_to_address"/> illustre la conversion d&#39;une clé publique en une adresse Bitcoin.</simpara>
<figure id="pubkey_to_address"><title>Clé publique vers adresse Bitcoin : conversion d&#39;une clé publique en adresse Bitcoin</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0405.png"/>
  </imageobject>
  <textobject><phrase>pubkey_to_address</phrase></textobject>
</mediaobject>
</figure>
<section id="base58">
<title>Encodage Base58 et Base58Check</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;adresses Bitcoin&quot;</secondary><tertiary>&quot;encodage Base58 et Base58check&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;adresses Bitcoin&quot;</primary><secondary>&quot;encodage Base58 et Base58check&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;encodage Base58 et Base58check&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Encodage Base58 et Base58check&quot;</primary><secondary>id=&quot;base5804&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;base5804&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>&quot;encodage Base58 et Base58check&quot;</secondary><tertiary>id=&quot;Abase5804&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;encodage Base58 et Base58check&quot;</primary><secondary>id=&quot;Abase5804&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Abase5804&quot;</primary>
</indexterm> Afin de représenter les nombres longs de manière compacte, en utilisant moins de symboles, de nombreux systèmes informatiques utilisent des représentations alphanumériques mixtes avec une base supérieure à 10. Par exemple, alors que le système décimal traditionnel utilise les 10 chiffres de 0 à 9, le système hexadécimal utilise 16, avec les lettres A à F comme six symboles supplémentaires. Un nombre représenté au format hexadécimal est plus court que la représentation décimale équivalente. Encore plus compacte, la représentation Base64 utilise 26 lettres minuscules, 26 lettres majuscules, 10 chiffres et 2 caractères supplémentaires tels que &quot;<literal>+</literal>&quot; et &quot;/&quot; pour transmettre des données binaires sur des supports textuels tels que le courrier électronique. Base64 est le plus couramment utilisé pour ajouter des pièces jointes binaires aux e-mails. Base58 est un format de codage binaire basé sur du texte développé pour être utilisé dans le bitcoin et utilisé dans de nombreuses autres cryptomonnaies. Il offre un équilibre entre représentation compacte, lisibilité et détection et prévention des erreurs. Base58 est un sous-ensemble de Base64, utilisant des lettres et des chiffres majuscules et minuscules, mais omettant certains caractères qui sont fréquemment confondus et qui peuvent apparaître identiques lorsqu&#39;ils sont affichés dans certaines polices. Plus précisément, Base58 est Base64 sans le 0 (chiffre zéro), O (o majuscule), l (L inférieur), I (i majuscule) et les symboles &quot;<literal>+</literal>&quot; et &quot;/&quot;. Ou, plus simplement, c&#39;est un ensemble de lettres minuscules et majuscules et de chiffres sans les quatre (0, O, l, I) que nous venons de mentionner. <xref linkend="base58alphabet"/> affiche l&#39;alphabet Base58 complet.</simpara>
<simpara id="base58alphabet">Alphabet Base58 de .Bitcoin</simpara>
<informalexample>
<screen>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</screen>
</informalexample>
<simpara>Pour ajouter une sécurité supplémentaire contre les fautes de frappe ou les erreurs de transcription, Base58Check est un format d&#39;encodage Base58, fréquemment utilisé dans le bitcoin, qui possède un code de vérification des erreurs intégré. La somme de contrôle est constituée de quatre octets supplémentaires ajoutés à la fin des données en cours de codage. La somme de contrôle est dérivée du hachage des données codées et peut donc être utilisée pour détecter et prévenir les erreurs de transcription et de frappe. Lorsqu&#39;il est présenté avec le code Base58Check, le logiciel de décodage calcule la somme de contrôle des données et la compare à la somme de contrôle incluse dans le code. Si les deux ne correspondent pas, une erreur a été introduite et les données Base58Check ne sont pas valides. Cela empêche qu&#39;une adresse Bitcoin mal saisie soit acceptée par le logiciel du portefeuille comme destination valide, une erreur qui entraînerait autrement une perte de fonds.</simpara>
<simpara>Pour convertir des données (un nombre) dans un format Base58Check, nous ajoutons d&#39;abord un préfixe aux données, appelé &quot;octet de version&quot;, qui sert à identifier facilement le type de données encodées. Par exemple, dans le cas d&#39;une adresse Bitcoin, le préfixe est zéro (0x00 en hexadécimal), alors que le préfixe utilisé lors de l&#39;encodage d&#39;une clé privée est 128 (0x80 en hexadécimal). Une liste des préfixes de version courants est affichée dans <xref linkend="base58check_versions"/>.</simpara>
<simpara>Ensuite, nous calculons la somme de contrôle &quot;double-SHA&quot;, ce qui signifie que nous appliquons l&#39;algorithme de hachage SHA256 deux fois sur le résultat précédent (préfixe et données):</simpara>
<screen>somme de contrôle (checksum) = SHA256(SHA256(préfixe+données))</screen>
<simpara>À partir du hachage de 32 octets résultant (hachag-d&#8217;un-hachage), nous ne prenons que les quatre premiers octets. Ces quatre octets servent de code de contrôle d&#39;erreur ou de somme de contrôle (checksum). La somme de contrôle est concaténée (ajoutée) à la fin.</simpara>
<simpara>Le résultat est composé de trois éléments : un préfixe, les données et une somme de contrôle. Ce résultat est encodé en utilisant l&#39;alphabet Base58 décrit précédemment. <xref linkend="base58check_encoding"/> illustre le processus d&#39;encodage Base58Check.</simpara>
<simpara id="base58check_encoding">Encodage .Base58Check : un format Base58, versionné et à somme de contrôle pour encoder sans ambiguïté les données bitcoin
<inlinemediaobject>
  <imageobject>
  <imagedata fileref=":images/mbc2_0406.png"/>
  </imageobject>
  <textobject><phrase>Base58CheckEncoding</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>En bitcoin, la plupart des données présentées à l&#39;utilisateur sont encodées en Base58Check pour les rendre compactes, faciles à lire et faciles à détecter les erreurs. Le préfixe de version dans l&#39;encodage Base58Check est utilisé pour créer des formats faciles à distinguer qui, lorsqu&#39;ils sont encodés en Base58, contiennent des caractères spécifiques au début de la charge utile encodée en Base58Check. Ces caractères permettent aux humains d&#39;identifier facilement le type de données codées et comment les utiliser. C&#39;est ce qui différencie, par exemple, une adresse Bitcoin encodée en Base58Check qui commence par un 1 d&#39;une clé privée WIF encodée en Base58Check qui commence par un 5. Quelques exemples de préfixes de version et les caractères Base58 résultants sont affichés dans <xref linkend="base58check_versions"/>.</simpara>
<table id="base58check_versions"
frame="all"
rowsep="1" colsep="1"
>
<title>Base58Check préfixe de version et exemples de résultats encodés</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top"> Préfixe de version (hex)</entry>
<entry align="left" valign="top"> Préfixe de résultat Base58</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Adresse Bitcoin</simpara></entry>
<entry align="left" valign="top"><simpara>0x00</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse de hachage Pay-to-Script</simpara></entry>
<entry align="left" valign="top"><simpara>0x05</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse de test Bitcoin</simpara></entry>
<entry align="left" valign="top"><simpara>0x6F</simpara></entry>
<entry align="left" valign="top"><simpara>m ou n</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Clé privée WIF</simpara></entry>
<entry align="left" valign="top"><simpara>0x80</simpara></entry>
<entry align="left" valign="top"><simpara>5, K ou L</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Clé privée cryptée BIP-38</simpara></entry>
<entry align="left" valign="top"><simpara>0x0142</simpara></entry>
<entry align="left" valign="top"><simpara>6P</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Clé publique étendue BIP-32</simpara></entry>
<entry align="left" valign="top"><simpara>0x0488B21E</simpara></entry>
<entry align="left" valign="top"><simpara>xpub</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="_formats_de_clé">
<title>Formats de clé</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;adresses Bitcoin&quot;</secondary><tertiary>&quot;formats de clés&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;adresses Bitcoin&quot;</primary><secondary>&quot;formats de clés&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;formats de clés&quot;</primary>
</indexterm> Les clés privées et publiques peuvent être représentées dans un certain nombre de formats différents. Ces représentations codent tous le même nombre, même si elles semblent différentes. Ces formats sont principalement utilisés pour faciliter la lecture et la transcription des clés sans introduire d&#39;erreurs.</simpara>
<section id="priv_formats">
<title>Formats de clé privée</title>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;formats de clé privée&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;formats de clé privée&quot;</primary>
</indexterm> La clé privée peut être représentée dans un certain nombre de formats différents, qui correspondent tous au même nombre de 256 bits. <xref linkend="table_4-2"/> montre trois formats courants utilisés pour représenter les clés privées. Différents formats sont utilisés dans différentes circonstances. Les formats binaires hexadécimaux et bruts sont utilisés en interne dans les logiciels et rarement montrés aux utilisateurs. Le WIF est utilisé pour l&#39;importation/exportation de clés entre portefeuilles et souvent utilisé dans les représentations de code QR (code-barres) des clés privées.</simpara>
<table id="table_4-2"
frame="all"
rowsep="1" colsep="1"
>
<title>Représentations de clés privées (formats d&#39;encodage)</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Préfixe</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Brut</simpara></entry>
<entry align="left" valign="top"><simpara>Aucun</simpara></entry>
<entry align="left" valign="top"><simpara>32 octets</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hex</simpara></entry>
<entry align="left" valign="top"><simpara>Aucun</simpara></entry>
<entry align="left" valign="top"><simpara>64 chiffres hexadécimaux</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WIF</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>Encodage Base58Check : Base58 avec préfixe de version 0x80 et somme de contrôle de 4 octets</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WIF compressé</simpara></entry>
<entry align="left" valign="top"><simpara>K ou L</simpara></entry>
<entry align="left" valign="top"><simpara>Comme ci-dessus, avec le suffixe ajouté 0x01 avant l&#39;encodage</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><xref linkend="table_4-3"/> affiche la clé privée générée dans ces trois formats.</simpara>
<table id="table_4-3"
frame="all"
rowsep="1" colsep="1"
>
<title>Exemple : même clé, différents formats</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Format </entry>
<entry align="left" valign="top"> Clé privée</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Hex</simpara></entry>
<entry align="left" valign="top"><simpara>1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WIF</simpara></entry>
<entry align="left" valign="top"><simpara>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WIF compressé</simpara></entry>
<entry align="left" valign="top"><simpara>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Toutes ces représentations sont des manières différentes de montrer le même numéro, la même clé privée. Ils semblent différents, mais n&#39;importe quel format peut facilement être converti en n&#39;importe quel autre format. Notez que le &quot;binaire brut&quot; n&#39;est pas affiché dans <xref linkend="table_4-3"/> car tout encodage à afficher ici ne serait, par définition, pas une donnée binaire brute.</simpara>
<simpara>Nous utilisons la commande <literal>wif-to-ec</literal> de Bitcoin Explorer (voir <xref linkend="appdx_bx"/>) pour montrer que les deux clés WIF représentent la même clé privée :</simpara>
<screen>$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</screen>
</section>
<section id="_décoder_à_partir_de_base58check">
<title>Décoder à partir de Base58Check</title>
<simpara>Les commandes de Bitcoin Explorer (voir <xref linkend="appdx_bx"/>) facilitent l&#39;écriture de scripts interface système (ou shell) à l&#8217;aide d'&quot;opérateurs de transfert de données&quot; en ligne de commande (ou &quot;command-line pipes&quot;) qui manipulent les clés, les adresses et les transactions bitcoin. Vous pouvez utiliser Bitcoin Explorer pour décoder le format Base58Check sur la ligne de commande.</simpara>
<simpara>Nous utilisons la commande <literal>base58check-decode</literal> pour décoder la clé non compressée :</simpara>
<screen>$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}</screen>
<simpara>Le résultat contient la clé comme charge utile (payload), le préfixe de version WIF 128 et une somme de contrôle (checksum).</simpara>
<simpara>Notez que la &quot;charge utile&quot; (ou &quot;payload&quot;) de la clé compressée est ajoutée avec le suffixe <literal>01</literal>, signalant que la clé publique dérivée doit être compressée :</simpara>
<screen>$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}</screen>
</section>
<section id="_encoder_de_l_39_hex_vers_base58check">
<title>Encoder de l&#39;hex vers Base58Check</title>
<simpara>Pour encoder en Base58Check (l&#39;inverse de la commande précédente), nous utilisons la commande <literal>base58check-encode</literal> de Bitcoin Explorer (voir <xref linkend="appdx_bx"/>) et indiquez la clé privée hexadécimale, suivie du préfixe de version WIF 128 :</simpara>
<screen>bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</screen>
</section>
<section id="_encoder_de_l_39_hex_clé_compressée_à_base58check">
<title>Encoder de l&#39;hex (clé compressée) à Base58Check</title>
<simpara>Pour encoder dans Base58Check comme une clé privée &quot;compressée&quot; (voir <xref linkend="comp_priv"/>), nous ajoutons le suffixe <literal>01</literal> à la clé hexadécimale puis encodons comme dans la section précédente :</simpara>
<screen>$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</screen>
<simpara>Le format compressé WIF résultant commence par un &quot;K&quot;. Cela indique que la clé privée à l&#39;intérieur a un suffixe de &quot;01&quot; et sera utilisée pour produire des clés publiques compressées uniquement (voir <xref linkend="comp_pub"/>).</simpara>
</section>
<section id="_formats_de_clé_publique">
<title>Formats de clé publique</title>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;formats de clés publiques&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;formats de clés publiques&quot;</primary>
</indexterm>Les clés publiques sont également présentées de différentes manières, généralement sous forme de clés publiques <emphasis>compressées</emphasis> ou <emphasis>non compressées</emphasis>.</simpara>
<simpara>Comme nous l&#39;avons vu précédemment, la clé publique est un point de la courbe elliptique constitué d&#39;un couple de coordonnées <literal>(x,y)</literal>. Il est généralement présenté avec le préfixe <literal>04</literal> suivi de deux nombres de 256 bits : un pour la coordonnée <emphasis>x</emphasis> du point, l&#39;autre pour la coordonnée <emphasis>y</emphasis>. Le préfixe <literal>04</literal> est utilisé pour distinguer les clés publiques non compressées des clés publiques compressées qui commencent par un <literal>02</literal> ou un <literal>03</literal>.</simpara>
<simpara>Voici la clé publique générée par la clé privée que nous avons créée précédemment, indiquée par les coordonnées <literal>x</literal> et <literal>y</literal> :</simpara>
<screen>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</screen>
<simpara>Voici la même clé publique affichée sous la forme d&#39;un nombre de 520 bits (130 chiffres hexadécimaux) avec le préfixe <literal>04</literal> suivi de <literal>x</literal> puis des coordonnées <literal>y</literal>, sous la forme <literal>04 x y</literal> :</simpara>
<pre data-type="programlisting">
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&#x21b5;
07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre>
</section>
<section id="comp_pub">
<title>Clés publiques compressées</title>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;clés publiques compressées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;clés publiques compressées&quot;</primary>
</indexterm>Des clés publiques compressées ont été introduites dans le bitcoin pour réduire la taille des transactions et économiser de l&#39;espace disque sur les nœuds qui stockent la base de données de la blockchain Bitcoin. La plupart des transactions incluent la clé publique, qui est nécessaire pour valider les informations d&#39;identification du propriétaire et dépenser le bitcoin. Chaque clé publique nécessite 520 bits (préfixe + x + y), ce qui, multiplié par plusieurs centaines de transactions par bloc, soit des dizaines de milliers de transactions par jour, ajoute une quantité importante de données à la chaîne de blocs.</simpara>
<simpara>Comme nous l&#39;avons vu dans la section <xref linkend="pubkey"/>, une clé publique est un point (x,y) sur une courbe elliptique. Parce que la courbe exprime une fonction mathématique, un point sur la courbe représente une solution à l&#39;équation et, par conséquent, si nous connaissons la coordonnée <emphasis>x</emphasis>, nous pouvons calculer la coordonnée <emphasis>y</emphasis> en résolvant l&#39;équation y <superscript> 2 </superscript> mod p = (x <superscript> 3 </superscript> + 7) mod p. Cela nous permet de stocker uniquement la coordonnée <emphasis>x</emphasis> du point de clé publique, en omettant la coordonnée <emphasis>y</emphasis> et en réduisant la taille de la clé et l&#39;espace requis pour la stocker de 256 bits. Une réduction de près de 50 % de la taille de chaque transaction représente une grande quantité de données enregistrées au fil du temps !</simpara>
<simpara>Alors que les clés publiques non compressées ont un préfixe de <literal>04</literal>, les clés publiques compressées commencent par un préfixe <literal>02</literal> ou <literal>03</literal>. Regardons pourquoi il y a deux préfixes possibles : parce que le côté gauche de l&#39;équation est <emphasis>y</emphasis><superscript>2</superscript>, la solution pour <emphasis>y</emphasis> est une racine carrée, qui peut avoir une valeur positive ou négative. Visuellement, cela signifie que la coordonnée <emphasis>y</emphasis> résultante peut être au-dessus ou au-dessous de l&#39;axe des x. Comme vous pouvez le voir sur le graphique de la courbe elliptique en <xref linkend="ecc-curve"/>, la courbe est symétrique, c&#39;est-à-dire qu&#39;elle est réfléchie comme par un miroir à l&#39;axe des abscisses. Ainsi, bien que nous puissions omettre la coordonnée <emphasis>y</emphasis>, nous devons stocker le <emphasis>signe</emphasis> de <emphasis>y</emphasis> (positif ou négatif) ; ou en d&#39;autres termes, nous devons nous rappeler si c&#39;était au-dessus ou au-dessous de l&#39;axe des x parce que chacune de ces options représente un point différent et une clé publique différente. Lors du calcul de la courbe elliptique en arithmétique binaire sur le corps fini d&#39;ordre premier p, la coordonnée <emphasis>y</emphasis> est paire ou impaire, ce qui correspond au signe positif/négatif comme expliqué précédemment. Ainsi, pour distinguer les deux valeurs possibles de <emphasis>y</emphasis>, on stocke une clé publique compressée avec le préfixe <literal>02</literal> si le <emphasis>y</emphasis> est pair, et <literal>03</literal> s&#39;il est impair, permettant au logiciel de déduire correctement la coordonnée <emphasis>y</emphasis> de la coordonnée <emphasis>x</emphasis> et de décompresser la clé publique aux coordonnées complètes du point. La compression de clé publique est illustrée dans <xref linkend="pubkey_compression"/>.</simpara>
<simpara>Voici la même clé publique générée précédemment, présentée sous la forme d&#39;une clé publique compressée stockée sur 264 bits (66 chiffres hexadécimaux) avec le préfixe <literal>03</literal> indiquant que la coordonnée <emphasis>y</emphasis> est impaire :</simpara>
<screen>K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</screen>
<simpara>Cette clé publique compressée correspond à la même clé privée, c&#39;est-à-dire qu&#39;elle est générée à partir de la même clé privée. Cependant, il semble différent de la clé publique non compressée. Plus important encore, si nous convertissons cette clé publique compressée en une adresse Bitcoin à l&#39;aide de la fonction de double hachage (<literal>RIPEMD160(SHA256(K))</literal>), cela produira une adresse Bitcoin <emphasis>différente</emphasis>. Cela peut prêter à confusion, car cela signifie qu&#39;une seule clé privée peut produire une clé publique exprimée dans deux formats différents (compressé et non compressé) qui produisent deux adresses Bitcoin différentes. Cependant, la clé privée est identique pour les deux adresses Bitcoin.</simpara>
<figure id="pubkey_compression" role="smallerseventy"><title>Compression de clé publique</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0407.png"/>
  </imageobject>
  <textobject><phrase>pubkey_compression</phrase></textobject>
</mediaobject>
</figure>
<simpara>Les clés publiques compressées deviennent progressivement la valeur par défaut pour les clients Bitcoin, ce qui a un impact significatif sur la réduction de la taille des transactions et donc de la chaîne de blocs. Cependant, tous les clients ne prennent pas encore en charge les clés publiques compressées. Les clients plus récents qui prennent en charge les clés publiques compressées doivent comptabiliser les transactions des clients plus anciens qui ne prennent pas en charge les clés publiques compressées. Ceci est particulièrement important lorsqu&#39;une application de portefeuille importe des clés privées à partir d&#39;une autre application de portefeuille bitcoin, car le nouveau portefeuille doit analyser la chaîne de blocs pour trouver les transactions correspondant à ces clés importées. Quelles adresses Bitcoin le portefeuille Bitcoin doit-il rechercher ? Les adresses Bitcoin produites par des clés publiques non compressées, ou les adresses Bitcoin produites par des clés publiques compressées ? Les deux sont des adresses Bitcoin valides et peuvent être signées par la clé privée, mais ce sont des adresses différentes !</simpara>
<simpara>Pour résoudre ce problème, lorsque des clés privées sont exportées depuis un portefeuille, le WIF utilisé pour les représenter est implémenté différemment dans les nouveaux portefeuilles Bitcoin, pour indiquer que ces clés privées ont été utilisées pour produire des clés publiques <emphasis>compressées</emphasis> et donc des adresses Bitcoin <emphasis>compressées</emphasis>. Cela permet au portefeuille importateur de faire la distinction entre les clés privées provenant de portefeuilles plus anciens ou plus récents et de rechercher dans la chaîne de blocs des transactions avec des adresses Bitcoin correspondant respectivement aux clés publiques non compressées ou compressées. Voyons comment cela fonctionne plus en détail, dans la section suivante.</simpara>
</section>
<section id="comp_priv">
<title>Clés privées compressées</title>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;clés privées compressées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;clés privées compressées&quot;</primary>
</indexterm>Ironiquement, le terme &quot;clé privée compressée&quot; est un abus de langage, car lorsqu&#39;une clé privée est exportée au format WIF compressé, elle est en fait un octet <emphasis>plus long</emphasis> qu&#39;une clé privée &quot;non compressée&quot;. C&#39;est parce que la clé privée a un suffixe d&#39;un octet ajouté (affiché comme 01 en hexadécimal dans <xref linkend="table_4-4"/>), ce qui signifie que la clé privée provient d&#39;un portefeuille plus récent et ne doit être utilisée que pour produire des clés publiques compressées. Les clés privées ne sont pas elles-mêmes compressées et ne peuvent pas être compressées. Le terme &quot;clé privée compressée&quot; signifie en réalité &quot;clé privée à partir de laquelle seules les clés publiques compressées doivent être dérivées&quot;, tandis que &quot;clé privée non compressée&quot; signifie en réalité &quot;clé privée à partir de laquelle seules les clés publiques non compressées doivent être dérivées&quot;. Vous devez uniquement faire référence au format d&#39;exportation en tant que &quot;WIF-compressé&quot; ou &quot;WIF&quot; et ne pas faire référence à la clé privée elle-même en tant que &quot;compressée&quot; pour éviter toute confusion supplémentaire.</simpara>
<simpara><xref linkend="table_4-4"/> affiche la même clé, encodée aux formats WIF et WIF compressé.</simpara>
<table id="table_4-4"
frame="all"
rowsep="1" colsep="1"
>
<title>Exemple : même clé, différents formats</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Format </entry>
<entry align="left" valign="top"> Clé privée</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Hex</simpara></entry>
<entry align="left" valign="top"><simpara>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WIF</simpara></entry>
<entry align="left" valign="top"><simpara>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hex-compressé</simpara></entry>
<entry align="left" valign="top"><simpara>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WIF compressé</simpara></entry>
<entry align="left" valign="top"><simpara>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Notez que le format de clé privée compressée en hexadécimal a un octet supplémentaire à la fin (01 en hexadécimal). Bien que le préfixe de version Base58Check soit le même (0x80) pour les formats WIF et WIF compressés, l&#39;ajout d&#39;un octet à la fin du numéro fait passer le premier caractère de l&#39;encodage Base58 de 5 à <emphasis>K</emphasis> ou <emphasis>L</emphasis> . Considérez cela comme l&#39;équivalent Base58 de la différence de codage décimal entre le nombre 100 et le nombre 99. Alors que 100 est un chiffre plus long que 99, il a également un préfixe de 1 au lieu d&#39;un préfixe de 9. Lorsque la longueur change, il affecte le préfixe. En Base58, le préfixe 5 se transforme en <emphasis>K</emphasis> ou <emphasis>L</emphasis> lorsque la longueur du nombre augmente d&#39;un octet.</simpara>
<simpara>N&#39;oubliez pas que ces formats ne sont <emphasis>pas</emphasis> utilisés de manière interchangeable. Dans un portefeuille plus récent qui implémente des clés publiques compressées, les clés privées ne seront exportées qu&#39;au format WIF compressé (avec un préfixe <emphasis>K</emphasis> ou <emphasis>L</emphasis>). Si le portefeuille est une implémentation plus ancienne et n&#39;utilise pas de clés publiques compressées, les clés privées ne seront exportées qu&#39;au format WIF (avec un préfixe 5). Le but ici est de signaler au portefeuille qui importe ces clés privées s&#39;il doit rechercher dans la blockchain des clés et des adresses publiques compressées ou non.</simpara>
<simpara>Si un portefeuille bitcoin est capable d&#39;implémenter des clés publiques compressées, il les utilisera dans toutes les transactions. Les clés privées du portefeuille seront utilisées pour dériver les points de clé publique sur la courbe, qui seront compressés. Les clés publiques compressées seront utilisées pour produire des adresses Bitcoin et celles-ci seront utilisées dans les transactions. Lors de l&#39;exportation de clés privées à partir d&#39;un nouveau portefeuille qui implémente des clés publiques compressées, le WIF est modifié, avec l&#39;ajout d&#39;un suffixe d&#39;un octet <literal>01</literal> à la clé privée. La clé privée encodée en Base58Check qui en résulte est appelée &quot;WIF compressé&quot; et commence par la lettre <emphasis>K</emphasis> ou <emphasis>L</emphasis>, au lieu de commencer par &quot;5&quot; comme c&#39;est le cas avec les clés encodées en WIF (non compressées) des portefeuilles plus anciens.</simpara>
<tip>
<simpara>&quot;Clés privées compressées&quot; est un terme impropre ! Ils ne sont pas compressés ; au lieu de cela, WIF-compressé signifie que les clés ne doivent être utilisées que pour dériver des clés publiques compressées et leurs adresses Bitcoin correspondantes. Ironiquement, une clé privée codée &quot;compressée en WIF&quot; est plus longue d&#39;un octet car elle a le suffixe <literal>01</literal> ajouté pour la distinguer d&#39;une clé &quot;non compressée&quot;.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;KAaddress04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;KAaddress04&quot;</primary>
</indexterm></simpara>
</tip>
</section>
</section>
</section>
<section id="_implémentation_des_clés_et_des_adresses_dans_c">
<title>Implémentation des clés et des adresses dans C++</title>
<simpara>Regardons le processus complet de création d&#39;une adresse Bitcoin, d&#39;une clé privée, à une clé publique (un point sur la courbe elliptique), à une adresse à hachage double, et enfin, l&#39;encodage Base58Check. Le code C++ dans <xref linkend="addr_example"/> montre le processus complet étape par étape, de la clé privée à l&#39;adresse Bitcoin encodée en Base58Check. L&#39;exemple de code utilise la bibliothèque libbitcoin introduite dans <xref linkend="alt_libraries"/> pour certaines fonctions d&#39;assistance.</simpara>
<example id="addr_example">
<title>Création d&#39;une adresse Bitcoin encodée en Base58Check à partir d&#39;une clé privée</title>
<programlisting language="cpp" role="c_less_space" linenumbering="unnumbered">#include &lt;bitcoin/bitcoin.hpp&gt;

int main()
{
    // Private secret key string as base16
    bc::ec_secret decoded;
    bc::decode_base16(decoded,
        "038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776");

    bc::wallet::ec_private secret(
        decoded, bc::wallet::ec_private::mainnet_p2kh);

    // Get public key.
    bc::wallet::ec_public public_key(secret);
    std::cout &lt;&lt; "Public key: " &lt;&lt; public_key.encoded() &lt;&lt; std::endl;

    // Create Bitcoin address.
    // Normally you can use:
    //    bc::wallet::payment_address payaddr =
    //        public_key.to_payment_address(
    //            bc::wallet::ec_public::mainnet_p2kh);
    //  const std::string address = payaddr.encoded();

    // Compute hash of public key for P2PKH address.
    bc::data_chunk public_key_data;
    public_key.to_data(public_key_data);
    const auto hash = bc::bitcoin_short_hash(public_key_data);

    bc::data_chunk unencoded_address;
    // Reserve 25 bytes
    //   [ version:1  ]
    //   [ hash:20    ]
    //   [ checksum:4 ]
    unencoded_address.reserve(25);
    // Version byte, 0 is normal BTC address (P2PKH).
    unencoded_address.push_back(0);
    // Hash data
    bc::extend_data(unencoded_address, hash);
    // Checksum is computed by hashing data, and adding 4 bytes from hash.
    bc::append_checksum(unencoded_address);
    // Finally we must encode the result in Bitcoin's base58 encoding.
    assert(unencoded_address.size() == 25);
    const std::string address = bc::encode_base58(unencoded_address);

    std::cout &lt;&lt; "Address: " &lt;&lt; address &lt;&lt; std::endl;
    return 0;
}</programlisting>
</example>
<simpara>Le code utilise une clé privée prédéfinie pour produire la même adresse Bitcoin à chaque exécution, comme indiqué dans <xref linkend="addr_example_run"/>.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;base5804&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;base5804&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Abase5804&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Abase5804&quot;</primary>
</indexterm></simpara>
<example id="addr_example_run">
<title>Compilation et exécution du code addr</title>
<programlisting language="bash" linenumbering="unnumbered"># Compiler le code addr.cpp
$ g++ -o addr addr.cpp -std=c++11 $(pkg-config --cflags --libs libbitcoin)
# Lancer l&amp;#39;exécutable addr
$ ./addr
Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK</programlisting>
</example>
<tip>
<simpara>Le code dans <xref linkend="addr_example_run"/> produit une adresse Bitcoin (<literal>1PRTT&#8230;</literal>) à partir d&#39;une clé publique <emphasis>compressée</emphasis> (voir <xref linkend="comp_pub"/>). Si vous utilisiez la clé publique non compressée à la place, cela produirait une adresse Bitcoin différente (<literal>14K1y&#8230;</literal>).</simpara>
</tip>
</section>
<section id="_implémenter_des_clés_et_des_adresses_en_python">
<title>Implémenter des clés et des adresses en Python</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;implémentation en Python&quot;</secondary><tertiary>id=&quot;KApython04&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;implémentation en Python&quot;</primary><secondary>id=&quot;KApython04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;KApython04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;pybitcointools&quot;</primary>
</indexterm> La bibliothèque bitcoin la plus complète en Python est <ulink url="https://github.com/vbuterin/pybitcointools">pybitcointools</ulink> par Vitalik Buterin. Dans <xref linkend="key-to-address_script"/>, nous utilisons la bibliothèque pybitcointools (importée en tant que &quot;bitcoin&quot;) pour générer et afficher des clés et des adresses dans différents formats.</simpara>
<example id="key-to-address_script">
<title>Génération et formatage de clés et d&#39;adresses avec la bibliothèque pybitcointools</title>
<programlisting language="python" linenumbering="unnumbered">import bitcoin

# Generate a random private key
valid_private_key = False
while not valid_private_key:
    private_key = bitcoin.random_key()
    decoded_private_key = bitcoin.decode_privkey(private_key, 'hex')
    valid_private_key =  0 &lt; decoded_private_key &lt; bitcoin.N

print "Private Key (hex) is: ", private_key
print "Private Key (decimal) is: ", decoded_private_key

# Convert private key to WIF format
wif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, 'wif')
print "Private Key (WIF) is: ", wif_encoded_private_key

# Add suffix "01" to indicate a compressed private key
compressed_private_key = private_key + '01'
print "Private Key Compressed (hex) is: ", compressed_private_key

# Generate a WIF format from the compressed private key (WIF-compressed)
wif_compressed_private_key = bitcoin.encode_privkey(
    bitcoin.decode_privkey(compressed_private_key, 'hex'), 'wif')
print "Private Key (WIF-Compressed) is: ", wif_compressed_private_key

# Multiply the EC generator point G with the private key to get a public key point
public_key = bitcoin.fast_multiply(bitcoin.G, decoded_private_key)
print "Public Key (x,y) coordinates is:", public_key

# Encode as hex, prefix 04
hex_encoded_public_key = bitcoin.encode_pubkey(public_key,'hex')
print "Public Key (hex) is:", hex_encoded_public_key

# Compress public key, adjust prefix depending on whether y is even or odd
(public_key_x, public_key_y) = public_key
if (public_key_y % 2) == 0:
    compressed_prefix = '02'
else:
    compressed_prefix = '03'
hex_compressed_public_key = compressed_prefix + bitcoin.encode(public_key_x, 16)
print "Compressed Public Key (hex) is:", hex_compressed_public_key

# Generate bitcoin address from public key
print "Bitcoin Address (b58check) is:", bitcoin.pubkey_to_address(public_key)

# Generate compressed bitcoin address from compressed public key
print "Compressed Bitcoin Address (b58check) is:", \
    bitcoin.pubkey_to_address(hex_compressed_public_key)</programlisting>
</example>
<simpara><xref linkend="key-to-address_script_run"/> affiche la sortie de l&#39;exécution de ce code.</simpara>
<example id="key-to-address_script_run">
<title>Exécution de key-to-address-ecc-example.py</title>
<pre data-type="programlisting">
$ python key-to-address-ecc-example.py
Private Key (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
Private Key (decimal) is:
 26563230048437957592232553826663696440606756685920117476832299673293013768870
Private Key (WIF) is:
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
Private Key Compressed (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
Private Key (WIF-Compressed) is:
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
Public Key (x,y) coordinates is:
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L,
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
Public Key (hex) is:
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec&#x21b5;
243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
Compressed Public Key (hex) is:
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
Bitcoin Address (b58check) is:
 1thMirt546nngXqyPEz532S8fLwbozud8
Compressed Bitcoin Address (b58check) is:
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</pre>
</example>
<simpara><xref linkend="ec_math"/> est un autre exemple, utilisant la bibliothèque Python ECDSA pour les mathématiques de la courbe elliptique et sans utiliser de bibliothèques bitcoin spécialisées.</simpara>
<example id="ec_math">
<title>Un script démontrant les mathématiques de la courbe elliptique utilisées pour les clés bitcoin</title>
<programlisting language="python" linenumbering="unnumbered">import ecdsa
import os
from ecdsa.util import string_to_number, number_to_string

# secp256k1, http://www.oid-info.com/get/1.3.132.0.10
_p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL
_r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L
_b = 0x0000000000000000000000000000000000000000000000000000000000000007L
_a = 0x0000000000000000000000000000000000000000000000000000000000000000L
_Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L
_Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L
curve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b)
generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r)
oid_secp256k1 = (1, 3, 132, 0, 10)
SECP256k1 = ecdsa.curves.Curve("SECP256k1", curve_secp256k1, generator_secp256k1, oid_secp256k1)
ec_order = _r

curve = curve_secp256k1
generator = generator_secp256k1

def random_secret():
    convert_to_int = lambda array: int("".join(array).encode("hex"), 16)

    # Collect 256 bits of random data from the OS's cryptographically secure random generator
    byte_array = os.urandom(32)

    return convert_to_int(byte_array)

def get_point_pubkey(point):
    if point.y() &amp; 1:
        key = '03' + '%064x' % point.x()
    else:
        key = '02' + '%064x' % point.x()
    return key.decode('hex')

def get_point_pubkey_uncompressed(point):
    key = '04' + \
          '%064x' % point.x() + \
          '%064x' % point.y()
    return key.decode('hex')


# Generate a new private key.
secret = random_secret()
print "Secret: ", secret

# Get the public key point.
point = secret * generator
print "EC point:", point

print "BTC public key:", get_point_pubkey(point).encode("hex")

# Given the point (x, y) we can create the object using:
point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order)
assert point1 == point</programlisting>
</example>
<simpara><xref linkend="ec_math_run"/> affiche la sortie produite en exécutant ce script.</simpara>
<warning>
<simpara><xref linkend="ec_math"/> <indexterm>
  <primary>&quot;nombres aléatoires&quot;</primary><secondary>&quot;os.urandom&quot;</secondary><tertiary>voir=&quot;entropie&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;os.urandom&quot;</primary><secondary>voir=&quot;entropie&quot;</secondary>
</indexterm>
<indexterm>
  <primary>voir=&quot;entropie&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;entropie&quot;</primary><secondary>&quot;os.urandom&quot;</secondary><tertiary>see=&quot;nombres aléatoires&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;os.urandom&quot;</primary><secondary>see=&quot;nombres aléatoires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;nombres aléatoires&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;nombres aléatoires&quot;</primary><secondary>&quot;génération de nombres aléatoires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de nombres aléatoires&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;entropie&quot;</primary><secondary>&quot;génération de nombres aléatoires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de nombres aléatoires&quot;</primary>
</indexterm>utilise <literal>os.urandom</literal>, qui reflète un générateur de nombres aléatoires cryptographiquement sécurisé (CSRNG) fourni par le système d&#39;exploitation sous-jacent. Attention : Selon le système d&#39;exploitation, <literal>os.urandom</literal> peut <emphasis>ne pas</emphasis> être implémenté avec une sécurité suffisante ou correctement amorcé et peut <emphasis>ne pas</emphasis> être approprié pour générer des clés bitcoin de qualité production.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;KApython04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;KApython04&quot;</primary>
</indexterm></simpara>
</warning>
<example id="ec_math_run">
<title>Installation de la bibliothèque Python ECDSA et exécution du script ec_math.py</title>
<screen># Installer le gestionnaire de packages Python PIP
$ sudo apt-get install python-pip
# Installer la bibliothèque Python ECDSA
$ sudo pip install ecdsa
# Exécuter le script
$ python ec-math.py
Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873</screen>
</example>
</section>
<section id="_clés_et_adresses_avancées">
<title>Clés et adresses avancées</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;formulaires avancés&quot;</secondary><tertiary>id=&quot;KAadvanced04&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;formulaires avancés&quot;</primary><secondary>id=&quot;KAadvanced04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;KAadvanced04&quot;</primary>
</indexterm>Dans les sections suivantes, nous examinerons les formes avancées de clés et d&#39;adresses, telles que les clés privées cryptées, les adresses de script et des multisignatures, les adresses personnalisées, et les portefeuilles en papier.</simpara>
<section id="p2sh_addresses">
<title>Pay-to-Script Hash (P2SH) et adresses multisig</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;formulaires avancés&quot;</secondary><tertiary>&quot;pay-to-script hash et adresses multisig&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;formulaires avancés&quot;</primary><secondary>&quot;pay-to-script hash et adresses multisig&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;pay-to-script hash et adresses multisig&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Pay-to-Script-Hash (P2SH)&quot;</primary><secondary>&quot;adresses multisig et&quot;) ))(((&quot;adresses multisig&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;adresses multisig et&quot;) ))(((&quot;adresses multisig&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>&quot;adresses multisig&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;adresses multisig&quot;</primary>
</indexterm>Comme nous le savons, les adresses Bitcoin traditionnelles commencent par le chiffre &quot;1&quot; et sont dérivées de la clé publique, qui est dérivé de la clé privée. Bien que n&#39;importe qui puisse envoyer des bitcoins à une adresse &quot;1&quot;, ce bitcoin ne peut être dépensé qu&#39;en présentant la signature de la clé privée et la clé publique correspondantes.</simpara>
<simpara><indexterm>
  <primary>&quot;propositions d&#39;amélioration de bitcoin&quot;</primary><secondary>&quot;Pay to Script Hash (BIP-16)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Pay to Script Hash (BIP-16)&quot;</primary>
</indexterm>Les adresses Bitcoin qui commencent par le chiffre &quot;3&quot; sont des adresses Pay-to-Script Hash (P2SH ou hachage de paiement-à-script), parfois appelées à tort adresses multisig ou adresses multisignatures. Ils désignent le bénéficiaire d&#39;une transaction bitcoin comme le hachage d&#39;un script, au lieu du propriétaire d&#39;une clé publique. La fonctionnalité a été introduite en janvier 2012 avec BIP-16 (voir <xref linkend="appdxbitcoinimpproposals"/>), et est largement adopté car il offre la possibilité d&#39;ajouter des fonctionnalités à l&#39;adresse elle-même. Contrairement aux transactions qui &quot;envoient&quot; des fonds aux adresses Bitcoin traditionnelles &quot;1&quot;, également connues sous le nom de hachage de clé publique (P2PKH), les fonds envoyés aux adresses &quot;3&quot; nécessitent quelque chose de plus que la présentation d&#39;une clé publique et une signature de clé privée comme preuve de propriété. Les exigences sont désignées au moment de la création de l&#39;adresse, dans le script, et toutes les entrées de cette adresse seront encombrées des mêmes exigences.</simpara>
<simpara>Une adresse P2SH est créée à partir d&#39;un script de transaction, qui définit qui peut dépenser une sortie de transaction (pour plus de détails, voir <xref linkend="p2sh"/>). L&#39;encodage d&#39;une adresse P2SH consiste à utiliser la même fonction de double hachage que celle utilisée lors de la création d&#39;une adresse Bitcoin, appliquée uniquement sur le script à la place de la clé publique :</simpara>
<screen>hachage de script = RIPEMD160(SHA256(script))</screen>
<simpara>Le &quot;hachage de script&quot; résultant est encodé avec Base58Check avec un préfixe de version de 5, ce qui donne une adresse encodée commençant par un <literal>3</literal>. Un exemple d&#39;adresse P2SH est <literal>3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM</literal>, qui peut être dérivée à l&#39;aide des commandes Bitcoin Explorer <literal>script-encode</literal>, <literal>sha256</literal>, <literal>ripemd160</literal> et <literal>base58check-encode</literal> (voir <xref linkend="appdx_bx"/>) comme suit :</simpara>
<screen>$ echo \
'DUP HASH160 [89abcdefabbaabbaabbaabbaabbaabbaabbaabba] EQUALVERIFY CHECKSIG' &gt; script
$ bx script-encode &lt; script | bx sha256 | bx ripemd160 \
| bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM</screen>
<tip>
<simpara>P2SH n&#39;est pas nécessairement la même chose qu&#39;une transaction standard multisignature. Une adresse P2SH représente <emphasis>le plus souvent</emphasis> un script multi-signatures, mais elle peut également représenter un script codant d&#39;autres types de transactions.</simpara>
</tip>
<section id="_adresses_multisignatures_et_p2sh">
<title>Adresses multisignatures et P2SH</title>
<simpara>Actuellement, l&#39;implémentation la plus courante de la fonction P2SH est le script d&#39;adresse multisignature. Comme son nom l&#39;indique, le script sous-jacent nécessite un nombre minimum de signatures pour prouver la propriété et donc dépenser des fonds. La fonctionnalité de multisignature bitcoin est conçue pour exiger M signatures (également appelées «seuil») à partir d&#39;un total de N clés, appelées multisig M-de-N, où M est égal ou inférieur à N. Par exemple , Bob le propriétaire du café de <xref linkend="ch01_intro_what_is_bitcoin"/> pourrait utiliser une adresse multisignature nécessitant 1 sur 2 signatures d&#39;une clé lui appartenant et d&#39;une clé appartenant à son ou sa conjointe, garantissant que l&#39;un ou l&#39;autre pourrait signer pour passer une sortie de transaction verrouillée à cette adresse. Cela ressemblerait à un «compte conjoint» tel qu&#39;il est mis en œuvre dans les banques traditionnelles où l&#39;un ou l&#39;autre des conjoints peut dépenser avec une seule signature. Gopesh,<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;services contractuels extraterritorial&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;services contractuels extraterritorial&quot;</primary>
</indexterm> le concepteur Web payé par Bob pour créer un site Web, pourrait avoir une adresse multisignature 2 sur 3 pour son entreprise qui garantit qu&#39;aucun fonds ne peut être dépensé à moins qu&#39;au moins deux des partenaires commerciaux ne signent une transaction.</simpara>
<simpara>Nous explorerons comment créer des transactions qui dépensent des fonds à partir d&#39;adresses P2SH (et multisignatures) dans <xref linkend="transactions"/>.</simpara>
</section>
</section>
<section id="_adresses_personnalisées">
<title>Adresses personnalisées</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;formulaires avancés&quot;</secondary><tertiary>&quot;adresses personnalisées&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;formulaires avancés&quot;</primary><secondary>&quot;adresses personnalisées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;adresses personnalisées&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;adresses personnalisées&quot;</primary><secondary>id=&quot;vanity04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;vanity04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;adresses&quot;</primary><secondary>&quot;adresses personnalisées&quot;</secondary><tertiary>id =&quot;Avanity04&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;adresses personnalisées&quot;</primary><secondary>id =&quot;Avanity04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id =&quot;Avanity04&quot;</primary>
</indexterm>Les adresses personnalisées sont des adresses Bitcoin valides qui contiennent des messages lisibles par l&#39;homme. Par exemple, <literal>1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33</literal> est une adresse valide qui contient les lettres formant le mot &quot;Love&quot; comme les quatre premières lettres Base58. Les adresses personnalisées nécessitent de générer et de tester des milliards de clés privées candidates, jusqu&#39;à ce qu&#39;une adresse Bitcoin avec le modèle souhaité soit trouvée. Bien qu&#39;il y ait quelques optimisations dans l&#39;algorithme de génération de vanité, le processus consiste essentiellement à choisir une clé privée au hasard, à dériver la clé publique, à dériver l&#39;adresse Bitcoin et à vérifier si elle correspond au modèle de vanité souhaité, en répétant des milliards de fois jusqu&#39;à ce qu&#39;un correspondance est trouvée.</simpara>
<simpara>Une fois qu&#39;une adresse personnalisée correspondant au modèle souhaité est trouvée, la clé privée dont elle est dérivée peut être utilisée par le propriétaire pour dépenser des bitcoins exactement de la même manière que n&#39;importe quelle autre adresse. Les adresses personnalisées ne sont ni moins ni plus sécurisées que toute autre adresse. Ils dépendent de la même cryptographie à courbe elliptique (ECC) et SHA que toute autre adresse. Vous ne pouvez pas plus facilement trouver la clé privée d&#39;une adresse commençant par un modèle de vanité que vous ne le pouvez de n&#39;importe quelle autre adresse.</simpara>
<simpara>Dans <xref linkend="ch01_intro_what_is_bitcoin"/>, nous avons présenté Eugenia, directrice d&#39;une association caritative pour enfants opérant aux Philippines. Disons qu&#39;Eugenia organise une collecte de fonds en bitcoins et souhaite utiliser une adresse personnalisée Bitcoin pour faire connaître la collecte de fonds. Eugenia créera une adresse de vanité qui commence par &quot;1Kids&quot; pour promouvoir la collecte de fonds caritative pour les enfants. Voyons comment cette adresse personnalisée sera créée et ce que cela signifie pour la sécurité de l&#39;association caritative d&#39;Eugenia.<indexterm>
  <primary>&quot;cas d&#8217;utilisation&quot;</primary><secondary>&quot;dons caritatifs&quot;</secondary><tertiary>startref=&quot;eugeniafour&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;dons caritatifs&quot;</primary><secondary>startref=&quot;eugeniafour&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;eugeniafour&quot;</primary>
</indexterm></simpara>
<section id="_génération_d_39_adresses_personnalisées">
<title>Génération d&#39;adresses personnalisées</title>
<simpara>Il est important de réaliser qu&#39;une adresse Bitcoin est simplement un nombre représenté par des symboles dans l&#39;alphabet Base58. La recherche d&#39;un modèle comme &quot;1Kids&quot; peut être considérée comme la recherche d&#39;une adresse comprise entre <literal>1Kids1111111111111111111111111111</literal> et <literal>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzz</literal>. Il y a environ 58 <superscript> 29 </superscript> (environ 1,4 * 10 <superscript> 51 </superscript>) adresses dans cette plage, toutes commençant par &quot;1Kids&quot;. <xref linkend="table_4-11"/> affiche la plage d&#39;adresses qui ont le préfixe 1Kids.</simpara>
<table id="table_4-11"
frame="all"
rowsep="1" colsep="1"
>
<title>La plage d&#39;adresses personnalisées (ou de vanités) commençant par &quot;1Kids&quot;</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">De</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1Kids11111111111111111111111111111</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1Kids11111111111111111111111111112</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1Kids11111111111111111111111111113</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&#8230;</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">À</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Regardons le modèle &quot;1Kids&quot; comme un nombre et voyons à quelle fréquence nous pourrions trouver ce modèle dans une adresse Bitcoin (voir <xref linkend="table_4-12"/>). Un ordinateur de bureau moyen, sans aucun matériel spécialisé, peut rechercher environ 100 000 clés par seconde.</simpara>
<table id="table_4-12"
frame="all"
rowsep="1" colsep="1"
>
<title>La fréquence d&#39;un modèle de vanité (1KidsCharity) et le temps de recherche moyen sur un PC de bureau</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top"> Longueur </entry>
<entry align="left" valign="top"> Motif </entry>
<entry align="left" valign="top"> Fréquence </entry>
<entry align="left" valign="top"> Temps de recherche moyen</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1K</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 58 touches</simpara></entry>
<entry align="left" valign="top"><simpara>&lt; 1 millisecondes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1Ki</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 3 364</simpara></entry>
<entry align="left" valign="top"><simpara>50 millisecondes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>1Kid</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 195 000</simpara></entry>
<entry align="left" valign="top"><simpara>&lt; 2 secondes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>1Kids</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 11 millions</simpara></entry>
<entry align="left" valign="top"><simpara>1 minute</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>1KidsC</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 656 millions</simpara></entry>
<entry align="left" valign="top"><simpara>1 heure</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>1KidsCh</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 38 milliards</simpara></entry>
<entry align="left" valign="top"><simpara>2 jours</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>1KidsCha</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 2,2 trillions</simpara></entry>
<entry align="left" valign="top"><simpara>3–4 mois</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>1KidsChar</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 128 billions</simpara></entry>
<entry align="left" valign="top"><simpara>13–18 ans</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>1KidsChari</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 7 quadrillions</simpara></entry>
<entry align="left" valign="top"><simpara>800 ans</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>1KidsCharit</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 400 quadrillions</simpara></entry>
<entry align="left" valign="top"><simpara>46 000 ans</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>1KidsCharity</simpara></entry>
<entry align="left" valign="top"><simpara>1 sur 23 quintillions</simpara></entry>
<entry align="left" valign="top"><simpara>2,5 millions d&#39;années</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Comme vous pouvez le voir, Eugenia ne créera pas de sitôt l&#39;adresse personnalisée &quot;1KidsCharity&quot;, même si elle avait accès à plusieurs milliers d&#39;ordinateurs. Chaque caractère supplémentaire augmente la difficulté d&#39;un facteur de 58. Les modèles de plus de sept caractères sont généralement trouvés par du matériel spécialisé, tel que des ordinateurs de bureau personnalisés avec plusieurs GPU. Ce sont souvent des &quot;plates-formes&quot; de minage de bitcoin réutilisées qui ne sont plus rentables pour le minage de bitcoin mais peuvent être utilisées pour trouver des adresses personnalisées. Les recherches d&#8217;adresse personnalisées (ou de vanités) sur les systèmes GPU sont de plusieurs ordres de grandeur plus rapides que sur un processeur à usage général.</simpara>
<simpara>Une autre façon de trouver une adresse de vanité consiste à sous-traiter le travail à un groupe ou bassin de mineurs de vanité, comme le groupe sur <ulink url="https://vanitypool.appspot.com">Vanity Pool</ulink>. Un groupe ou bassin de ce type est un service qui permet à ceux qui disposent de matériel GPU de gagner des bitcoins en recherchant des adresses personnalisées pour les autres. Pour un petit paiement (0,01 bitcoin ou environ 5 $ au moment d&#39;écrire ces lignes), Eugenia peut externaliser la recherche d&#39;une adresse personnalisée à sept caractères et obtenir des résultats en quelques heures au lieu d&#39;avoir à exécuter une recherche de CPU pendant des mois.</simpara>
<simpara>Générer une adresse personnalisée est un exercice de force brute : essayez une clé aléatoire, vérifiez l&#39;adresse résultante pour voir si elle correspond au modèle souhaité, et répétez jusqu&#39;à ce que vous réussissiez. <xref linkend="vanity_miner_code"/> montre un exemple de &quot;mineur de vanité&quot;, un programme conçu pour trouver des adresses personnalisées, écrit en C++. L&#39;exemple utilise la bibliothèque libbitcoin, que nous avons introduite dans <xref linkend="alt_libraries"/>.</simpara>
<example id="vanity_miner_code">
<title>Mineur d&#39;adresse personnalisées (ou de vanité)</title>
<programlisting language="cpp" linenumbering="unnumbered">#include &lt;random&gt;
#include &lt;bitcoin/bitcoin.hpp&gt;

// The string we are searching for
const std::string search = "1kid";

// Generate a random secret key. A random 32 bytes.
bc::ec_secret random_secret(std::default_random_engine&amp; engine);
// Extract the Bitcoin address from an EC secret.
std::string bitcoin_address(const bc::ec_secret&amp; secret);
// Case insensitive comparison with the search string.
bool match_found(const std::string&amp; address);

int main()
{
    // random_device on Linux uses "/dev/urandom"
    // CAUTION: Depending on implementation this RNG may not be secure enough!
    // Do not use vanity keys generated by this example in production
    std::random_device random;
    std::default_random_engine engine(random());

    // Loop continuously...
    while (true)
    {
        // Generate a random secret.
        bc::ec_secret secret = random_secret(engine);
        // Get the address.
        std::string address = bitcoin_address(secret);
        // Does it match our search string? (1kid)
        if (match_found(address))
        {
            // Success!
            std::cout &lt;&lt; "Found vanity address! " &lt;&lt; address &lt;&lt; std::endl;
            std::cout &lt;&lt; "Secret: " &lt;&lt; bc::encode_base16(secret) &lt;&lt; std::endl;
            return 0;
        }
    }
    // Should never reach here!
    return 0;
}

bc::ec_secret random_secret(std::default_random_engine&amp; engine)
{
    // Create new secret...
    bc::ec_secret secret;
    // Iterate through every byte setting a random value...
    for (uint8_t&amp; byte: secret)
        byte = engine() % std::numeric_limits&lt;uint8_t&gt;::max();
    // Return result.
    return secret;
}

std::string bitcoin_address(const bc::ec_secret&amp; secret)
{
    // Convert secret to payment address
    bc::wallet::ec_private private_key(secret);
    bc::wallet::payment_address payaddr(private_key);
    // Return encoded form.
    return payaddr.encoded();
}

bool match_found(const std::string&amp; address)
{
    auto addr_it = address.begin();
    // Loop through the search string comparing it to the lower case
    // character of the supplied address.
    for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)
        if (*it != std::tolower(*addr_it))
            return false;
    // Reached end of search string, so address matches.
    return true;
}</programlisting>
</example>
<note>
<simpara><xref linkend="vanity_miner_code"/> utilise <literal>std::random_device</literal>. Selon l&#39;implémentation, cela peut refléter un CSRNG fourni par le système d&#39;exploitation sous-jacent. Dans le cas d&#39;un système d&#39;exploitation de type Unix tel que Linux, il tire de <literal>/dev/urandom</literal>. Le générateur de nombres aléatoires utilisé ici est à des fins de démonstration n&#39;est <emphasis>pas</emphasis> approprié pour générer des clés bitcoin de qualité production car il n&#39;est pas implémenté avec une sécurité suffisante.</simpara>
</note>
<simpara>L&#39;exemple de code doit être compilé à l&#39;aide d&#39;un compilateur C++ et lié à la bibliothèque libbitcoin (qui doit d&#39;abord être installée sur ce système). Pour exécuter l&#39;exemple, lancez l&#39;exécutable <literal>vanity-miner</literal> sans paramètres (voir <xref linkend="vanity_miner_run"/>) et il tentera de trouver une adresse personnalisée commençant par &quot;1kid&quot;.</simpara>
<example id="vanity_miner_run">
<title>Compilation et exécution de l&#39;exemple vanity-miner</title>
<programlisting language="bash" linenumbering="unnumbered"># Compiler le code avec g++
$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin)
# Exécutez l&amp;#39;exemple
$ ./vanity-miner
Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT
Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f
# Exécutez-le à nouveau pour un résultat différent
$ ./vanity-miner
Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn
Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623
# Utilisez &amp;quot;time&amp;quot; pour voir combien de temps il faut pour trouver un résultat
$ time ./vanity-miner
Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM
Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349

real    0m8.868s
user    0m8.828s
sys     0m0.035s</programlisting>
</example>
<simpara>L&#39;exemple de code prendra quelques secondes pour trouver une correspondance pour le modèle à trois caractères &quot;kid&quot;, comme nous pouvons le voir lorsque nous utilisons la commande Unix <literal>time</literal> pour mesurer le temps d&#39;exécution. Modifiez le modèle <literal>search</literal> dans le code source et voyez combien de temps cela prend pour les modèles à quatre ou cinq caractères !</simpara>
</section>
<section id="_sécurité_de_l_39_adresse_personnalisée">
<title>Sécurité de l&#39;adresse personnalisée</title>
<simpara><indexterm>
  <primary>&quot;sécurité&quot;</primary><secondary>&quot;adresses personnalisées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;adresses personnalisées&quot;</primary>
</indexterm>Les adresses personnalisées peuvent être utilisées pour améliorer <emphasis>et</emphasis> pour contourner les mesures de sécurité ; ils sont vraiment une épée à double tranchant. Utilisée pour améliorer la sécurité, une adresse distinctive rend plus difficile pour les adversaires de substituer leur propre adresse et de tromper vos clients en les payant à votre place. Malheureusement, les adresses personnalisées permettent également à quiconque de créer une adresse qui <emphasis>ressemble</emphasis> à n&#39;importe quelle adresse aléatoire, ou même à une autre adresse personnalisée, trompant ainsi vos clients.</simpara>
<simpara>Eugenia pourrait annoncer une adresse générée aléatoirement (par exemple, <literal>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</literal>) à laquelle les gens peuvent envoyer leurs dons. Ou, elle pourrait générer une adresse de vanité qui commence par 1Kids, pour la rendre plus distinctive.</simpara>
<simpara>Dans les deux cas, l&#39;un des risques d&#39;utiliser une seule adresse fixe (plutôt qu&#39;une adresse dynamique distincte par donateur) est qu&#39;un voleur puisse s&#39;infiltrer dans votre site Web et le remplacer par sa propre adresse, détournant ainsi les dons vers lui. Si vous avez annoncé votre adresse de don à plusieurs endroits différents, vos utilisateurs peuvent inspecter visuellement l&#39;adresse avant d&#39;effectuer un paiement pour s&#39;assurer qu&#39;il s&#39;agit de la même adresse qu&#39;ils ont vue sur votre site Web, sur votre e-mail et sur votre dépliant. Dans le cas d&#39;une adresse aléatoire comme <literal>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</literal>, l&#39;utilisateur moyen inspectera peut-être les premiers caractères &quot;1J7mdg&quot; et sera satisfait que l&#39;adresse corresponde. À l&#39;aide d&#39;un générateur d&#39;adresses personnalisées, une personne ayant l&#39;intention de voler en substituant une adresse d&#39;apparence similaire peut rapidement générer des adresses qui correspondent aux premiers caractères, comme indiqué dans <xref linkend="table_4-13"/>.</simpara>
<table id="table_4-13"
frame="all"
rowsep="1" colsep="1"
>
<title>Génération d&#39;adresses personnalisées pour correspondre à une adresse aléatoire</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Adresse aléatoire originale</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Vanité (correspondance à 4 caractères)</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Vanité (correspondance à 5 caractères)</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Vanité (correspondance à 6 caractères)</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Alors, une adresse personnalisée augmente-t-elle la sécurité ? Si Eugenia génère l&#39;adresse personnalisée <literal>1Kids33q44erFfpeXrmDSz7zEqG2FesZEN</literal>, les utilisateurs sont susceptibles de regarder le mot de modèle personnalisé <emphasis>et quelques caractères au-delà</emphasis>, par exemple en remarquant la partie &quot;1Kids33&quot; de l&#39;adresse. Cela obligerait un attaquant à générer une adresse de vanité correspondant à au moins six caractères (deux de plus), en déployant un effort 3 364 fois (58 × 58) supérieur à l&#39;effort qu&#39;Eugenia a dépensé pour sa vanité à 4 caractères. Essentiellement, l&#39;effort qu&#39;Eugenia déploie (ou paie une vanité pour) &quot;pousse&quot; l&#39;attaquant à devoir produire une vanité de modèle plus longue. Si Eugenia paie un pool pour générer une adresse de vanité à 8 caractères, l&#39;attaquant serait poussé dans le domaine de 10 caractères, ce qui est irréalisable sur un ordinateur personnel et coûteux même avec une plate-forme d&#39;extraction de vanité personnalisée ou un pool de vanité. Ce qui est abordable pour Eugenia devient inabordable pour l&#39;attaquant, surtout si la récompense potentielle de la fraude n&#39;est pas assez élevée pour couvrir le coût de la génération d&#39;adresse personnalisée.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Avanity04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Avanity04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot; &quot;</primary><secondary>startref=&quot;vanity04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;vanity04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;eugeniafour&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;eugeniafour&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="paper_wallets">
<title>Portefeuilles en papier</title>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>&quot;formulaires avancés&quot;</secondary><tertiary>&quot;portefeuilles papier&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;formulaires avancés&quot;</primary><secondary>&quot;portefeuilles papier&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;portefeuilles papier&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles papier&quot;</primary><secondary>id=&quot;paperw04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;paperw04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;types de&quot;</secondary><tertiary>&quot; paper wallets&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;types de&quot;</primary><secondary>&quot; paper wallets&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot; paper wallets&quot;</primary>
</indexterm> Les paper wallets, ou les portefeuilles en papier, sont des clés privées bitcoin imprimées sur papier. Souvent, le portefeuille papier comprend également l&#39;adresse Bitcoin correspondante pour plus de commodité, mais ce n&#39;est pas nécessaire car elle peut être dérivée de la clé privée.</simpara>
<warning>
<simpara>Les portefeuilles en papier sont une technologie OBSOLÈTE et sont dangereux pour la plupart des utilisateurs. Il existe de nombreux pièges subtils impliqués dans leur génération, notamment la possibilité que le code de génération soit compromis par une &quot;porte dérobée&quot;. Des centaines de bitcoins ont été volés de cette façon. Les portefeuilles en papier sont présentés ici à titre informatif uniquement et ne doivent pas être utilisés pour stocker des bitcoins. Utilisez une phrase mnémonique BIP-39 pour sauvegarder vos clés. Utilisez un portefeuille matériel pour stocker des clés et signer des transactions. N&#39;UTILISEZ PAS DE PORTEFEUILLES EN PAPIER.</simpara>
</warning>
<simpara>Les portefeuilles en papier se présentent sous de nombreuses formes, tailles et conceptions, mais à un niveau très basique, il ne s&#39;agit que d&#39;une clé et d&#39;une adresse imprimées sur papier. <xref linkend="table_4-14"/> montre la forme la plus simple d&#39;un portefeuille en papier.</simpara>
<table id="table_4-14"
frame="all"
rowsep="1" colsep="1"
>
<title>La forme la plus simple d&#39;un portefeuille papier - une impression de l&#39;adresse Bitcoin et de la clé privée</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Adresse publique</entry>
<entry align="left" valign="top">Clé privée (WIF)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x</simpara></entry>
<entry align="left" valign="top"><simpara>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Les portefeuilles en papier sont disponibles dans de nombreux modèles et tailles, avec de nombreuses fonctionnalités différentes. <xref linkend="paper_wallet_simple"/> montre un exemple de portefeuille en papier.</simpara>
<figure id="paper_wallet_simple"><title>Un exemple de portefeuille en papier simple</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0408.png"/>
  </imageobject>
  <textobject><phrase>images/mbc2_0408.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Certains sont destinés à être offerts en cadeau et ont des thèmes saisonniers, tels que les thèmes de Noël et du Nouvel An. D&#39;autres sont conçus pour être stockés dans un coffre-fort de banque ou un coffre-fort avec la clé privée cachée d&#39;une manière ou d&#39;une autre, soit avec des autocollants opaques à gratter, soit pliés et scellés avec une feuille adhésive inviolable.</simpara>
<simpara>D&#39;autres conceptions comportent des copies supplémentaires de la clé et de l&#39;adresse, sous la forme de talons détachables similaires aux talons de ticket, vous permettant de stocker plusieurs copies pour vous protéger contre les incendies, les inondations ou d&#39;autres catastrophes naturelles.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;KAadvanced04 &quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;KAadvanced04 &quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Wpaper04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Wpaper04&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;paperw04&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;paperw04&quot;</primary>
</indexterm></simpara>
<figure id="paper_wallet_spw"><title>Un exemple de portefeuille papier avec des copies supplémentaires des clés sur un &quot;talon&quot; de sauvegarde</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0412.png"/>
  </imageobject>
  <textobject><phrase>images/mbc2_0412.png</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
</section>
<section id="ch05_wallets">
<title>Portefeuilles</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm>Le mot &quot;portefeuille&quot; est utilisé pour décrire différentes choses dans le bitcoin.</simpara>
<simpara>À un niveau élevé, un portefeuille est une application qui sert d&#39;interface utilisateur principale. Le portefeuille contrôle l&#39;accès à l&#39;argent d&#39;un utilisateur, gère les clés et les adresses, le solde et crée et signe des transactions.</simpara>
<simpara>Plus précisément, du point de vue d&#39;un programmeur, le mot &quot;portefeuille&quot; fait référence à la structure de données utilisée pour stocker et gérer les clés d&#39;un utilisateur.</simpara>
<simpara>Dans ce chapitre, nous examinerons la deuxième signification, où les portefeuilles sont des conteneurs de clés privées, généralement implémentés sous forme de fichiers structurés ou de simples bases de données.</simpara>
<section id="_présentation_de_la_technologie_de_portefeuille">
<title>Présentation de la technologie de portefeuille</title>
<simpara>Dans cette section, nous résumons les différentes technologies utilisées pour construire des portefeuilles Bitcoin conviviaux, sécurisés et flexibles.</simpara>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;contenu de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;contenu de&quot;</primary>
</indexterm> Une idée faussement courante à propos du bitcoin est que les portefeuilles bitcoin contiennent du bitcoin. En fait, le portefeuille ne contient que des clés. Les &quot;monnaies ou coins&quot; sont enregistrés dans la chaîne de blocs sur le réseau Bitcoin. Les utilisateurs contrôlent les pièces sur le réseau en signant des transactions avec les clés de leur portefeuille. <indexterm>
  <primary>&quot;porte-clés&quot;</primary>
</indexterm> Dans un sens, un portefeuille bitcoin est un <emphasis>porte-clés</emphasis>.</simpara>
<tip>
<simpara>Les portefeuilles Bitcoin contiennent des clés, pas des pièces (ou coins). Chaque utilisateur dispose d&#39;un portefeuille contenant des clés. Les portefeuilles sont en réalité des porte-clés contenant des paires de clés privées/publiques (voir <xref linkend="private_public_keys"/>). Les utilisateurs signent des transactions avec les clés, prouvant ainsi qu&#39;ils sont propriétaires des sorties de transaction (leurs pièces ou monnaies). Les pièces sont stockées sur la blockchain sous la forme de sorties de transaction (souvent notées vout ou txout).</simpara>
</tip>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;types de&quot;</secondary><tertiary>&quot;distinctions primaires&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;types de&quot;</primary><secondary>&quot;distinctions primaires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;distinctions primaires&quot;</primary>
</indexterm>Il existe deux principaux types de portefeuilles, qui se distinguent par le fait que les clés qu&#39;ils contiennent sont liées les unes aux autres ou non.</simpara>
<simpara><indexterm>
  <primary>&quot;Portefeuilles JBOK&quot;</primary><secondary>seealso=&quot;portefeuilles&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;portefeuilles&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;types de&quot;</secondary><tertiary>&quot;portefeuilles JBOK&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;types de&quot;</primary><secondary>&quot;portefeuilles JBOK&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;portefeuilles JBOK&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles non déterministes&quot;</primary><secondary>seealso=&quot;portefeuilles&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;portefeuilles&quot;</primary>
</indexterm>Le premier type est un <emphasis>portefeuille non déterministe</emphasis>, où chaque clé est générée indépendamment à partir d&#39;un nombre aléatoire. Les clés ne sont pas liées les unes aux autres. Ce type de portefeuille est également connu sous le nom de portefeuille JBOK à partir de l&#39;expression &quot;Just a Bunch Of Keys&quot; (juste une poignées de clés).</simpara>
<simpara><indexterm>
  <primary>&quot;portefeuilles déterministes&quot;</primary><secondary>seealso=&quot;portefeuilles&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;portefeuilles&quot;</primary>
</indexterm>Le deuxième type de portefeuille est un <emphasis>portefeuille déterministe</emphasis>, où toutes les clés sont dérivées d&#39;une seule clé principale, connue sous le nom de <emphasis>seed</emphasis> (ou valeur d&#8217;amorçage). Toutes les clés de ce type de portefeuille sont liées les unes aux autres et peuvent être générées à nouveau si l&#39;on dispose de la valeur d&#8217;amorçage d&#39;origine. <indexterm>
  <primary>&quot;méthodes de dérivation de clé&quot;</primary>
</indexterm> Il existe un certain nombre de méthodes différentes de <emphasis>dérivation de clé</emphasis> utilisées dans les portefeuilles déterministes. <indexterm>
  <primary>&quot;portefeuilles déterministes hiérarchiques (HD)&quot;</primary><secondary>seealso=&quot;portefeuilles&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;portefeuilles&quot;</primary>
</indexterm>La méthode de dérivation la plus couramment utilisée utilise une structure arborescente et est connue sous le nom de portefeuille <emphasis>déterministe hiérarchique</emphasis> ou <emphasis>HD</emphasis>.</simpara>
<simpara><indexterm>
  <primary>&quot;mots de code mnémoniques&quot;</primary>
</indexterm>Les portefeuilles déterministes sont initialisés à partir d&#39;une séquence aléatoire (une entropie). Pour faciliter leur utilisation, les séquences aléatoires sont encodées sous forme de mots anglais, également appelés <emphasis>mots de code mnémoniques</emphasis>.</simpara>
<simpara>Les prochaines sections présentent chacune de ces technologies à un niveau élevé.</simpara>
<section id="random_wallet">
<title>Portefeuilles non déterministes (aléatoires)</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;types de&quot;</secondary><tertiary>&quot;portefeuilles non déterministes (aléatoires)&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;types de&quot;</primary><secondary>&quot;portefeuilles non déterministes (aléatoires)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;portefeuilles non déterministes (aléatoires)&quot;</primary>
</indexterm> Dans le premier portefeuille bitcoin (maintenant appelé Bitcoin Core), les portefeuilles étaient des collections de clés privées générées aléatoirement. Par exemple, le client Bitcoin Core d&#39;origine prégénère 100 clés privées aléatoires lors du premier démarrage et génère plus de clés si nécessaire, en utilisant chaque clé une seule fois. Ces portefeuilles sont remplacés par des portefeuilles déterministes car ils sont lourds à gérer, à sauvegarder et à importer. L&#39;inconvénient des clés aléatoires est que si vous en générez beaucoup, vous devez conserver des copies de toutes, ce qui signifie que le portefeuille doit être sauvegardé fréquemment. Chaque clé doit être sauvegardée, sinon les fonds qu&#39;elle contrôle sont irrévocablement perdus si le portefeuille devient inaccessible. Cela entre directement en conflit avec le principe d&#39;éviter la réutilisation des adresses, en utilisant chaque adresse Bitcoin pour une seule transaction. La réutilisation des adresses réduit la confidentialité en associant plusieurs transactions et adresses les unes aux autres. Un portefeuille non déterministe de type-0 est un mauvais choix de portefeuille, surtout si vous voulez éviter la réutilisation des adresses car cela implique de gérer de nombreuses clés, ce qui crée le besoin de sauvegardes fréquentes. Bien que le client Bitcoin Core inclue un portefeuille de type 0, l&#39;utilisation de ce portefeuille est déconseillée par les développeurs de Bitcoin Core. <xref linkend="Type0_wallet"/> montre un portefeuille non déterministe, contenant une collection lâche de clés aléatoires.</simpara>
<tip>
<simpara>L&#39;utilisation de portefeuilles non déterministes est déconseillée pour autre chose que de simples tests. Ils sont tout simplement trop lourds à sauvegarder et à utiliser. À la place, utilisez un <emphasis>portefeuille HD</emphasis> standard de l&#39;industrie avec une séquence aléatoire <emphasis>mnémonique</emphasis> (entropie, ou &quot;valeur d&#8217;amorçage&quot;) pour la sauvegarde.</simpara>
</tip>
<figure id="Type0_wallet" role="smallersixty"><title>Portefeuille non déterministe (aléatoire) de type-0 : une collection de clés générées aléatoirement</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0501.png"/>
  </imageobject>
  <textobject><phrase>Non-Deterministic Wallet</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_portefeuilles_déterministes_ensemencés">
<title>Portefeuilles déterministes (ensemencés)</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;types de&quot;</secondary><tertiary>&quot;portefeuilles déterministes (ensemencés)&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;types de&quot;</primary><secondary>&quot;portefeuilles déterministes (ensemencés)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;portefeuilles déterministes (ensemencés)&quot;</primary>
</indexterm>Les portefeuilles déterministes ou &quot;ensemencés&quot; sont des portefeuilles qui contiennent des clés privées qui sont toutes dérivées d&#39;une valeur d&#8217;amorçage commune, grâce à l&#39;utilisation d&#39;un fonction de hachage à sens unique. La valeur d&#8217;amorçage est un nombre généré aléatoirement qui est combiné avec d&#39;autres données, telles qu&#39;un numéro d&#39;index ou un &quot;code de chaîne&quot; (voir <xref linkend="hd_wallets"/>) pour dériver les clés privées. Dans un portefeuille déterministe, la valeur d&#8217;amorçage est suffisante pour récupérer toutes les clés dérivées, et donc une seule sauvegarde au moment de la création est suffisante. La valeur d&#8217;amorçage est également suffisante pour une exportation ou une importation de portefeuille, permettant une migration facile de toutes les clés de l&#39;utilisateur entre différentes implémentations de portefeuille. <xref linkend="Type1_wallet"/> montre un diagramme logique d&#39;un portefeuille déterministe.</simpara>
<figure id="Type1_wallet" role="smallersixty"><title>Portefeuille déterministe (ensemencé) de type-1 : une séquence déterministe de clés dérivée d&#39;une valeur d&#8217;amorçage</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0502.png"/>
  </imageobject>
  <textobject><phrase>Deterministic Wallet</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="hd_wallets">
<title>Portefeuilles HD (BIP-32/BIP-44)</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;types de&quot;</secondary><tertiary>&quot;portefeuilles déterministes hiérarchiques (HD)&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;types de&quot;</primary><secondary>&quot;portefeuilles déterministes hiérarchiques (HD)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;portefeuilles déterministes hiérarchiques (HD)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles déterministes hiérarchiques (HD)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration du bitcoin&quot;</primary><secondary>&quot;Portefeuilles déterministes hiérarchiques (BIP-32/BIP-44)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Portefeuilles déterministes hiérarchiques (BIP-32/BIP-44)&quot;</primary>
</indexterm> Des portefeuilles déterministes ont été développés pour faciliter la dérivation de nombreuses clés à partir d&#39;une seule &quot;valeur d&#8217;amorçage&quot;. La forme la plus avancée de portefeuilles déterministes est le portefeuille HD défini par la norme BIP-32. Les portefeuilles HD contiennent des clés dérivées dans une structure arborescente, de sorte qu&#39;une clé parent peut dériver une séquence de clés enfants, chacune pouvant dériver une séquence de clés petits-enfants, et ainsi de suite, jusqu&#39;à une profondeur infinie. Cette arborescence est illustrée dans <xref linkend="Type2_wallet"/>.</simpara>
<figure id="Type2_wallet"><title>Portefeuille HD de type-2 : un arbre de clés généré à partir d&#39;une seule valeur d&#8217;amorçage</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0503.png"/>
  </imageobject>
  <textobject><phrase>HD wallet</phrase></textobject>
</mediaobject>
</figure>
<simpara>Les portefeuilles HD offrent deux avantages majeurs par rapport aux clés aléatoires (non déterministes). Tout d&#39;abord, la structure arborescente peut être utilisée pour exprimer une signification organisationnelle supplémentaire, par exemple lorsqu&#39;une branche spécifique de sous-clés est utilisée pour recevoir des paiements entrants et qu&#39;une branche différente est utilisée pour recevoir la monnaie des paiements sortants. Les branches de clés peuvent également être utilisées dans les paramètres de l&#39;entreprise, en attribuant différentes branches à des départements, des filiales, des fonctions spécifiques ou des catégories comptables.</simpara>
<simpara>Le deuxième avantage des portefeuilles HD est que les utilisateurs peuvent créer une séquence de clés publiques sans avoir accès aux clés privées correspondantes. Cela permet aux portefeuilles HD d&#39;être utilisés sur un serveur non sécurisé ou dans une capacité de réception uniquement, en émettant une clé publique différente pour chaque transaction. Les clés publiques n&#39;ont pas besoin d&#39;être préchargées ou dérivées à l&#39;avance, mais le serveur ne dispose pas des clés privées qui peuvent dépenser les fonds.</simpara>
</section>
<section id="_graines_ou_valeurs_d_8217_amorçages_et_codes_mnémoniques_bip_39">
<title>Graines (ou valeurs d&#8217;amorçages) et codes mnémoniques (BIP-39)</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;technologie de&quot;</secondary><tertiary>&quot;valeurs d&#8217;amorçage et codes mnémoniques&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;technologie de&quot;</primary><secondary>&quot;valeurs d&#8217;amorçage et codes mnémoniques&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;valeurs d&#8217;amorçage et codes mnémoniques&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;mots de code mnémoniques&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration du bitcoin&quot;</primary><secondary>&quot;mots de code mnémoniques (BIP-39) &quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;mots de code mnémoniques (BIP-39) &quot;</primary>
</indexterm>Les portefeuilles HD sont un mécanisme très puissant pour gérer de nombreuses clés et adresses. Ils sont encore plus utiles s&#39;ils sont combinés à une manière standardisée de créer des valeurs d&#8217;amorçage à partir d&#39;une séquence de mots anglais faciles à transcrire, exporter et importer sur plusieurs portefeuilles. C&#39;est ce qu&#39;on appelle un <emphasis>mnémonique</emphasis> et la norme est définie par BIP-39. Aujourd&#39;hui, la plupart des portefeuilles Bitcoin (ainsi que des portefeuilles pour d&#39;autres cryptomonnaies) utilisent cette norme et peuvent importer et exporter des valeurs d&#8217;amorçage pour la sauvegarde et la récupération à l&#39;aide de mnémoniques interopérables.</simpara>
<simpara>Regardons cela d&#39;un point de vue pratique. Laquelle des valeurs d&#8217;amorçage suivantes est la plus facile à transcrire, à enregistrer sur papier, à lire sans erreur ou à exporter et à importer dans un autre portefeuille ?</simpara>
<formalpara><title>Une valeur d&#8217;amorçage pour un portefeuille déterministe, en hexadécimal</title><para>
<screen>0C1E24E5917779D297E14D45F14E1A1A</screen>
</para></formalpara>
<formalpara><title>Une valeur d&#8217;amorçage pour un portefeuille déterministe, à partir d&#39;un mnémonique de 12 mots</title><para>
<screen>army van defense carry jealous true
garbage claim echo media make crunch</screen>
</para></formalpara>
</section>
<section id="_meilleures_procédures_de_portefeuille">
<title>Meilleures procédures de portefeuille</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;meilleures procédures pour&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;meilleures procédures pour&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration des bitcoins&quot;</primary><secondary>&quot;Structure de portefeuille HD polyvalente (BIP-43)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Structure de portefeuille HD polyvalente (BIP-43)&quot;</primary>
</indexterm>Au fur et à mesure que les portefeuilles de Bitcoin ont atteint un degré de maturité, certaines normes industrielles mis en commun ont émergé, rendant de nos jours des portefeuilles Bitcoin largement interopérables, faciles à utiliser, sécurisés et flexibles. Ces normes communes sont :</simpara>
<itemizedlist>
<listitem>
<simpara>
Mots de code mnémonique, basés sur BIP-39
</simpara>
</listitem>
<listitem>
<simpara>
Portefeuilles HD, basés sur BIP-32
</simpara>
</listitem>
<listitem>
<simpara>
Structure de portefeuille HD polyvalente, basée sur BIP-43
</simpara>
</listitem>
<listitem>
<simpara>
Portefeuilles multidevises et multicomptes, basés sur BIP-44
</simpara>
</listitem>
</itemizedlist>
<simpara>Ces normes peuvent changer ou devenir obsolètes en raison de développements futurs, mais pour l&#39;instant, elles forment un ensemble de technologies imbriquées qui sont devenues de facto la norme de portefeuille pour le bitcoin.</simpara>
<simpara>Les normes ont été adoptées par une large gamme de portefeuilles bitcoin logiciels et matériels, rendant tous ces portefeuilles interopérables. Un utilisateur peut exporter un mnémonique généré sur l&#39;un de ces portefeuilles et l&#39;importer dans un autre portefeuille, récupérant toutes les transactions, clés et adresses.</simpara>
<simpara><indexterm>
  <primary>&quot;portefeuilles matériels&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles matériels&quot;</primary><secondary>see=&quot;aussi portefeuilles&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi portefeuilles&quot;</primary>
</indexterm> Quelques exemples de portefeuilles logiciels prenant en charge ces normes incluent (par ordre alphabétique) Bluewallet, Breadwallet, Copay et Multibit HD. Des exemples de portefeuilles matériels prenant en charge ces normes incluent (par ordre alphabétique) KeepKey, Ledger et Trezor.</simpara>
<simpara>Les sections suivantes examinent chacune de ces technologies en détail.</simpara>
<tip>
<simpara>Si vous implémentez un portefeuille bitcoin, il doit être construit comme un portefeuille HD, avec une valeur d&#8217;amorçage dérivée et codée comme un code mnémonique pour la sauvegarde, suivant les normes BIP-32, BIP-39, BIP-43 et BIP-44, comme décrit dans les sections suivantes.</simpara>
</tip>
</section>
<section id="_utiliser_un_portefeuille_bitcoin">
<title>Utiliser un portefeuille Bitcoin</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;utiliser des portefeuilles bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;utiliser des portefeuilles bitcoin&quot;</primary>
</indexterm>Dans <xref linkend="user-stories"/> nous avons présenté Gabriel, <indexterm>
  <primary>&quot;cas d"utilisation&quot;</primary><secondary>&quot;commerce électronique&quot;</secondary><tertiary>id=&quot;gabrielfive&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;commerce électronique&quot;</primary><secondary>id=&quot;gabrielfive&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;gabrielfive&quot;</primary>
</indexterm>un jeune adolescent entreprenant à Rio de Janeiro, qui gère une simple boutique en ligne qui vend des t-shirts de marque bitcoin, des tasses à café et des autocollants.</simpara>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;types de&quot;</secondary><tertiary>&quot;portefeuilles matériels&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;types de&quot;</primary><secondary>&quot;portefeuilles matériels&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;portefeuilles matériels&quot;</primary>
</indexterm>Gabriel utilise un portefeuille matériel bitcoin Trezor (<xref linkend="a_trezor_device"/>) pour gérer en toute sécurité son bitcoin. Le Trezor est un simple périphérique USB à deux boutons qui stocke les clés (sous la forme d&#39;un portefeuille HD) et signe les transactions. Les portefeuilles Trezor mettent en œuvre toutes les normes de l&#39;industrie abordées dans ce chapitre, de sorte que Gabriel ne dépend d&#39;aucune technologie propriétaire ou d&#39;une solution de fournisseur unique.</simpara>
<figure id="a_trezor_device"><title>Un appareil Trezor : un portefeuille bitcoin HD en matériel</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0504.png"/>
  </imageobject>
  <textobject><phrase>alt</phrase></textobject>
</mediaobject>
</figure>
<simpara>Lorsque Gabriel a utilisé le Trezor pour la première fois, l&#39;appareil a généré une séquence aléatoire (entropie), le mnémonique associé et a dérivé une valeur d&#8217;amorçage à partir d&#39;un générateur de nombres aléatoires matériel intégré. Lors de cette phase d&#39;initialisation, le portefeuille affichait à l&#39;écran une séquence de mots numérotés, un par un (voir <xref linkend="trezor_mnemonic_display"/>).</simpara>
<figure id="trezor_mnemonic_display"><title>Trezor affichant un des mots mnémoniques</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0505.png"/>
  </imageobject>
  <textobject><phrase>Trezor wallet display of mnemonic word</phrase></textobject>
</mediaobject>
</figure>
<simpara>En écrivant ce mnémonique, Gabriel a créé une sauvegarde (voir <xref linkend="mnemonic_paper_backup"/>) qui peut être utilisé pour la récupération en cas de perte ou d&#39;endommagement de l&#39;appareil Trezor. Ce mnémonique peut être utilisé pour la récupération dans un nouveau Trezor ou dans l&#39;un des nombreux portefeuilles logiciels ou matériels compatibles. Notez que la séquence des mots est importante, donc les sauvegardes papier mnémotechniques ont des espaces numérotés pour chaque mot. Gabriel a dû enregistrer soigneusement chaque mot dans l&#39;espace numéroté pour préserver la séquence correcte.</simpara>
<table id="mnemonic_paper_backup"
frame="all"
rowsep="1" colsep="1"
>
<title>La sauvegarde papier de Gabriel du mnémonique</title>
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="3*"/>
<colspec colname="col_2" colwidth="167*"/>
<colspec colname="col_3" colwidth="3*"/>
<colspec colname="col_4" colwidth="167*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">1.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>army</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">7.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>garbage</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">2.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>van</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">8.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>claim</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">3.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>defense</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">9.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>echo</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">4.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>carry</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">10.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>media</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">5.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>jealous</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">11.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>make</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">6.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>true</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">12.</emphasis></simpara></entry>
<entry align="center" valign="top"><simpara><emphasis>crunch</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Un mnémonique de 12 mots est affiché dans <xref linkend="mnemonic_paper_backup"/>, pour plus de simplicité. En fait, la plupart des portefeuilles matériels génèrent un mnémonique de 24 mots plus sécurisé. Le mnémonique est utilisé exactement de la même manière, quelle que soit sa longueur.</simpara>
</note>
<simpara>Pour la première implémentation de sa boutique en ligne, Gabriel utilise une seule adresse Bitcoin, générée sur son appareil Trezor. Cette adresse unique est utilisée par tous les clients pour toutes les commandes. Comme nous le verrons, cette approche présente quelques inconvénients et peut être améliorée avec un portefeuille HD.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;gabrielfive&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;gabrielfive&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="_détails_de_la_technologie_de_portefeuille">
<title>Détails de la technologie de portefeuille</title>
<simpara>Examinons maintenant en détail chacune des normes importantes de l&#39;industrie utilisées par de nombreux portefeuilles Bitcoin.</simpara>
<section id="mnemonic_code_words">
<title>Mots de code mnémonique (BIP-39)</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;technologie de&quot;</secondary><tertiary>&quot;mots de code mnémoniques&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;technologie de&quot;</primary><secondary>&quot;mots de code mnémoniques&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;mots de code mnémoniques&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;mots de code mnémoniques&quot;</primary><secondary>id=&quot;mnemonic05&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;mnemonic05&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration du bitcoin&quot;</primary><secondary>&quot;Mots de code mnémoniques (BIP-39)&quot;</secondary><tertiary>id=&quot;BIP3905&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Mots de code mnémoniques (BIP-39)&quot;</primary><secondary>id=&quot;BIP3905&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;BIP3905&quot;</primary>
</indexterm>Les mots de code mnémonique sont des séquences de mots qui représentent (encodent) un nombre aléatoire utilisé comme valeur d&#8217;amorçage pour dériver un portefeuille déterministe. La séquence de mots est suffisante pour recréer la valeur d&#8217;amorçage et à partir de là recréer le portefeuille et toutes les clés dérivées. Une application de portefeuille qui implémente des portefeuilles déterministes avec des mots mnémoniques montrera à l&#39;utilisateur une séquence de 12 à 24 mots lors de la première création d&#39;un portefeuille. Cette séquence de mots est à sauvegarder et est la valeur d&#8217;amorçage du portefeuille. Elle peut être utilisée pour récupérer et recréer toutes les clés dans la même application de portefeuille ou dans n&#39;importe quelle application de portefeuille compatible. Les mots mnémotechniques facilitent la sauvegarde des portefeuilles par les utilisateurs, car ils sont faciles à lire et à transcrire correctement, par rapport à une séquence aléatoire de chiffres.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;brainwallets&quot;</primary>
</indexterm> Les mots mnémoniques sont souvent confondus avec les &quot;brainwallets&quot;. Ils ne sont pas les mêmes. La principale différence est qu&#39;un brainwallet se compose de mots choisis par l&#39;utilisateur, tandis que les mots mnémoniques sont créés de manière aléatoire par le portefeuille et présentés à l&#39;utilisateur. Cette différence importante rend les mots mnémoniques beaucoup plus sûrs, car les humains sont de très mauvaises sources d&#39;aléatoire.</simpara>
</tip>
<simpara>Les codes mnémoniques sont définis dans le BIP-39 (voir <xref linkend="appdxbitcoinimpproposals"/>). Notez que BIP-39 est une implémentation d&#39;une norme de code mnémonique. <indexterm>
  <primary>&quot;portefeuilles Electrum&quot;</primary><secondary>seealso=&quot;wallets&quot;</secondary>
</indexterm>
<indexterm>
  <primary>seealso=&quot;wallets&quot;</primary>
</indexterm> Il existe une norme différente, avec un ensemble de mots différent, utilisée par le portefeuille Electrum et antérieure à BIP-39. BIP-39 a été proposé par la société à l&#39;origine du portefeuille matériel Trezor et est incompatible avec la mise en œuvre d&#39;Electrum. Cependant, BIP-39 a maintenant obtenu un large soutien de l&#39;industrie à travers des dizaines d&#39;implémentations interopérables et devrait être considéré comme la norme de facto de l&#39;industrie.</simpara>
<simpara>La BIP-39 définit la création d&#39;un code mnémonique et d&#39;une valeur d&#8217;amorçage, que nous décrivons ici en neuf étapes. Pour plus de clarté, le processus est divisé en deux parties: les étapes 1 à 6 sont présentées dans <xref linkend="generating_mnemonic_words"/> et les étapes 7 à 9 sont illustrées dans <xref linkend="mnemonic_to_seed"/>.</simpara>
<section id="generating_mnemonic_words">
<title>Génération de mots mnémoniques</title>
<simpara>Les mots mnémoniques sont générés automatiquement par le portefeuille en utilisant le processus standardisé défini dans BIP-39. Le portefeuille part d&#39;une source d&#39;entropie, ajoute une somme de contrôle, puis mappe l&#39;entropie sur une liste de mots :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Créez une séquence aléatoire (entropie) de 128 à 256 bits.
</simpara>
</listitem>
<listitem>
<simpara>
Créez une somme de contrôle de la séquence aléatoire en prenant les premiers bits (longueur d&#39;entropie/32) de son hachage SHA256.
</simpara>
</listitem>
<listitem>
<simpara>
Ajoutez la somme de contrôle à la fin de la séquence aléatoire.
</simpara>
</listitem>
<listitem>
<simpara>
Divisez le résultat en segments de 11 bits.
</simpara>
</listitem>
<listitem>
<simpara>
Associez chaque valeur 11 bits à un mot du dictionnaire prédéfini de 2048 mots.
</simpara>
</listitem>
<listitem>
<simpara>
Le code mnémonique est la séquence de mots.
</simpara>
</listitem>
</orderedlist>
<simpara>&lt;&lt;generating_entropy_and_encoding&gt; &gt; montre comment l&#39;entropie est utilisée pour générer des mots mnémoniques.</simpara>
<figure id="generating_entropy_and_encoding" role="smallerseventy"><title>Génération d&#39;entropie et encodage sous forme de mots mnémoniques</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0506.png"/>
  </imageobject>
  <textobject><phrase>&quot;Génération d&#39;entropie et encodage sous forme de mots mnémoniques&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara><xref linkend="table_4-5"/> montre la relation entre la taille des données d&#39;entropie et la longueur des codes mnémoniques en mots.</simpara>
<table id="table_4-5"
frame="all"
rowsep="1" colsep="1"
>
<title>Codes mnémoniques : entropie et longueur des mots</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Entropie (bits) </entry>
<entry align="left" valign="top"> Somme de contrôle (bits) </entry>
<entry align="left" valign="top"> Somme de contrôle d&#39;entropie <emphasis role="strong">+</emphasis> (bits) </entry>
<entry align="left" valign="top"> Longueur mnémonique (mots)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>128</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>132</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>160</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>165</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>192</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>198</simpara></entry>
<entry align="left" valign="top"><simpara>18</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>224</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>231</simpara></entry>
<entry align="left" valign="top"><simpara>21</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>256</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>264</simpara></entry>
<entry align="left" valign="top"><simpara>24</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="mnemonic_to_seed">
<title>Du mnémonique à la valeur d&#8217;amorçage</title>
<simpara><indexterm>
  <primary>&quot;fonction d&#39;étirement de clé&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Fonction PBKDF2&quot;</primary>
</indexterm>Les mots mnémoniques représentent l&#39;entropie d&#39;une longueur de 128 à 256 bits. L&#39;entropie est ensuite utilisée pour dériver une valeur d&#8217;amorçage plus longue (512 bits) grâce à l&#39;utilisation de la fonction d&#39;étirement de clé PBKDF2. La valeur d&#8217;amorçage produite est ensuite utilisée pour construire un portefeuille déterministe et en dériver ses clés.</simpara>
<simpara><indexterm>
  <primary>&quot;sels&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Phrases de passe&quot;</primary>
</indexterm>La fonction d&#39;étirement de clé prend deux paramètres : le mnémonique et un <emphasis>sel</emphasis>. Le but d&#39;un sel dans une fonction d&#39;étirement de clé est de rendre difficile la construction d&#39;une table de recherche permettant une attaque par force brute. Dans la norme BIP-39, le sel a un autre objectif : il permet l&#39;introduction d&#39;une phrase secrète qui sert de facteur de sécurité supplémentaire protégeant la valeur d&#8217;amorçage, comme nous le décrirons plus en détail dans <xref linkend="mnemonic_passphrase"/>.</simpara>
<simpara>Le processus décrit aux étapes 7 à 9 continue à partir du processus décrit précédemment dans <xref linkend="generating_mnemonic_words"/> :</simpara>
<ol start="7">
        <li>Le premier paramètre de la fonction d&#39;étirement de clé PBKDF2 est le <em>mnémonique</em> produit à partir de l&#39;étape 6.</li>
        <li>Le deuxième paramètre de la fonction d&#39;étirement de clé PBKDF2 est un <em>sel</em> . Le sel est composé de la constante de chaîne &quot;<code>mnemonique</code>&quot; concaténée avec une phrase de passe facultative fournie par l&#39;utilisateur.</li>
        <li>PBKDF2 étend les paramètres mnémoniques et le sel en utilisant 2048 cycles de hachage avec l&#39;algorithme HMAC-SHA512, produisant une valeur de 512 bits comme sortie finale. Cette valeur de 512 bits est la valeur d'amorçage.</li>
</ol>
<simpara><xref linkend="fig_5_7"/> montre comment un mnémonique est utilisé pour générer une valeur d&#8217;amorçage.</simpara>
<figure id="fig_5_7"><title>Du mnémonique à la valeur d&#8217;amorçage</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0507.png"/>
  </imageobject>
  <textobject><phrase>&quot;Du mnémonique à la valeur d'amorçage&quot;</phrase></textobject>
</mediaobject>
</figure>
<tip>
<simpara>La fonction d&#39;étirement de clé, avec ses 2048 tours de hachage, est une protection très efficace contre les attaques par force brute contre le mnémonique ou la phrase secrète. Cela rend extrêmement coûteux (en calcul) d&#39;essayer plus de quelques milliers de combinaisons de mots de passe et de mnémoniques, alors que le nombre de graines dérivées possibles est vaste (2 <superscript> 512 </superscript>).</simpara>
</tip>
<simpara>Les tableaux <a data-type="xref" href="#mnemonic_128_no_pass" data-xrefstyle="select: labelnumber">#mnemonic_128_no_pass</a>, <a data-type="xref" href="#mnemonic_128_w_pass" data-xrefstyle="select: labelnumber">#mnemonic_128_w_pass</a> et <a data-type="xref" href="#mnemonic_256_no_pass" data-xrefstyle="select: labelnumber">#mnemonic_256_no_pass</a> montrent quelques exemples de codes mnémoniques et les valeurs d&#8217;amorçage qu&#39;ils produisent (avec ou sans phrase secrète).</simpara>
<table id="mnemonic_128_no_pass"
frame="all"
rowsep="1" colsep="1"
>
<title>Code mnémonique d&#39;entropie 128 bits, sans phrase secrète, valeur d&#8217;amorçage résultante</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Entrée d&#39;entropie (128 bits)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>0c1e24e5917779d297e14d45f14e1a1a</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Mnémonique (12 mots)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>army van defense carry jealous true garbage claim echo media make crunch</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Phrase secrète</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>(rien)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Valeur d&#8217;amorçage (512 bits)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39</literal>
<literal>a88b76373733891bfaba16ed27a813ceed498804c0570</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="mnemonic_128_w_pass"
frame="all"
rowsep="1" colsep="1"
>
<title>Code mnémonique d&#39;entropie 128 bits, avec phrase secrète, valeur d&#8217;amorçage résultante</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Entrée d&#39;entropie (128 bits)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>0c1e24e5917779d297e14d45f14e1a1a</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Mnémonique (12 mots)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>army van defense carry jealous true garbage claim echo media make crunch</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Phrase secrète</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>SuperDuperSecret</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Valeur d&#8217;amorçage (512 bits)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28ab3ab091897d0</literal>
<literal>715861dc8a18358f80b79d49acf64142ae57037d1d54</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="mnemonic_256_no_pass"
frame="all"
rowsep="1" colsep="1"
>
<title>Code mnémonique d&#39;entropie 256 bits, sans phrase secrète, valeur d&#8217;amorçage résultante</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Entrée d&#39;entropie (256 bits)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Mnémonique (24 mots)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Phrase secrète</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>(rien)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis role="strong">Valeur d&#8217;amorçge (512 bits)</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3a04356e53d062e5</literal>
<literal>5f1e0deaa082df8d487381379df848a6ad7e98798404</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<tip>
<simpara>De nombreux portefeuilles ne permettent pas la création de portefeuilles avec plus d&#39;une phrase mnémonique de 12 mots. Vous remarquerez dans les tableaux ci-dessus que malgré les longueurs uniques d&#39;entrée d&#39;entropie, la taille de la valeur d&#8217;amorçage reste la même (512 bits). Du point de vue de la sécurité, la quantité d&#39;entropie réellement utilisée pour la production de portefeuilles HD est d&#39;environ 128 bits, ce qui équivaut à 12 mots. Fournir plus de 12 mots produit une entropie supplémentaire qui n&#39;est pas nécessaire, et cette entropie est <emphasis>inutilisée</emphasis>  pour la dérivation de la valeur d&#8217;amorçage de la manière que l&#39;on pourrait initialement soupçonner. Du point de vue de la convivialité, 12 mots sont également plus faciles à écrire, à sauvegarder et à stocker.</simpara>
</tip>
</section>
<section id="mnemonic_passphrase">
<title>Phrase secrète facultative dans BIP-39</title>
<simpara><indexterm>
  <primary>&quot;phrases secrètes&quot;</primary>
</indexterm>La norme BIP-39 permet l&#39;utilisation d&#39;une phrase secrète facultative dans la dérivation de la valeur d&#8217;amorçage. Si aucune phrase secrète n&#39;est utilisée, le mnémonique est étiré avec un sel constitué de la chaîne constante <literal>&quot;mnémonique&quot;</literal>, produisant une graine spécifique de 512 bits à partir de n&#39;importe quel mnémonique donné. Si une phrase secrète est utilisée, la fonction d&#39;étirement produit une valeur d&#8217;amorçage <emphasis>différente</emphasis> à partir de ce même mnémonique. En fait, étant donné un seul mnémonique, chaque phrases secrètes possible conduit à une valeurs d&#8217;amorçage différente. Essentiellement, il n&#39;y a pas de &quot;mauvaise&quot; phrase secrète. Toutes les phrases secrètes sont valides et mènent toutes à des valeurs d&#8217;amorçage différentes, formant un vaste ensemble de portefeuilles non initialisés possibles. L&#39;ensemble des portefeuilles possibles est si grand (2 <superscript>512</superscript>) qu&#39;il n&#39;y a aucune possibilité pratique de forcer brutalement ou de deviner accidentellement celui qui est utilisé.</simpara>
<tip>
<simpara>Il n&#39;y a pas de &quot;mauvaises&quot; phrases secrètes dans BIP-39. Chaque phrase de passe mène à un portefeuille qui, à moins qu&#39;il n&#39;ait été utilisé auparavant, sera vide.</simpara>
</tip>
<simpara>La phrase secrète facultative crée deux fonctionnalités importantes :</simpara>
<itemizedlist>
<listitem>
<simpara>
Un deuxième facteur (quelque chose de mémorisé) qui rend un mnémonique inutile par lui-même, protégeant les sauvegardes mnémoniques de la compromission par un voleur.
</simpara>
</listitem>
<listitem>
<simpara>
Une forme de déni plausible ou &quot;portefeuille sous contrainte&quot;, où une phrase secrète choisie mène à un portefeuille avec une petite quantité de fonds utilisée pour distraire un attaquant du &quot;vrai&quot; portefeuille qui contient la majorité des fonds.
</simpara>
</listitem>
</itemizedlist>
<simpara>Cependant, il est important de noter que l&#39;utilisation d&#39;une phrase secrète introduit également un risque de perte :</simpara>
<itemizedlist>
<listitem>
<simpara>
Si le propriétaire du portefeuille est incapacité ou décédé et que personne d&#39;autre ne connaît la phrase secrète, le code mnémonique est inutile et tous les fonds stockés dans le portefeuille sont perdus à jamais.
</simpara>
</listitem>
<listitem>
<simpara>
À l&#39;inverse, si le propriétaire sauvegarde la phrase secrète au même endroit que le code mnémonique, cela va à l&#39;encontre de l&#39;objectif d&#39;un deuxième facteur.
</simpara>
</listitem>
</itemizedlist>
<simpara>Bien que les phrases secrètes soient très utiles, elles ne doivent être utilisées qu&#39;en combinaison avec un processus soigneusement planifié de sauvegarde et de récupération, compte tenu de la possibilité de survivre au propriétaire et de permettre à sa famille de récupérer le patrimoine de la cryptomonnaie.</simpara>
</section>
<section id="_travailler_avec_des_codes_mnémoniques">
<title>Travailler avec des codes mnémoniques</title>
<simpara>BIP-39 est implémenté en tant que bibliothèque dans de nombreux langages de programmation différents :</simpara>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/trezor/python-mnemonic">python-mnemonic</ulink>
</term>
<listitem>
<simpara>
L&#39;implémentation de référence de la norme par l&#39;équipe SatoshiLabs qui a proposé BIP-39, en Python
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoinjs/bip39">bitcoinjs/bip39</ulink>
</term>
<listitem>
<simpara>
Une implémentation de BIP-39, dans le cadre du populaire framework bitcoinJS, en JavaScript
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/libbitcoin/libbitcoin/blob/master/src/wallet/mnemonic.cpp">libbitcoin/mnemonic</ulink>
</term>
<listitem>
<simpara>
Une implémentation de BIP-39, dans le cadre du populaire framework Libbitcoin, en <span class="keep-together">C++</span>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="_créer_un_portefeuille_hd_à_partir_de_la_valeur_d_8217_amorçage">
<title>Créer un portefeuille HD à partir de la valeur d&#8217;amorçage</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;technologie de&quot;</secondary><tertiary>&quot;création de portefeuilles HD à partir d&#39;une valeurs d&#8217;amorçage racine&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;technologie de&quot;</primary><secondary>&quot;création de portefeuilles HD à partir d&#39;une valeurs d&#8217;amorçage racine&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;création de portefeuilles HD à partir d&#39;une valeurs d&#8217;amorçage racine&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;valeurs d&#8217;amorçage racine&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles déterministes hiérarchiques (HD)&quot;</primary>
</indexterm>Les portefeuilles HD sont créé à partir d&#39;une seule <emphasis>valeur d&#8217;amorçage racine</emphasis>, qui est un nombre aléatoire de 128, 256 ou 512 bits. Le plus souvent, cette valeur d&#8217;amorçage est générée à partir d&#39;un <emphasis>mnemonique</emphasis> comme détaillé dans la section précédente.</simpara>
<simpara>Chaque clé du portefeuille HD est dérivée de manière déterministe de cette valeur d&#8217;amorçage racine, ce qui permet de recréer l&#39;intégralité du portefeuille HD à partir de cette valeur d&#8217;amorçage dans n&#39;importe quel portefeuille HD compatible. Cela facilite la sauvegarde, la restauration, l&#39;exportation et l&#39;importation de portefeuilles HD contenant des milliers, voire des millions de clés en transférant simplement uniquement le mnémonique dont la valeur d&#8217;amorçage racine est dérivée.</simpara>
<simpara>Le processus de création des clés principales et du code de chaîne principal pour un portefeuille HD est illustré dans <xref linkend="HDWalletFromSeed"/>.</simpara>
<figure id="HDWalletFromSeed"><title>Création de clés principales et de code de chaîne à partir d&#39;une valeur d&#8217;amorçage racine</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0509.png"/>
  </imageobject>
  <textobject><phrase>HDWalletFromRootSeed</phrase></textobject>
</mediaobject>
</figure>
<simpara>La valeur d&#8217;amorçage racine est entrée dans l&#39;algorithme HMAC-SHA512 et le hachage résultant est utilisé pour créer une <emphasis>clé privée principale</emphasis> (m) et un <emphasis>code de chaîne principal</emphasis> (c).</simpara>
<simpara>La clé privée principale (m) génère ensuite une clé publique principale correspondante (M) en utilisant le processus normal de multiplication de courbe elliptique <literal>m * G</literal> que nous avons vu dans <xref linkend="pubkey"/>.</simpara>
<simpara>Le code de chaîne (c) est utilisé pour introduire de l&#39;entropie dans la fonction qui crée des clés enfants à partir des clés parents, comme nous le verrons dans la section suivante.</simpara>
<section id="_dérivation_de_clé_enfant_privée">
<title>Dérivation de clé enfant privée</title>
<simpara><indexterm>
  <primary>&quot;dérivation de la clé-enfant (CKD)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clé publique et privé&quot;</primary><secondary>&quot;dérivation de clé-enfant (CKD)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;dérivation de clé-enfant (CKD)&quot;</primary>
</indexterm>Les portefeuilles HD utilisent une fonction <emphasis>dérivation de la clé-enfant</emphasis> (CKD) pour dériver les clés enfants à partir des clés parents.</simpara>
<simpara>Les fonctions de dérivation de la clé-enfant sont basées sur une fonction de hachage unidirectionnelle qui combine :</simpara>
<itemizedlist>
<listitem>
<simpara>
Une clé privée ou publique parent (clé compressée ECDSA)
</simpara>
</listitem>
<listitem>
<simpara>
Une valeur d&#8217;amorçage appelée code de chaîne (256 bits)
</simpara>
</listitem>
<listitem>
<simpara>
Un numéro d&#39;index (32 bits)
</simpara>
</listitem>
</itemizedlist>
<simpara>Le code de chaîne est utilisé pour introduire des données aléatoires déterministes dans le processus, de sorte que la connaissance de l&#39;index et d&#39;une clé-enfant ne suffit pas pour dériver d&#39;autres clés-enfants. Connaître une clé enfant ne permet pas de retrouver ses frères et sœurs, sauf si vous disposez également du code chaîne. La valeur d&#8217;amorçage de code de chaîne initiale (à la racine de l&#39;arborescence) est créée à partir de la valeur d&#8217;amorçage, tandis que les codes de chaîne enfants suivants sont dérivés de chaque code de chaîne parent.</simpara>
<simpara>Ces trois éléments (clé parent, code de chaîne et index) sont combinés et hachés pour générer des clés enfants, comme suit.</simpara>
<simpara>La clé publique parent, le code de chaîne et le numéro d&#39;index sont combinés et hachés avec l&#39;algorithme HMAC-SHA512 pour produire un hachage de 512 bits. Ce hachage de 512 bits est divisé en deux moitiés de 256 bits. Les 256 bits de la moitié droite de la sortie de hachage deviennent le code de chaîne pour l&#39;enfant. Les 256 bits de la moitié gauche du hachage sont ajoutés à la clé parent pour produire la clé privée enfant. Dans <xref linkend="CKDpriv"/>, nous voyons cela illustré avec l&#39;index mis à 0 pour produire l&#39;enfant &quot;zéro&quot; (premier par index) du parent.</simpara>
<figure id="CKDpriv"><title>Étendre une clé privée parent pour créer une clé privée enfant</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0510.png"/>
  </imageobject>
  <textobject><phrase>ChildPrivateDerivation</phrase></textobject>
</mediaobject>
</figure>
<simpara>Changer l&#39;index nous permet d&#39;étendre le parent et de créer les autres enfants dans la séquence, par exemple, Enfant 0, Enfant 1, Enfant 2, etc. Chaque clé parent peut avoir 2 147 483 647 (2<superscript>31</superscript>) enfants (2<superscript>31</superscript> est moitié de la plage entière 2<superscript>32</superscript> disponible car l&#39;autre moitié est réservée à un type spécial de dérivation dont nous parlerons plus loin dans ce chapitre).</simpara>
<simpara>En répétant le processus un niveau plus bas dans l&#39;arbre, chaque enfant peut à son tour devenir parent et créer ses propres enfants, dans un nombre infini de générations.</simpara>
</section>
<section id="_utilisation_de_clés_enfants_dérivées">
<title>Utilisation de clés enfants dérivées</title>
<simpara>Les clés privées enfants ne peuvent pas être distinguées des clés non déterministes (aléatoires). Comme la fonction de dérivation est une fonction à sens unique, la clé enfant ne peut pas être utilisée pour trouver la clé parent. La clé enfant ne peut pas non plus être utilisée pour trouver des frères et sœurs. Si vous avez le n<subscript>ième</subscript> enfant, vous ne pouvez pas trouver ses frères et sœurs, tels que l&#39;enfant n–1 ou l&#39;enfant n+1, ou tout autre enfant faisant partie de la séquence. Seuls la clé parent et le code de chaîne peuvent dériver tous les enfants. Sans le code de chaîne enfant, la clé enfant ne peut pas non plus être utilisée pour dériver des petits-enfants. Vous avez besoin à la fois de la clé privée enfant et du code de chaîne enfant pour démarrer une nouvelle branche et dériver des petits-enfants.</simpara>
<simpara>Alors, à quoi peut servir la clé privée enfant seule ? Il peut être utilisé pour créer une clé publique et une adresse Bitcoin. Ensuite, il peut être utilisé pour signer des transactions afin de dépenser tout ce qui est payé à cette adresse.</simpara>
<tip>
<simpara>Une clé privée enfant, la clé publique correspondante et l&#39;adresse Bitcoin sont toutes indiscernables des clés et des adresses créées au hasard. Le fait qu&#39;ils fassent partie d&#39;une séquence n&#39;est pas visible en dehors de la fonction de portefeuille HD qui les a créés. Une fois créées, elles fonctionnent exactement comme des clés &quot;normales&quot;.</simpara>
</tip>
</section>
<section id="_touches_étendues">
<title>Touches étendues</title>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;clés étendues&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;clés étendues&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clés étendues&quot;</primary>
</indexterm>Comme nous l&#39;avons vu précédemment, la fonction de dérivation de clé peut être utilisée pour créer des enfants à n&#39;importe quel niveau de l&#39;arborescence, en fonction sur les trois entrées : une clé, un code chaîne et l&#39;index de l&#39;enfant souhaité. Les deux ingrédients essentiels sont la clé et le code de chaîne, et combinés, ils s&#39;appellent une <emphasis>clé étendue</emphasis>. Le terme &quot;clé étendue&quot; pourrait également être considéré comme une &quot;clé extensible&quot; car une telle clé peut être utilisée pour dériver des enfants.</simpara>
<simpara>Les clés étendues sont stockées et représentées simplement comme la concaténation de la clé de 256 bits et du code de chaîne de 256 bits dans une séquence de 512 bits. Il existe deux types de clés étendues. Une clé privée étendue est la combinaison d&#39;une clé privée et d&#39;un code de chaîne et peut être utilisée pour dériver des clés privées enfants (et à partir de celles-ci, des clés publiques enfants). Une clé publique étendue est une clé publique et un code de chaîne, qui peuvent être utilisés pour créer des clés publiques enfants (<emphasis>public uniquement</emphasis>), comme décrit dans <xref linkend="public_key_derivation"/>.</simpara>
<simpara>Considérez une clé étendue comme la racine d&#39;une branche dans l&#39;arborescence du portefeuille HD. Avec la racine de la branche, vous pouvez dériver le reste de la branche. La clé privée étendue peut créer une branche complète, tandis que la clé publique étendue peut créer <emphasis>uniquement</emphasis> une branche de clés publiques.</simpara>
<tip>
<simpara>Une clé étendue se compose d&#39;une clé privée ou publique et d&#39;un code de chaîne. Une clé étendue peut créer des enfants, générant sa propre branche dans l&#39;arborescence. Le partage d&#39;une clé étendue donne accès à l&#39;ensemble de la branche.</simpara>
</tip>
<simpara>Les clés étendues sont encodées à l&#39;aide de Base58Check, pour exporter et importer facilement entre différents portefeuilles compatibles BIP-32. Le codage Base58Check pour les clés étendues utilise une somme de contrôle qui se traduit par le préfixe &quot;xprv&quot; et &quot;xpub&quot; lorsqu&#39;il est codé en caractères Base58 pour les rendre facilement reconnaissables. Étant donné que la clé étendue est de 512 ou 513 bits, elle est également beaucoup plus longue que les autres chaînes codées en Base58Check que nous avons vues précédemment.</simpara>
<simpara>Voici un exemple de clé <emphasis>privée</emphasis> étendue, codée en Base58Check :</simpara>
<screen>xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c</screen>
<simpara>Voici la clé <emphasis>publique</emphasis> étendue correspondante, codée en Base58Check :</simpara>
<screen>xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</screen>
</section>
<section id="public__child_key_derivation">
<title>Dérivation de la clé enfant publique</title>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;dérivation de clé publique enfant&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;dérivation de clé publique enfant&quot;</primary>
</indexterm>Comme mentionné précédemment, une caractéristique très utile des portefeuilles HD est la possibilité de dériver des clés publiques enfant à partir de clés publiques parent, <emphasis>sans</emphasis> avoir les clés privées. Cela nous donne deux façons de dériver une clé publique enfant : soit à partir de la clé privée enfant, soit directement à partir de la clé publique parent.</simpara>
<simpara>Une clé publique étendue peut donc être utilisée pour dériver toutes les clés <emphasis>publiques</emphasis> (et uniquement les clés publiques) dans cette branche de la structure du portefeuille HD.</simpara>
<simpara>Ce raccourci peut être utilisé pour créer des déploiements très sécurisés à clé publique uniquement dans lesquels un serveur ou une application possède une copie d&#39;une clé publique étendue et aucune clé privée. Ce type de déploiement peut produire un nombre infini de clés publiques et d&#39;adresses Bitcoin, mais ce type de déploiement ne permet pas dépenser l&#39;argent envoyé à ces adresses. Pendant ce temps, sur un autre serveur plus sécurisé, la clé privée étendue peut dériver toutes les clés privées correspondantes pour signer des transactions et dépenser de l&#39;argent.</simpara>
<simpara>Une application courante de cette solution consiste à installer une clé publique étendue sur un serveur Web qui sert une application de commerce électronique. Le serveur Web peut utiliser la fonction de dérivation de clé publique pour créer une nouvelle adresse Bitcoin pour chaque transaction (par exemple, pour le panier d&#39;un client). Le serveur Web n&#39;aura aucune clé privée qui serait vulnérable au vol. Sans les portefeuilles HD, la seule façon d&#39;y parvenir est de générer des milliers d&#39;adresses Bitcoin sur un serveur sécurisé séparé, puis de les précharger sur le serveur de commerce électronique. Cette approche est lourde et nécessite une maintenance constante pour s&#39;assurer que le serveur de commerce électronique ne &quot;manque&quot; pas d&#39;adresses.</simpara>
<simpara><indexterm>
  <primary>&quot;stockage à froid&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;stockage&quot;</primary><secondary>&quot;stockage à froid&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;stockage à froid&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;portefeuilles matériels&quot;</primary>
</indexterm>Une autre application courante de cette solution est le stockage à froid ou les portefeuilles matériels. Dans ce scénario, la clé privée étendue peut être stockée sur un portefeuille papier ou un périphérique matériel (tel qu&#39;un portefeuille matériel Trezor), tandis que la clé publique étendue peut être conservée en ligne. L&#39;utilisateur peut créer des adresses &quot;de réception&quot; à volonté, tandis que les clés privées sont stockées en toute sécurité hors ligne. Pour dépenser les fonds, l&#39;utilisateur peut utiliser la clé privée étendue sur un client Bitcoin de signature hors ligne ou signer des transactions sur le périphérique de portefeuille matériel (par exemple, Trezor). <xref linkend="CKDpub"/> illustre le mécanisme d&#39;extension d&#39;une clé publique parent pour dériver des clés publiques enfants.</simpara>
<figure id="CKDpub"><title>Étendre une clé publique parent pour créer une clé publique enfant</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0511.png"/>
  </imageobject>
  <textobject><phrase>ChildPublicDerivation</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_dérivation_de_clé_enfant_renforcée">
<title>Dérivation de clé enfant renforcée</title>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;dérivation de clé enfant renforcée&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;dérivation de clé enfant renforcée&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;dérivation renforcée&quot;</primary>
</indexterm>La possibilité de dériver une branche de clés publiques à partir d&#39;un xpub est très utile, mais elle est potentiellement risquée. L&#39;accès à une xpub ne donne pas accès aux clés privées enfants. Cependant, étant donné que xpub contient le code de chaîne, si une clé privée enfant est connue ou divulguée d&#39;une manière ou d&#39;une autre, elle peut être utilisée avec le code de chaîne pour dériver toutes les autres clés privées enfants. Une seule clé privée enfant divulguée, associée à un code de chaîne parent, révèle toutes les clés privées de tous les enfants. Pire encore, la clé privée enfant associée à un code de chaîne parent peut être utilisée pour déduire la clé privée parent.</simpara>
<simpara>Pour contrer ce risque, les portefeuilles HD utilisent une fonction de dérivation alternative appelée <emphasis>dérivation renforcée</emphasis>, qui &quot;casse&quot; la relation entre la clé publique parent et le code de chaîne enfant. La fonction de dérivation renforcée utilise la clé privée parent pour dériver le code de chaîne enfant, au lieu de la clé publique parent. Cela crée un &quot;pare-feu&quot; dans la séquence parent/enfant, avec un code de chaîne qui ne peut pas être utilisé pour compromettre une clé privée parent ou sœur. La fonction de dérivation renforcée semble presque identique à la dérivation de clé privée enfant normale, sauf que la clé privée parent est utilisée comme entrée de la fonction de hachage, au lieu de la clé publique parent, comme indiqué dans le diagramme de <xref linkend="CKDprime"/>.</simpara>
<figure id="CKDprime"><title>Dérivation renforcée d&#39;une clé enfant ; omet la clé publique parent</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0513.png"/>
  </imageobject>
  <textobject><phrase>ChildHardPrivateDerivation</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">Lorsque la fonction de dérivation privée renforcée est utilisée, la clé privée enfant et le code de chaîne résultants sont complètement différents de ce qui résulterait de la fonction de dérivation normale. La &quot;branche&quot; de clés résultante peut être utilisée pour produire des clés publiques étendues qui ne sont pas vulnérables, car le code de chaîne qu&#39;elles contiennent ne peut pas être exploité pour révéler des clés privées. La dérivation renforcée est donc utilisée pour créer un &quot;trou&quot; dans l&#39;arborescence au-dessus du niveau où les clés publiques étendues sont utilisées.</simpara>
<simpara>En termes simples, si vous souhaitez utiliser la commodité d&#39;un xpub pour dériver des branches de clés publiques, sans vous exposer au risque d&#39;une fuite de code de chaîne, vous devez le dériver d&#39;une clé parent renforcée, plutôt que d&#39;une clé normale (non-renforcée) clé parent. En tant que meilleure pratique, les enfants de niveau 1 des clés principales sont toujours dérivés via la dérivation renforcée, pour éviter la compromission des clés principales.</simpara>
</section>
<section id="_numéros_d_39_index_pour_dérivation_normale_et_durcie">
<title>Numéros d&#39;index pour dérivation normale et durcie</title>
<simpara>Le numéro d&#39;index utilisé dans la fonction de dérivation est un entier de 32 bits. Pour distinguer facilement les clés dérivées par la fonction de dérivation normale des clés dérivées par dérivation renforcée, ce numéro d&#39;index est divisé en deux plages. Les numéros d&#39;index entre 0 et 2<superscript>31</superscript>–1 (0x0 à 0x7FFFFFFF) sont utilisés <emphasis>uniquement</emphasis> pour la dérivation normale. Les numéros d&#39;index entre 2<superscript>31</superscript> et 2<superscript>32</superscript>–1 (0x80000000 à 0xFFFFFFFF) sont utilisés <emphasis>uniquement</emphasis> pour la dérivation renforcée. Donc, si l&#39;indice est inférieur à 2<superscript>31</superscript>, l&#39;enfant est normal, alors que si l&#39;indice est égal ou supérieur à 2<superscript>31</superscript>, l&#39;enfant est renforcé.</simpara>
<simpara>Pour faciliter la lecture et l&#39;affichage du numéro d&#39;index, le numéro d&#39;index pour les enfants renforcés est affiché à partir de zéro, mais avec un symbole prime. La première clé enfant normale s&#39;affiche donc sous la forme 0, tandis que la première clé enfant renforcée (index 0x80000000) s&#39;affiche sous la forme 0<literal>&#x27;</literal>. Dans l&#39;ordre, la deuxième clé renforcée aurait l&#39;index 0x80000001 et serait affichée sous la forme 1<literal>&#x27;</literal>, et ainsi de suite. Lorsque vous voyez un index de portefeuille HD i<literal>&#x27;</literal>, cela signifie 2<superscript>31</superscript>+i.</simpara>
</section>
<section id="_identifiant_de_clé_de_portefeuille_hd_chemin">
<title>Identifiant de clé de portefeuille HD (chemin)</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles déterministes hiérarchiques (HD)&quot;</primary>
</indexterm>Les clés d&#39;un portefeuille HD sont identifiées à l&#39;aide d&#39;une convention de dénomination &quot;chemin&quot;, où chaque niveau de l&#39;arborescence est séparé par une barre oblique (/) (voir <xref linkend="table_4-8"/>). Les clés privées dérivées de la clé privée principale commencent par &quot;m&quot;. Les clés publiques dérivées de la clé publique principale commencent par « M ». Par conséquent, la première clé privée enfant de la clé privée principale est m/0. La première clé publique enfant est M/0. Le deuxième petit-enfant du premier enfant est m/0/1, et ainsi de suite.</simpara>
<simpara>L&#39;&quot;ascendance&quot; d&#39;une clé se lit de droite à gauche, jusqu&#39;à atteindre la clé maîtresse dont elle est issue. Par exemple, l&#39;identifiant m/x/y/z décrit la clé privée qui est le z-ième enfant de la clé privée parent m/x/y, qui est le y-ième enfant de la clé privée parent m/x, qui est le x-ième enfant de la clé privée principale parente m.</simpara>
<table id="table_4-8"
frame="all"
rowsep="1" colsep="1"
>
<title>Exemples de chemin de portefeuille HD</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Chemin HD </entry>
<entry align="left" valign="top"> Clé décrite</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>m/0</simpara></entry>
<entry align="left" valign="top"><simpara>La première (0) clé privée enfant de la clé privée maîtresse (m)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>m/0/0</simpara></entry>
<entry align="left" valign="top"><simpara>La première (0) clé privée enfant du premier enfant (m/0)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>m/0&#39;/0</simpara></entry>
<entry align="left" valign="top"><simpara>Le premier (0) enfant normal du premier enfant <emphasis>renforcé</emphasis> (m/0&#39;)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>m/1/0</simpara></entry>
<entry align="left" valign="top"><simpara>La première (0) clé privée enfant du deuxième enfant (m/1)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>M/23/17/0/0</simpara></entry>
<entry align="left" valign="top"><simpara>La première (0) clé publique enfant du premier enfant (M/23/17/0) du 18ème enfant (M/23/17) du 24ème enfant (M/23)</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="_naviguer_dans_l_39_arborescence_du_portefeuille_hd">
<title>Naviguer dans l&#39;arborescence du portefeuille HD</title>
<simpara>La structure arborescente du portefeuille HD offre une grande flexibilité. Chaque clé étendue parent peut avoir 4 milliards d&#39;enfants : 2 milliards d&#39;enfants normaux et 2 milliards d&#39;enfants renforcés. Chacun de ces enfants peut avoir 4 milliards d&#39;enfants supplémentaires, et ainsi de suite. L&#39;arbre peut être aussi profond que vous le souhaitez, avec un nombre infini de générations. Avec toute cette flexibilité, cependant, il devient assez difficile de naviguer dans cet arbre infini. Il est particulièrement difficile de transférer des portefeuilles HD entre les implémentations, car les possibilités d&#39;organisation interne en succursales et sous-succursales sont infinies.</simpara>
<simpara>Deux BIP offrent une solution à cette complexité en créant des propositions de normes pour la structure des arborescences de portefeuille HD. BIP-43 propose l&#39;utilisation du premier index enfant renforcé comme identifiant spécial qui signifie le &quot;but&quot; de la structure arborescente. Basé sur BIP-43, un portefeuille HD ne devrait utiliser qu&#39;une seule branche de niveau 1 de l&#39;arborescence, le numéro d&#39;index identifiant la structure et l&#39;espace de noms du reste de l&#39;arborescence en définissant son objectif. Par exemple, un portefeuille HD utilisant uniquement la branche m/i<literal>&#x27;</literal>/ est destiné à signifier un objectif spécifique et cet objectif est identifié par le numéro d&#39;index &quot;i&quot;.</simpara>
<simpara>En étendant cette spécification, BIP-44 propose une structure multicompte en tant que numéro &quot;d&#39;objet&quot; <literal>44&#39;</literal> sous BIP-43. Tous les portefeuilles HD suivant la structure BIP-44 sont identifiés par le fait qu&#39;ils n&#39;utilisent qu&#39;une seule branche de l&#39;arborescence : m/44&#39;/.</simpara>
<simpara>BIP-44 spécifie la structure comme étant composée de cinq niveaux d&#39;arborescence prédéfinis :</simpara>
<screen>m / but&amp;#39; / type_monnaie&amp;#39; / compte&amp;#39; / change / index_adresse</screen>
<simpara>Le &quot;but&quot; de premier niveau est toujours réglé sur <literal>44&#39;</literal>. Le &quot;type_monnaie&quot; de deuxième niveau spécifie le type de pièce de cryptomonnaie, permettant des portefeuilles HD multidevises où chaque devise a son propre sous-arbre sous le deuxième niveau. Il y a trois devises définies pour l&#39;instant : Bitcoin est m/44&#x27;/0&#x27;, Bitcoin Testnet est m/44<literal>&#x27;</literal>/1<literal>&#x27;</literal>, et Litecoin est m/44<literal>&#x27;</literal>/2<literal>&#x27;</literal>.</simpara>
<simpara>Le troisième niveau de l&#39;arborescence est &quot;compte&quot;, qui permet aux utilisateurs de subdiviser leurs portefeuilles en sous-comptes logiques distincts, à des fins comptables ou organisationnelles. Par exemple, un portefeuille HD peut contenir deux &quot;comptes&quot; bitcoin : m/44<literal>&#x27;</literal>/0<literal>&#x27;</literal>/0<literal>&#x27;</literal> et m/44<literal>&#x27;</literal>/0<literal>&#x27;</literal>/1<literal>&#x27;</literal>. Chaque compte est la racine de sa propre sous-arborescence.</simpara>
<simpara><indexterm>
  <primary>&quot;clés et adresses&quot;</primary><secondary>see=&quot;aussi clés publiques et privées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi clés publiques et privées&quot;</primary>
</indexterm> Au quatrième niveau, &quot;change&quot;, un portefeuille HD a deux sous-arborescences, une pour créer des adresses de réception et une pour créer des adresses de modification. Notez qu&#39;alors que les niveaux précédents utilisaient une dérivation renforcée, ce niveau utilise une dérivation normale. Cela permet à ce niveau de l&#39;arborescence d&#39;exporter des clés publiques étendues pour une utilisation dans un environnement non sécurisé. Les adresses utilisables sont dérivées par le portefeuille HD en tant qu&#39;enfants du quatrième niveau, faisant du cinquième niveau de l&#39;arborescence l'&quot;index_adresse&quot;. Par exemple, la troisième adresse de réception pour les paiements en bitcoins dans le compte principal serait M/44<literal>&#x27;</literal>/0<literal>&#x27;</literal>/0<literal>&#x27;</literal>/0/2. <xref linkend="table_4-9"/> montre quelques exemples supplémentaires.</simpara>
<table id="table_4-9"
frame="all"
rowsep="1" colsep="1"
>
<title>Exemples de structure de portefeuille HD BIP-44</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Chemin HD </entry>
<entry align="left" valign="top"> Clé décrite</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>M/44<literal>&#39;</literal>/0<literal>&#39;</literal>/0<literal>&#39;</literal>/0/2</simpara></entry>
<entry align="left" valign="top"><simpara>La troisième clé publique de réception pour le compte bitcoin principal</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>M/44<literal>&#39;</literal>/0<literal>&#39;</literal>/3<literal>&#39;</literal>/1/14</simpara></entry>
<entry align="left" valign="top"><simpara>La quinzième clé publique de changement d&#39;adresse pour le quatrième compte bitcoin</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>m/44<literal>&#39;</literal>/2<literal>&#39;</literal>/0<literal>&#39;</literal>/0/1</simpara></entry>
<entry align="left" valign="top"><simpara>La deuxième clé privée du compte principal Litecoin, pour la signature des transactions</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section id="_utilisation_d_39_une_clé_publique_étendue_sur_une_boutique_en_ligne">
<title>Utilisation d&#39;une clé publique étendue sur une boutique en ligne</title>
<simpara><indexterm>
  <primary>&quot;portefeuilles&quot;</primary><secondary>&quot;technologie de&quot;</secondary><tertiary>&quot;utilisation de clés publiques étendues sur les boutiques en ligne&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;technologie de&quot;</primary><secondary>&quot;utilisation de clés publiques étendues sur les boutiques en ligne&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;utilisation de clés publiques étendues sur les boutiques en ligne&quot;</primary>
</indexterm> Voyons comment les portefeuilles HD sont utilisés en poursuivant notre histoire avec la boutique en ligne de Gabriel.<indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;commerce électronique&quot;</secondary><tertiary>id=&quot;gabrielfivetwo&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;commerce électronique&quot;</primary><secondary>id=&quot;gabrielfivetwo&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;gabrielfivetwo&quot;</primary>
</indexterm></simpara>
<simpara>Gabriel a d&#39;abord créé sa boutique en ligne comme passe-temps, basé sur une simple page Wordpress hébergée. Son magasin était assez simple avec seulement quelques pages et un bon de commande avec une seule adresse Bitcoin.</simpara>
<simpara>Gabriel a utilisé la première adresse Bitcoin générée par son appareil Trezor comme adresse Bitcoin principale pour son magasin. De cette façon, tous les paiements entrants seraient versés à une adresse contrôlée par son portefeuille matériel Trezor.</simpara>
<simpara>Les clients soumettraient une commande en utilisant le formulaire et enverraient le paiement à l&#39;adresse Bitcoin publiée de Gabriel, déclenchant un e-mail avec les détails de la commande à traiter par Gabriel. Avec seulement quelques commandes par semaine, ce système fonctionnait assez bien.</simpara>
<simpara>Cependant, la petite boutique en ligne a connu un certain succès et a attiré de nombreuses commandes de la communauté locale. Bientôt, Gabriel a été submergé. Avec toutes les commandes payées à la même adresse, il devenait difficile de faire correspondre correctement les commandes et les transactions, en particulier lorsque plusieurs commandes pour le même montant arrivaient à proximité.</simpara>
<simpara>Le portefeuille HD de Gabriel offre une bien meilleure solution grâce à la possibilité de dériver des clés enfants publiques sans connaître les clés privées. Gabriel peut charger une clé publique étendue (xpub) sur son site Web, qui peut être utilisée pour dériver une adresse unique pour chaque commande client. Gabriel peut dépenser les fonds de son Trezor, mais le xpub chargé sur le site Web ne peut que générer des adresses et recevoir des fonds. Cette fonctionnalité des portefeuilles HD est une excellente fonctionnalité de sécurité. Le site Web de Gabriel ne contient aucune clé privée et n&#39;a donc pas besoin de niveaux de sécurité élevés.</simpara>
<simpara>Pour exporter le xpub, Gabriel utilise l&#39;application de bureau Trezor Suite en conjonction avec le portefeuille matériel Trezor. L&#39;appareil Trezor doit être branché pour que les clés publiques soient exportées. Notez que les portefeuilles matériels n&#39;exporteront jamais de clés privées, celles-ci restant toujours sur l&#39;appareil. <xref linkend="export_xpub"/> montre ce que Gabriel voit dans Trezor Suite lors de l&#39;exportation du xpub.</simpara>
<figure id="export_xpub"><title>Exportation d&#39;un xpub à partir d&#39;un portefeuille matériel Trezor</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0512.png"/>
  </imageobject>
  <textobject><phrase>&quot;Exporter le xpub du Trezor&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara>Gabriel copie le xpub dans le logiciel de boutique bitcoin de sa boutique en ligne. Il utilise <emphasis>BTCPay Server</emphasis>, qui est une boutique en ligne open source pour une variété de plates-formes d&#39;hébergement Web et de contenu. BTCPay Server utilise le xpub pour générer une adresse unique pour chaque achat. <indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;gabrielfivetwo&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;gabrielfivetwo&quot;</primary>
</indexterm></simpara>
<section id="_découverte_et_gestion_de_compte">
<title>Découverte et gestion de compte</title>
<simpara>L&#39;entreprise de Gabriel est florissante. Il a fourni sa clé publique étendue (xpub) à <emphasis>BTCPay Server</emphasis>, qui génère des adresses uniques pour les clients de son site Web. Chaque fois qu&#39;un client du site Web de Gabriel clique sur le bouton &quot;Commander&quot; avec une modalité de paiement spécifiée (dans ce cas, bitcoin), <emphasis>BTCPay Server</emphasis> génère une nouvelle adresse pour ce client. Plus précisément, <emphasis>BTCPay Server</emphasis> itère sur l&#39;arborescence <emphasis>address_index</emphasis> pour créer une nouvelle adresse à afficher au client, comme défini par BIP-44. Si le client décide de changer de méthode de paiement ou d&#39;abandonner complètement la transaction, cette adresse Bitcoin n&#39;est pas utilisée et ne sera pas utilisée pour un autre client tout de suite.</simpara>
<simpara>À un moment donné, le site Web de Gabriel peut avoir un grand nombre d&#39;adresses en attente pour les clients effectuant des achats, dont certaines peuvent rester inutilisées et éventuellement expirer. Une fois ces adresses expirées, <emphasis>BTCPay Server</emphasis> réutilisera ces adresses pour combler le vide dans l'<emphasis>index_adresse</emphasis>, mais il devient clair qu&#39;il peut y avoir des vides entre les feuilles d'<emphasis>index_adresse</emphasis> de l&#39;arbre déterministe hiérarchique où se trouve réellement l&#39;argent.</simpara>
<simpara>Disons que Gabriel est intéressé à voir son montant total de bitcoin gagné sur un portefeuille de surveillance uniquement (celui qui vous permet de voir l&#39;historique des transactions, mais pas de dépenser des fonds) qui est distinct du serveur BTCPay mais également conforme à la norme BIP-44 . Comment ce portefeuille séparé devrait-il rechercher des fonds dans ce vaste arbre hiérarchique, et quand devrait-il cesser de chercher ? La plupart des portefeuilles suivent généralement un processus itératif qui utilise une limite prédéfinie, connue sous le nom de <emphasis>gap limit</emphasis>. Si, lors de la recherche d&#39;adresses utilisées, le portefeuille ne trouve pas d&#39;adresses utilisées d&#39;affilée au-delà de ce nombre limite, il arrête de rechercher la chaîne d&#39;adresses. La limite d&#39;écart par défaut est généralement fixée à 20. Ceci est détaillé dans <anchor id="bip-44" xreflabel="[bip-44]"/><ulink url="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</ulink>.</simpara>
<tip>
<simpara>Les limites d&#39;écart expliquent le phénomène selon lequel l&#39;importation d&#39;un portefeuille peut afficher un solde incorrect ou nul. Les fonds ne sont pas perdus, mais plutôt, la fonction d&#39;importation de portefeuille n&#39;a pas traversé suffisamment de feuilles pour détecter pleinement les fonds. De nombreux portefeuilles permettent de modifier cette limite d&#39;écart par défaut, et Gabriel peut avoir besoin d&#39;augmenter cette limite pour permettre à son portefeuille d&#39;importer entièrement son historique de transactions.</simpara>
</tip>
</section>
</section>
</section>
</section>
<section id="transactions">
<title>Opérations</title>
<section id="ch06_intro">
<title>Présentation</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>see=&quot;aussi la sécurité&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi la sécurité&quot;</primary>
</indexterm>Les transactions sont la partie la plus importante du système Bitcoin. Tout le reste dans le bitcoin est conçu pour garantir que les transactions peuvent être créées, propagées sur le réseau, validées et finalement ajoutées au grand livre mondial des transactions (la chaîne de blocs). Les transactions sont des structures de données qui encodent le transfert de valeur entre les participants au système Bitcoin. Chaque transaction est une entrée publique dans la chaîne de blocs de bitcoin, le grand livre comptable mondial en partie double.</simpara>
<simpara>Dans ce chapitre, nous examinerons toutes les différentes formes de transactions, ce qu&#39;elles contiennent, comment les créer, comment elles sont vérifiées et comment elles deviennent partie intégrante de l&#39;enregistrement permanent de toutes les transactions. Lorsque nous utilisons le terme &quot;portefeuille&quot; dans ce chapitre, nous faisons référence au logiciel qui construit les transactions, et pas seulement à la base de données des clés.</simpara>
</section>
<section id="tx_structure">
<title>Transactions en détail</title>
<simpara><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;acheter du café&quot;</secondary><tertiary>id=&quot;alicesix&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;acheter du café&quot;</primary><secondary>id=&quot;alicesix&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;alicesix&quot;</primary>
</indexterm>Dans <xref linkend="ch02_bitcoin_overview"/>, nous avons examiné la transaction utilisée par Alice pour payer un café au comptoir à café de Bob à l&#39;aide d&#39;un explorateur de blocs (<xref linkend="alices_transactions_to_bobs_cafe"/>).</simpara>
<simpara>L&#39;application de l&#39;explorateur de blocs montre une transaction de &quot;l&#39;adresse&quot; d&#39;Alice à &quot;l&#39;adresse&quot; de Bob. Il s&#39;agit d&#39;une vue très simplifiée de ce qui est contenu dans une transaction. En fait, comme nous le verrons dans ce chapitre, une grande partie des informations affichées sont construites par l&#39;explorateur de blocs et ne se trouvent pas réellement dans la transaction.</simpara>
<figure id="alices_transactions_to_bobs_cafe"><title>Transaction d&#39;Alice au Bob&#39;s Café</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0208.png"/>
  </imageobject>
  <textobject><phrase>Alice Coffee Transaction</phrase></textobject>
</mediaobject>
</figure>
<section id="transactions_behind_the_scenes">
<title>Transactions: Dans les coulisses</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;détails des coulisses de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;détails des coulisses de&quot;</primary>
</indexterm> Dans les coulisses, une transaction réelle est très différente d&#39;une transaction fournie par un explorateur de blocs typique. En fait, la plupart des constructions de haut niveau que nous voyons dans les différentes interfaces utilisateur des applications bitcoin <emphasis>n&#39;existent pas réellement</emphasis> dans le système Bitcoin.</simpara>
<simpara>Nous pouvons utiliser l&#39;interface de ligne de commande de Bitcoin Core (<literal>getrawtransaction</literal> et <literal>decoderawtransaction</literal>) pour récupérer la transaction &quot;brute&quot; d&#39;Alice, la décoder et voir ce qu&#39;elle contient. Le résultat ressemble à ceci :</simpara>
<formalpara id="alice_tx"><title>La transaction d&#8217;Alice décodée</title><para>
<programlisting language="json" linenumbering="unnumbered">{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}</programlisting>
</para></formalpara>
<simpara>Vous remarquerez peut-être certaines choses à propos de cette transaction, principalement les choses qui manquent ! Où est l&#39;adresse d&#39;Alice ? Où est l&#39;adresse de Bob ? Où est l&#39;entrée 0.1 &quot;envoyée&quot; par Alice ? En bitcoin, il n&#39;y a pas de pièces, pas d&#39;expéditeurs, pas de destinataires, pas de soldes, pas de comptes et pas d&#39;adresses. Toutes ces choses sont construites à un niveau supérieur pour le bénéfice de l&#39;utilisateur, pour rendre les choses plus faciles à comprendre.</simpara>
<simpara>Vous pouvez également remarquer de nombreux champs étranges et indéchiffrables et des chaînes hexadécimales. Ne vous inquiétez pas, nous expliquerons en détail chaque champ affiché ici dans ce chapitre.</simpara>
</section>
</section>
<section id="tx_inputs_outputs">
<title>Sorties et entrées de transaction</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;sorties et entrées&quot;</secondary><tertiary>id=&quot;Tout06&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>id=&quot;Tout06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Tout06&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;sorties définies&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sorties définies&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties de transaction non dépensées (UTXO)&quot;)) )(((&quot;Ensembles UTXO&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;sorties et entrées&quot;</secondary><tertiary>&quot;caractéristiques de sortie&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;caractéristiques de sortie&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;caractéristiques de sortie&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;caractéristiques de sortie&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;caractéristiques de sortie&quot;</primary>
</indexterm>La base fondamentale d&#39;une transaction bitcoin est une <emphasis>sortie de transaction</emphasis>. Les sorties de transaction sont des morceaux indivisibles de monnaie bitcoin, enregistrés sur la chaîne de blocs et reconnus comme valides par l&#39;ensemble du réseau. Les nœuds complets Bitcoin suivent toutes les sorties disponibles et utilisables, appelées <emphasis>sorties de transaction non dépensées</emphasis>, ou <emphasis>UTXO</emphasis>. La collection de tous les UTXO est connue sous le nom d'<emphasis>ensemble UTXO</emphasis> et compte actuellement des millions d&#39;UTXO. L&#39;ensemble UTXO augmente à mesure que de nouveaux UTXO sont créés et diminue lorsque UTXO est consommé. Chaque transaction représente un changement (transition d&#39;état) dans l&#39;ensemble UTXO.</simpara>
<simpara><indexterm>
  <primary>&quot;soldes&quot;</primary>
</indexterm>Lorsque nous disons que le portefeuille d&#39;un utilisateur a &quot;reçu&quot; du bitcoin, nous voulons dire que le portefeuille a détecté sur la chaîne de blocs un UTXO pouvant être dépensé avec l&#39;une des clés contrôlées par ce portefeuille. Ainsi, le &quot;solde&quot; de bitcoins d&#39;un utilisateur est la somme de tous les UTXO que le portefeuille de l&#39;utilisateur peut dépenser et qui peuvent être dispersés parmi des centaines de transactions et des centaines de blocs. Le concept de solde est créé par l&#39;application de portefeuille. Le portefeuille calcule le solde de l&#39;utilisateur en scannant la chaîne de blocs et en agrégeant la valeur de tout UTXO que le portefeuille peut dépenser avec les clés qu&#39;il contrôle. La plupart des portefeuilles maintiennent une base de données ou utilisent un service de base de données pour stocker un ensemble de référence rapide de tous les UTXO qu&#39;ils peuvent dépenser avec les clés qu&#39;ils contrôlent.</simpara>
<simpara><indexterm>
  <primary>&quot;sorties de transaction dépensées (STXO)&quot;</primary>
</indexterm><xref linkend="utxo-stxo"/> affiche la chaîne de blocs à trois moments différents, alors que la chaîne de transaction de Joe à Gopesh est en cours de construction. Remarquez comment chaque transaction dépense un UTXO qui a été créé dans une transaction précédente, le transformant en une <emphasis>sortie de transaction dépensée</emphasis>, ou <emphasis>STXO</emphasis>. Puisque la transaction #1 (de Joe à Alice) dépense un seul UTXO (de Joe) et crée un seul UTXO (à Alice), elle ne modifie pas la taille de l&#39;ensemble UTXO. D&#39;autre part, les transactions #2 et #3 créent toutes deux des sorties de change à l&#39;expéditeur, dépensant un seul UTXO et créant deux UTXO (le paiement et la sortie de change). Par conséquent, chacun d&#39;eux augmente la taille de l&#39;ensemble UTXO de 1.</simpara>
<figure id="utxo-stxo"><title>Chaîne de transaction de Joe à Gopesh en cours de construction sur la chaîne de blocs</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0609.png"/>
  </imageobject>
  <textobject><phrase>&quot;Chaîne de transaction de Joe à Gopesh en cours de construction sur la blockchain&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
  <primary>&quot;satoshis&quot;</primary>
</indexterm>Une sortie de transaction peut avoir une valeur arbitraire (entière) libellée comme un multiple de satoshis. Tout comme les dollars peuvent être divisés jusqu&#39;à deux décimales sous forme de cents, le bitcoin peut être divisé jusqu&#39;à huit décimales sous forme de satoshis. Bien qu&#39;une sortie puisse avoir n&#39;importe quelle valeur arbitraire, une fois créée, elle est indivisible. Il s&#39;agit d&#39;une caractéristique importante des sorties qui doit être soulignée : les sorties sont des unités de valeur <emphasis>discrètes</emphasis> et <emphasis>indivisibles</emphasis>, libellées en satoshis entiers. Une production non dépensée ne peut être consommée dans son intégralité que par une transaction.</simpara>
<simpara><indexterm>
  <primary>&quot;change</primary><secondary>faire&quot;</secondary>
</indexterm>
<indexterm>
  <primary>faire&quot;</primary>
</indexterm>Si un UTXO est supérieur à la valeur souhaitée d&#39;une transaction, il doit toujours être consommé dans son intégralité et le changement doit être généré dans la transaction. En d&#39;autres termes, si vous avez un UTXO d&#39;une valeur de 20 bitcoins et que vous souhaitez payer seulement 1 bitcoin, votre transaction doit consommer l&#39;intégralité de l&#39;UTXO de 20 bitcoins et produire deux sorties : une payant 1 bitcoin au destinataire souhaité et une autre payant 19 bitcoin en échange. retour dans votre portefeuille. En raison de la nature indivisible des sorties de transaction, la plupart des transactions bitcoin devront générer du change.</simpara>
<simpara>Imaginez une cliente qui achète une boisson à 1,50 $, puise dans son portefeuille et essaie de trouver une combinaison de pièces et de billets de banque pour couvrir le coût de 1,50 $. L&#39;acheteur choisira la monnaie exacte si disponible, par exemple un billet d&#39;un dollar et deux quarts (un quart vaut 0,25 $), ou une combinaison de coupures plus petites (six quarts), ou si nécessaire, une unité plus grande comme un billet de 5 $. Si elle remet trop d&#39;argent, disons 5 $, au propriétaire du magasin, elle s&#39;attendra à 3,50 $ de monnaie, qu&#39;elle remettra dans son portefeuille et qu&#39;elle disposera pour de futures transactions.</simpara>
<simpara>De même, une transaction bitcoin doit être créée à partir de l&#39;UTXO d&#39;un utilisateur dans toutes les dénominations disponibles pour cet utilisateur. Les utilisateurs ne peuvent pas couper un UTXO en deux, pas plus qu&#39;ils ne peuvent couper un billet d&#39;un dollar en deux et l&#39;utiliser comme monnaie. L&#39;application de portefeuille de l&#39;utilisateur sélectionne généralement à partir de l&#39;UTXO disponible de l&#39;utilisateur pour composer un montant supérieur ou égal au montant de transaction souhaité.</simpara>
<simpara>Comme dans la vraie vie, l&#39;application bitcoin peut utiliser plusieurs stratégies pour satisfaire le montant de l&#39;achat : combiner plusieurs unités plus petites, trouver la monnaie exacte ou utiliser une seule unité supérieure à la valeur de la transaction et rendre la monnaie. Tout cet assemblage complexe d&#39;UTXO dépensables est effectué automatiquement par le portefeuille de l&#39;utilisateur et est invisible pour les utilisateurs. Cela n&#39;est pertinent que si vous construisez par programme des transactions brutes à partir d&#39;UTXO.</simpara>
<simpara>Une transaction consomme des sorties de transaction non dépensées précédemment enregistrées et crée de nouvelles sorties de transaction qui peuvent être consommées par une transaction future. De cette façon, des morceaux de valeur bitcoin passent d&#39;un propriétaire à l&#39;autre dans une chaîne de transactions consommant et créant des UTXO.</simpara>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;transactions coinbase&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;transactions coinbase&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions coinbase&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;transactions coinbase&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;transactions coinbase&quot;</primary>
</indexterm>L&#39;exception à la chaîne de sortie et d&#39;entrée est une type spécial de transaction appelé transaction <emphasis>coinbase</emphasis>, qui est la première transaction de chaque bloc. Cette transaction y est placée par le mineur &quot;gagnant&quot; et crée un tout nouveau bitcoin payable à ce mineur en récompense de l&#39;exploitation minière. Cette transaction coinbase spéciale ne consomme pas d&#39;UTXO ; à la place, il a un type spécial d&#39;entrée appelé &quot;coinbase&quot;. C&#39;est ainsi que la masse monétaire du bitcoin est créée pendant le processus de minage, comme nous le verrons dans <xref linkend="mining"/>.</simpara>
<tip>
<simpara>Qu&#39;est-ce qui vient en premier ? Entrées ou sorties, la poule ou l&#39;œuf ? Strictement parlant, les sorties viennent en premier parce que les transactions coinbase, qui génèrent de nouveaux bitcoins, n&#39;ont pas d&#39;entrées et créent des sorties à partir de rien.</simpara>
</tip>
<section id="tx_outs">
<title>Sorties des transactions</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;sorties et entrées&quot;</secondary><tertiary>&quot;composants de sortie&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;composants de sortie&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;composants de sortie&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;parties de sortie&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;parties de sortie&quot;</primary>
</indexterm>Chaque transaction bitcoin crée des sorties, qui sont enregistrées sur le grand livre bitcoin. Presque toutes ces sorties, à une exception près (voir <xref linkend="op_return"/>) créent des morceaux de bitcoin utilisables appelés UTXO, qui sont ensuite reconnus par l&#39;ensemble du réseau et disponibles pour que le propriétaire les dépense lors d&#39;une future transaction.</simpara>
<simpara>Les UTXO sont suivis par chaque client Bitcoin à nœud complet dans l&#39;ensemble UTXO. Les nouvelles transactions consomment (dépensent) une ou plusieurs de ces sorties de l&#39;ensemble UTXO.</simpara>
<simpara>Les sorties de transaction se composent de deux parties :</simpara>
<itemizedlist>
<listitem>
<simpara>
Un montant de bitcoin, libellé en <emphasis>satoshis</emphasis>, la plus petite unité de bitcoin
</simpara>
</listitem>
<listitem>
<simpara>
Un puzzle cryptographique qui détermine les conditions requises pour passer la sortie
</simpara>
</listitem>
</itemizedlist>
<simpara><indexterm>
  <primary>&quot;scripts de verrouillage&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;script&quot;</primary><secondary>&quot;scripts de verrouillage&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de verrouillage&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;témoins&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptPubKey&quot;</primary>
</indexterm>Le puzzle cryptographique est également connu sous le nom de <emphasis>script de verrouillage</emphasis>, un <emphasis>script de témoin</emphasis> ou un <literal>scriptPubKey</literal>.</simpara>
<simpara>Le langage de script de transaction, utilisé dans le script de verrouillage mentionné précédemment, est décrit en détail dans <xref linkend="tx_script"/>.</simpara>
<simpara>Maintenant, regardons la transaction d&#39;Alice (montrée précédemment dans <xref linkend="transactions_behind_the_scenes"/>) et voir si nous pouvons identifier les sorties. Dans l&#39;encodage JSON, les sorties sont dans un tableau (liste) nommé <literal>vout</literal> :</simpara>
<programlisting language="json" linenumbering="unnumbered">"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY
    OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
  }
]</programlisting>
<simpara>Comme vous pouvez le voir, la transaction contient deux sorties. Chaque sortie est définie par une valeur et un puzzle cryptographique. Dans l&#39;encodage indiqué par Bitcoin Core, la valeur est indiquée en bitcoin, mais dans la transaction elle-même, elle est enregistrée sous la forme d&#39;un entier libellé en satoshis. La deuxième partie de chaque sortie est le puzzle cryptographique qui fixe les conditions de dépenses. Bitcoin Core le montre comme <literal>scriptPubKey</literal> et nous montre une représentation lisible par l&#39;homme du script.</simpara>
<simpara>Le sujet du verrouillage et du déverrouillage de l&#39;UTXO sera abordé plus tard, dans <xref linkend="tx_lock_unlock"/>. Le langage de script utilisé pour le script dans <literal>scriptPubKey</literal> est décrit dans <xref linkend="tx_script"/>. Mais avant d&#39;approfondir ces sujets, nous devons comprendre la structure globale des entrées et sorties des transactions.</simpara>
<section id="_sérialisation_des_transactions_sorties">
<title>Sérialisation des transactions: sorties</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;sorties et entrées&quot;</secondary><tertiary>&quot;structure de&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;structure de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;structure de&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;structure de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;structure de&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sérialisation&quot;</primary><secondary>&quot;sorties&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sorties&quot;</primary>
</indexterm>Lorsque les transactions sont transmises sur le réseau ou échangées entre applications, elles sont <emphasis>sérialisées</emphasis>. La sérialisation est le processus de conversion de la représentation interne d&#39;une structure de données dans un format qui peut être transmis un octet à la fois, également appelé flux d&#39;octets. La sérialisation est le plus souvent utilisée pour coder des structures de données à transmettre sur un réseau ou à stocker dans un fichier. Le format de sérialisation d&#39;une sortie de transaction est affiché dans <xref linkend="tx_out_structure"/>.</simpara>
<table id="tx_out_structure"
frame="all"
rowsep="1" colsep="1"
>
<title>Sérialisation des sorties de transaction</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Taille</entry>
<entry align="left" valign="top"> Champ </entry>
<entry align="left" valign="top"> Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>8 octets (petit-boutiste)</simpara></entry>
<entry align="left" valign="top"><simpara>Montant</simpara></entry>
<entry align="left" valign="top"><simpara>Valeur du bitcoin en satoshis (10<superscript>-8</superscript> bitcoin)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1–9 octets (VarInt)</simpara></entry>
<entry align="left" valign="top"><simpara>Taille du script de verrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>Longueur du script de verrouillage en octets, à suivre</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Variable</simpara></entry>
<entry align="left" valign="top"><simpara>Script de verrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>Un script définissant les conditions nécessaires pour dépenser la sortie</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>La plupart des bibliothèques et frameworks bitcoin ne stockent pas les transactions en interne sous forme de flux d&#39;octets, car cela nécessiterait une analyse complexe chaque fois que vous auriez besoin d&#39;accéder à un seul champ. Pour plus de commodité et de lisibilité, les bibliothèques bitcoin stockent les transactions en interne dans des structures de données (généralement des structures orientées objet).</simpara>
<simpara><indexterm>
  <primary>&quot;désérialisation&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;analyse&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;analyse&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;analyse&quot;</primary>
</indexterm>Le processus de conversion de la représentation de flux d&#39;octets d&#39;une transaction en données de représentation interne d&#39;une bibliothèque est appelée <emphasis>désérialisation</emphasis> ou <emphasis>analyse des transactions</emphasis>. Le processus de reconversion en un flux d&#39;octets pour la transmission sur le réseau, pour le hachage ou pour le stockage sur disque est appelé <emphasis>sérialisation</emphasis>. La plupart des bibliothèques bitcoin ont des fonctions intégrées pour la sérialisation et la désérialisation des transactions.</simpara>
<simpara>Voyez si vous pouvez décoder manuellement la transaction d&#39;Alice à partir de la forme hexadécimale sérialisée, en trouvant certains des éléments que nous avons vus précédemment. La section contenant les deux sorties est mise en surbrillance dans <xref linkend="example_6_1"/> pour vous aider :</simpara>
<example id="example_6_1">
<title>Transaction d&#39;Alice, sérialisée et présentée en notation hexadécimale</title>
<simpara><literal>0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73</literal>
<literal>4d2804fe65fa35779000000008b483045022100884d142d86652a3f47</literal>
<literal>ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039</literal>
<literal>ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</literal>
<literal>01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84</literal>
<literal>16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1</literal>
<literal>7b4a10fa336a8d752adfffffffff02</literal><emphasis role="strong"><literal>60e31600000000001976a914ab6</literal></emphasis>
<emphasis role="strong"><literal>8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000</literal></emphasis>
<emphasis role="strong"><literal>1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac</literal></emphasis>
<literal>00000000</literal></simpara>
</example>
<simpara>Voici quelques conseils :</simpara>
<itemizedlist>
<listitem>
<simpara>
Il y a deux sorties dans la section en surbrillance, chacune sérialisée comme indiqué dans <xref linkend="tx_out_structure"/>.
</simpara>
</listitem>
<listitem>
<simpara>
La valeur de 0,015 bitcoin est de 1 500 000 satoshis. C&#39;est <literal>16 e3 60</literal> en hexadécimal.
</simpara>
</listitem>
<listitem>
<simpara>
Dans la transaction sérialisée, la valeur <literal>16 e3 60</literal> est encodée dans l&#39;ordre d&#8217;octets petit-boutiste (octet le moins significatif en premier), elle ressemble donc à <literal>60 e3 16</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
La longueur de <literal>scriptPubKey</literal> est de 25 octets, soit <literal>19</literal> en hexadécimal.
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="tx_inputs">
<title>Entrées de transactions</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;sorties et entrées&quot;</secondary><tertiary>&quot;composantes d&#39;entrée&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;composantes d&#39;entrée&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;composantes d&#39;entrée&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;composantes d&#39;entrée&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;composantes d&#39;entrée&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties de transactions non dépensées (UTXO)&quot;</primary>
</indexterm> <indexterm>
  <primary>&quot;Ensembles UTXO&quot;</primary>
</indexterm>Les entrées de transaction identifient (par référence) quel UTXO sera consommé et fournissent une preuve de propriété via un script de déverrouillage.</simpara>
<simpara>Pour construire une transaction, un portefeuille sélectionne parmi l&#39;UTXO qu&#39;il contrôle, l&#39;UTXO avec une valeur suffisante pour effectuer le paiement demandé. Parfois un UTXO suffit, d&#39;autres fois plus d&#39;un est nécessaire. Pour chaque UTXO qui sera consommé pour effectuer ce paiement, le portefeuille crée une entrée pointant vers l&#39;UTXO et le déverrouille avec un script de déverrouillage.</simpara>
<simpara>Examinons plus en détail les composants d&#39;une entrée. La première partie d&#39;une entrée est un pointeur vers un UTXO par référence au hachage de transaction et à un index de sortie, qui identifie l&#39;UTXO spécifique dans cette transaction. La deuxième partie est un script de déverrouillage, que le portefeuille construit afin de satisfaire aux conditions de dépenses définies dans l&#39;UTXO. Le plus souvent, le script de déverrouillage est une signature numérique et une clé publique prouvant la propriété du bitcoin. Cependant, ce ne sont pas tous les scripts de déverrouillage qui contiennent une signature. La troisième partie est un numéro de séquence, qui sera discuté plus tard.</simpara>
<simpara>Considérez notre exemple dans <xref linkend="transactions_behind_the_scenes"/>. Les entrées de transaction sont un tableau (liste) appelé <literal>vin</literal> :</simpara>
<formalpara id="vin"><title>Les entrées de transaction dans la transaction d&#39;Alice</title><para>
<programlisting language="json" linenumbering="unnumbered">"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
]</programlisting>
</para></formalpara>
<simpara>Comme vous pouvez le voir, il n&#39;y a qu&#39;une seule entrée dans la liste (car un UTXO contenait une valeur suffisante pour effectuer ce paiement). L&#39;entrée contient quatre éléments :</simpara>
<itemizedlist>
<listitem>
<simpara>
Un <indexterm>
  <primary>&quot;ID de transaction (txd)&quot;</primary>
</indexterm>ID de transaction, faisant référence à la transaction qui contient l&#39;UTXO dépensé
</simpara>
</listitem>
<listitem>
<simpara>
Un index de sortie (<literal>vout</literal>), identifiant quel UTXO de cette transaction est référencé (le premier est zéro)
</simpara>
</listitem>
<listitem>
<simpara>
Un <literal>scriptSig</literal>, qui satisfait aux conditions imposées à l&#39;UTXO, le déverrouillant pour les dépenses
</simpara>
</listitem>
<listitem>
<simpara>
Un numéro de séquence (à discuter plus tard)
</simpara>
</listitem>
</itemizedlist>
<simpara>Dans la transaction d&#39;Alice, l&#39;entrée pointe vers l&#39;ID de transaction :</simpara>
<screen>7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18</screen>
<simpara>et l&#39;indice de sortie <literal>0</literal> (c&#39;est-à-dire le premier UTXO créé par cette transaction). Le script de déverrouillage est construit par le portefeuille d&#39;Alice en récupérant d&#39;abord l&#39;UTXO référencé, en examinant son script de verrouillage, puis en l&#39;utilisant pour créer le script de déverrouillage nécessaire pour le satisfaire.</simpara>
<simpara>En regardant simplement l&#39;entrée, vous avez peut-être remarqué que nous ne savons rien de cet UTXO, à part une référence à la transaction parent qui le contient. Nous ne connaissons pas sa valeur (montant en satoshi), et nous ne connaissons pas le script de verrouillage qui fixe les conditions pour le dépenser. Pour retrouver ces informations, il faut récupérer l&#39;UTXO référencé en récupérant la transaction mère qui le contient. Notez que parce que la valeur de l&#39;entrée n&#39;est pas explicitement indiquée, nous devons également utiliser l&#39;UTXO référencé afin de calculer les frais qui seront payés dans cette transaction (voir <xref linkend="tx_fees"/>).</simpara>
<simpara>Ce n&#39;est pas seulement le portefeuille d&#39;Alice qui doit récupérer l&#39;UTXO référencé dans les entrées. Une fois cette transaction diffusée sur le réseau, chaque nœud de validation devra également récupérer l&#39;UTXO référencé dans les entrées de transaction afin de valider la transaction.</simpara>
<simpara>Les transactions en elles-mêmes semblent incomplètes car elles manquent de contexte. Elles référencent l&#8217;UTXO dans leurs entrées mais sans récupérer cet UTXO on ne peut pas connaître la valeur des entrées ni leurs conditions de verrouillage. Lors de l&#39;écriture d&#39;un logiciel bitcoin, chaque fois que vous décodez une transaction dans le but de la valider ou de compter les frais ou de vérifier le script de déverrouillage, votre code devra d&#39;abord récupérer l&#39;UTXO référencé de la blockchain afin de construire le contexte implicite mais non présent dans les références UTXO des entrées. Par exemple, pour calculer le montant payé en frais, vous devez connaître la somme des valeurs des entrées et des sorties. Mais sans récupérer les UTXO référencés dans les entrées, vous ne connaissez pas leur valeur. Ainsi, une opération apparemment simple comme le comptage des frais dans une seule transaction implique en fait plusieurs étapes et des données provenant de plusieurs transactions.</simpara>
<simpara>Nous pouvons utiliser la même séquence de commandes avec Bitcoin Core que celle que nous avons utilisée lors de la récupération de la transaction d&#39;Alice (<literal>getrawtransaction</literal> et <literal>decoderawtransaction</literal>). Avec cela, nous pouvons obtenir l&#39;UTXO référencé dans l&#39;entrée de la transaction d&#39;Alice et jeter un œil :</simpara>
<formalpara id="alice_input_tx"><title>UTXO de la transaction précédente, référencé dans l&#39;entrée de la transaction d&#39;Alice</title><para>
<programlisting language="json" linenumbering="unnumbered">"vout": [
   {
     "value": 0.10000000,
     "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
   }
 ]</programlisting>
</para></formalpara>
<simpara>On voit que cet UTXO a une valeur de 0.1 BTC et qu&#39;il a un script de verrouillage (<literal>scriptPubKey</literal>) qui contient &quot;OP_DUP OP_HASH160&#8230;&quot;.</simpara>
<tip>
<simpara>Pour bien comprendre la transaction d&#39;Alice, nous avons dû récupérer la transaction précédente référencée en entrée. Une fonction qui récupère les transactions précédentes et les sorties de transaction non dépensées est très courante et existe dans presque toutes les bibliothèques et API Bitcoin.</simpara>
</tip>
<section id="_sérialisation_des_transactions_entrées">
<title>Sérialisation des transactions: entrées</title>
<simpara><indexterm>
  <primary>&quot;sérialisation&quot;</primary><secondary>&quot;entrées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;entrées&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;sorties et entrées&quot;</secondary><tertiary>&quot;sérialisation des entrées&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;sérialisation des entrées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sérialisation des entrées&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties et entrées&quot;</primary><secondary>&quot;sérialisation des entrées&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sérialisation des entrées&quot;</primary>
</indexterm>Lorsque les transactions sont sérialisées pour être transmises sur le réseau, leurs entrées sont codées dans un flux d&#39;octets comme indiqué dans <xref linkend="tx_in_structure"/>.</simpara>
<table id="tx_in_structure"
frame="all"
rowsep="1" colsep="1"
>
<title>Sérialisation des entrées de transaction</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Taille</entry>
<entry align="left" valign="top"> Champ </entry>
<entry align="left" valign="top"> Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>32 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Hachage de transaction</simpara></entry>
<entry align="left" valign="top"><simpara>Pointeur vers la transaction contenant l&#39;UTXO à dépenser</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Indice de sortie</simpara></entry>
<entry align="left" valign="top"><simpara>Le numéro d&#39;index de l&#39;UTXO à dépenser ; le premier est 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1–9 octets (VarInt)</simpara></entry>
<entry align="left" valign="top"><simpara>Taille du script de déverrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>Longueur du script de déverrouillage en octets à suivre</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>variables</simpara></entry>
<entry align="left" valign="top"><simpara>Déverrouillage-Script</simpara></entry>
<entry align="left" valign="top"><simpara>Un script remplissant les conditions du script de verrouillage UTXO</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 octets</simpara></entry>
<entry align="left" valign="top"><simpara>Numéro de séquence</simpara></entry>
<entry align="left" valign="top"><simpara>Utilisé pour le temps de verrouillage ou désactivé (0xFFFFFFFF)</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Comme pour les sorties, voyons si nous pouvons trouver les entrées de la transaction d&#39;Alice au format sérialisé. Tout d&#39;abord, les entrées décodées :</simpara>
<programlisting language="json" linenumbering="unnumbered">"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
],</programlisting>
<simpara>Voyons maintenant si nous pouvons identifier ces champs dans le codage hexadécimal sérialisé dans <xref linkend="example_6_2"/> :</simpara>
<example id="example_6_2">
<title>Transaction d&#39;Alice, sérialisée et présentée en notation hexadécimale</title>
<simpara><literal>0100000001</literal><emphasis role="strong"><literal>186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73</literal></emphasis>
<emphasis role="strong"><literal>4d2804fe65fa35779000000008b483045022100884d142d86652a3f47</literal></emphasis>
<emphasis role="strong"><literal>ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039</literal></emphasis>
<emphasis role="strong"><literal>ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</literal></emphasis>
<emphasis role="strong"><literal>01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84</literal></emphasis>
<emphasis role="strong"><literal>16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1</literal></emphasis>
<emphasis role="strong"><literal>7b4a10fa336a8d752adfffffffff</literal></emphasis><literal>0260e31600000000001976a914ab6</literal>
<literal>8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000</literal>
<literal>1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000</literal>
<literal>000</literal></simpara>
</example>
<simpara>Astuces:</simpara>
<itemizedlist>
<listitem>
<simpara>
L&#39;ID de transaction est sérialisé dans l&#39;ordre inverse des octets, il commence donc par (hex) <literal>18</literal> et se termine par <literal>79</literal>
</simpara>
</listitem>
<listitem>
<simpara>
L&#39;index de sortie est un groupe de zéros de 4 octets, facile à identifier
</simpara>
</listitem>
<listitem>
<simpara>
La longueur du <literal>scriptSig</literal> est de 139 octets, soit <literal>8b</literal> en hexadécimal
</simpara>
</listitem>
<listitem>
<simpara>
Le numéro de séquence est défini sur <literal>FFFFFFFF</literal>, encore une fois facile à identifier<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;alicesix&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;alicesix&quot;</primary>
</indexterm>
</simpara>
</listitem>
</itemizedlist>
<simpara>ScriptSig est un type spécifique de script de déverrouillage qui, lorsqu&#39;il est sérialisé pour être transmis sur le réseau, les entrées sont codées dans un flux d&#39;octets, comme indiqué dans <xref linkend="scriptsig_in_structure"/>. La sérialisation du champ signature est détaillée dans <xref linkend="seralization_of_signatures_der"/>. Le champ de signature comprend également un type de hachage de signature (SIGHASH), qui est détaillé dans <xref linkend="sighash_types"/>.</simpara>
<table id="scriptsig_in_structure"
frame="all"
rowsep="1" colsep="1"
>
<title>Sérialisation des entrées ScriptSig</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Taille</entry>
<entry align="left" valign="top"> Champ </entry>
<entry align="left" valign="top"> Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1–9 octets (VarInt)</simpara></entry>
<entry align="left" valign="top"><simpara>Taille signature</simpara></entry>
<entry align="left" valign="top"><simpara>Longueur de la signature en octets à suivre</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>variables</simpara></entry>
<entry align="left" valign="top"><simpara>signature</simpara></entry>
<entry align="left" valign="top"><simpara>Une signature produite par le portefeuille de l&#39;utilisateur à partir de sa clé privée, qui comprend un SIGHASH</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1–9 octets (VarInt)</simpara></entry>
<entry align="left" valign="top"><simpara>Taille de la clé publique</simpara></entry>
<entry align="left" valign="top"><simpara>Longueur de la clé publique en octets à suivre</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>variables</simpara></entry>
<entry align="left" valign="top"><simpara>Clé publique</simpara></entry>
<entry align="left" valign="top"><simpara>La clé publique, non hachée</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section id="tx_fees">
<title>Frais de transaction</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;extrants et intrants&quot;</secondary><tertiary>&quot;frais de transaction&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;extrants et intrants&quot;</primary><secondary>&quot;frais de transaction&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;frais de transaction&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;frais de transaction&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;frais de transaction&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;minage et consensus&quot;</primary><secondary>&quot;récompenses et frais&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;récompenses et frais&quot;</primary>
</indexterm>La plupart des transactions incluent des frais de transaction, qui rémunèrent les mineurs de bitcoins pour la sécurisation du réseau. Les frais servent également de mécanisme de sécurité eux-mêmes, en rendant économiquement impossible pour les attaquants d&#39;inonder le réseau de transactions. L&#39;exploitation minière et les frais et récompenses perçus par les mineurs sont discutés plus en détail dans <xref linkend="mining"/>.</simpara>
<simpara>Cette section examine comment les frais de transaction sont inclus dans une transaction typique. La plupart des portefeuilles calculent et incluent automatiquement les frais de transaction. Toutefois, si vous créez des transactions par programmation ou à l&#39;aide d&#39;une interface de ligne de commande, vous devez comptabiliser et inclure manuellement ces frais.</simpara>
<simpara>Les frais de transaction servent d&#39;incitation à inclure (exploiter) une transaction dans le bloc suivant et également de dissuasion contre les abus du système en imposant un petit coût sur chaque transaction. Les frais de transaction sont perçus par le mineur qui exploite le bloc qui enregistre la transaction sur la chaîne de blocs.</simpara>
<simpara>Les frais de transaction sont calculés en fonction de la taille de la transaction en kilo-octets, et non de la valeur de la transaction en bitcoin. Dans l&#39;ensemble, les frais de transaction sont fixés en fonction des forces du marché au sein du réseau Bitcoin. Les mineurs hiérarchisent les transactions en fonction de nombreux critères différents, y compris les frais, et peuvent même traiter les transactions gratuitement dans certaines circonstances. Les frais de transaction affectent la priorité de traitement, ce qui signifie qu&#39;une transaction avec des frais suffisants est susceptible d&#39;être incluse dans le prochain bloc miné, alors qu&#39;une transaction avec des frais insuffisants ou nuls peut être retardée, traitée au mieux après quelques blocs, ou pas traité du tout. Les frais de transaction ne sont pas obligatoires et les transactions sans frais peuvent éventuellement être traitées ; cependant, l&#39;inclusion des frais de transaction encourage le traitement prioritaire.</simpara>
<simpara>Au fil du temps, la façon dont les frais de transaction sont calculés et leur effet sur la hiérarchisation des transactions ont évolué. Au départ, les frais de transaction étaient fixes et constants sur l&#39;ensemble du réseau. Progressivement, la structure tarifaire s&#39;est assouplie et peut être influencée par les forces du marché, en fonction de la capacité du réseau et du volume des transactions. Depuis au moins le début de 2016, les limites de capacité en bitcoin ont créé une concurrence entre les transactions, entraînant des frais plus élevés et faisant des transactions gratuites une chose du passé. Les transactions sans frais ou à très faibles frais sont rarement minées et parfois ne seront même pas propagées sur le réseau.</simpara>
<simpara><indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;politiques de relais des frais&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;politiques de relais des frais&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;option minrelaytxfee&quot;</primary>
</indexterm>Dans Bitcoin Core, les politiques de relais des frais sont définies par l&#39;option <literal>minrelaytxfee</literal>. Le <literal>minrelaytxfee</literal> par défaut actuel est de 0,00001 bitcoin ou un centième de millibitcoin par kilooctet. Par conséquent, par défaut, les transactions dont les frais sont inférieurs à 0,00001 bitcoin sont traitées comme gratuites et ne sont relayées que s&#39;il y a de la place dans le mempool ; sinon, ils sont supprimés. Les nœuds Bitcoin peuvent remplacer la politique de relais de frais par défaut en ajustant la valeur de <literal>minrelaytxfee</literal>.</simpara>
<simpara><indexterm>
  <primary>&quot;frais dynamiques&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;frais dynamiques&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;frais dynamiques&quot;</primary>
</indexterm>Tout service bitcoin qui crée des transactions, y compris les portefeuilles, les échanges, les applications de vente au détail, etc., <emphasis>doit</emphasis> implémenter des frais dynamiques. Les frais dynamiques peuvent être mis en œuvre via un service tiers d&#39;estimation des frais ou avec un algorithme d&#39;estimation des frais intégré. Si vous n&#39;êtes pas sûr, commencez par un service tiers et, à mesure que vous acquérez de l&#39;expérience, concevez et implémentez votre propre algorithme si vous souhaitez supprimer la dépendance tierce.</simpara>
<simpara>Les algorithmes d&#39;estimation des frais calculent les frais appropriés, en fonction de la capacité et des frais offerts par les transactions « concurrentes ». Ces algorithmes vont du simple (frais moyens ou médians dans le dernier bloc) au sophistiqué (analyse statistique). Ils estiment les frais nécessaires (en satoshis par octet) qui donneront à une transaction une forte probabilité d&#39;être sélectionnée et incluse dans un certain nombre de blocs. La plupart des services offrent aux utilisateurs la possibilité de choisir des frais de priorité élevés, moyens ou faibles. Une priorité élevée signifie que les utilisateurs paient des frais plus élevés, mais la transaction est susceptible d&#39;être incluse dans le bloc suivant. Une priorité moyenne et faible signifie que les utilisateurs paient des frais de transaction moins élevés, mais que la confirmation des transactions peut prendre beaucoup plus de temps.</simpara>
<simpara><indexterm>
  <primary>&quot;bitcoinfees (service tiers)&quot;</primary>
</indexterm> De nombreuses applications de portefeuille utilisent des services tiers pour le calcul des frais. Un service populaire est <ulink url="https://bitcoinfees.earn.com/"><emphasis>https://bitcoinfees.earn.com/</emphasis></ulink>, qui fournit une API et un graphique visuel montrant les frais en satoshi/octet pour différentes priorités.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;frais statiques&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;frais statiques&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;frais statiques&quot;</primary>
</indexterm>Les frais statiques ne sont plus viables sur le réseau Bitcoin. Les portefeuilles qui fixent des frais statiques produiront une mauvaise expérience utilisateur car les transactions seront souvent &quot;bloquées&quot; et resteront non confirmées. Les utilisateurs qui ne comprennent pas les transactions et les frais en bitcoins sont consternés par les transactions &quot;bloquées&quot; car ils pensent avoir perdu leur argent.</simpara>
</tip>
<simpara>Le graphique en <xref linkend="bitcoinfeesearncom"/> affiche l&#39;estimation en temps réel des frais par incréments de 10 satoshi/octet et le temps de confirmation attendu (en minutes et en nombre de blocs) pour les transactions avec des frais dans chaque plage. Pour chaque fourchette de frais (par exemple, 61 à 70 satoshi/octet), deux barres horizontales indiquent le nombre de transactions non confirmées (1 405) et le nombre total de transactions au cours des dernières 24 heures (102 975), avec des frais compris dans cette fourchette. Sur la base du graphique, les frais de haute priorité recommandés à ce moment étaient de 80 satoshi/octet, des frais susceptibles d&#39;entraîner l&#39;inclusion de la transaction dans le bloc suivant (délai de bloc nul). Pour la perspective, la taille médiane des transactions est de 226 octets, donc les frais recommandés pour cette taille de transaction seraient de 18 080 satoshis (0,00018080 BTC).</simpara>
<simpara>Les données d&#39;estimation des frais peuvent être récupérées via une simple API HTTP REST, à l&#39;adresse <ulink url="https://bitcoinfees.earn.com/api/v1/fees/recommended">https://bitcoinfees.earn.com/api/v1/fees/recommended </ulink>. Par exemple, sur la ligne de commande en utilisant la commande <literal>curl</literal> :</simpara>
<formalpara><title>Utilisation de l&#39;API d&#39;estimation des frais</title><para>
<screen>$ curl https://bitcoinfees.earn.com/api/v1/fees/recommended

{"fastestFee":80,"halfHourFee":80,"hourFee":60}</screen>
</para></formalpara>
<simpara>L&#39;API renvoie un objet JSON avec l&#39;estimation actuelle des frais pour la confirmation la plus rapide (<literal>fastestFee</literal>), la confirmation dans les trois blocs (<literal>halfHourFee</literal>) et six blocs (<literal>hourFee</literal>), en satoshi par octet.</simpara>
<figure id="bitcoinfeesearncom"><title>Service d&#39;estimation des frais bitcoinfees.earn.com</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0602.png"/>
  </imageobject>
  <textobject><phrase>Service d&#39;estimation des frais bitcoinfees.earn.com</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_ajout_de_frais_aux_transactions">
<title>Ajout de frais aux transactions</title>
<simpara>La structure de données des transactions n&#39;a pas de champ pour les frais. Au lieu de cela, les frais sont implicites comme la différence entre la somme des entrées et la somme des sorties. Tout montant excédentaire qui reste après que toutes les sorties ont été déduites de toutes les entrées est la redevance perçue par les mineurs :</simpara>
<formalpara id="tx_fee_equation"><title>Les frais de transaction sont implicites, comme l&#39;excédent des intrants moins les extrants :</title><para>
<screen>Frais = Somme(intrants) - Somme(extrants)</screen>
</para></formalpara>
<simpara>Il s&#39;agit d&#39;un élément quelque peu déroutant des transactions et d&#39;un point important à comprendre, car si vous construisez vos propres transactions, vous devez vous assurer de ne pas inclure par inadvertance des frais très importants en sous-dépensant les intrants. Cela signifie que vous devez comptabiliser toutes les entrées, si nécessaire en créant du change, ou vous finirez par donner un très gros pourboire aux mineurs !</simpara>
<simpara>Par exemple, si vous consommez un UTXO de 20 bitcoins pour effectuer un paiement de 1 bitcoin, vous devez inclure une sortie de modification de 19 bitcoins dans votre portefeuille. Sinon, le &quot;reste&quot; de 19 bitcoins sera compté comme des frais de transaction et sera collecté par le mineur qui exploite votre transaction dans un bloc. Bien que vous receviez un traitement prioritaire et rendiez un mineur très heureux, ce n&#39;est probablement pas ce que vous vouliez.</simpara>
<warning>
<simpara><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;modifier les sorties&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;modifier les sorties&quot;</primary>
</indexterm> Si vous oubliez d&#39;ajouter une sortie de modification dans une transaction construite manuellement, vous paierez la modification en tant que frais de transaction. Dire &quot;Gardez la monnaie !&quot; au mineur n&#39;est peut-être pas ce que vous vouliez vraiment.</simpara>
</warning>
<simpara><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;achat de café&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;achat de café&quot;</primary>
</indexterm> Voyons comment cela fonctionne en pratique, en examinant à nouveau l&#39;achat de café d&#39;Alice. Alice veut dépenser 0,015 bitcoin pour payer son café. Pour s&#39;assurer que cette transaction est traitée rapidement, elle voudra inclure des frais de transaction, disons 0,0005. Cela signifie que le coût total de la transaction sera de 0,0155. Son portefeuille doit donc se procurer un ensemble d&#39;UTXO qui totalise 0,0155 bitcoin ou plus et, si nécessaire, créer de la monnaie. Disons que son portefeuille dispose d&#39;un UTXO de 0,1 bitcoin. Elle devra donc consommer cet UTXO, créer une sortie pour le comptoir à café de Bob pour 0,015, et une seconde sortie avec 0,0845 bitcoin en retour vers son propre portefeuille, laissant 0,0005 bitcoin non alloué, comme frais implicites pour la transaction.</simpara>
<simpara><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;dons caritatifs&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;dons caritatifs&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;dons caritatifs&quot;</primary>
</indexterm>Regardons maintenant un scénario différent. Eugenia, directrice de notre association caritative pour enfants aux Philippines, a organisé une collecte de fonds pour acheter des manuels scolaires pour les enfants. Elle a reçu plusieurs milliers de petits dons de personnes du monde entier, totalisant 50 bitcoins, donc son portefeuille est plein de très petits paiements (UTXO). Maintenant, elle veut acheter des centaines de manuels scolaires auprès d&#39;un éditeur local, en payant en bitcoins.</simpara>
<simpara>Alors que l&#39;application de portefeuille d&#39;Eugenia tente de construire une seule transaction de paiement plus importante, elle doit s&#39;approvisionner à partir de l&#39;ensemble UTXO disponible, qui est composé de nombreux montants plus petits. Cela signifie que la transaction résultante proviendra de plus d&#39;une centaine d&#39;UTXO de petite valeur en tant qu&#39;entrées et d&#39;une seule sortie, payant l&#39;éditeur du livre. Une transaction avec autant d&#39;entrées sera supérieure à un kilo-octet, peut-être plusieurs kilo-octets. En conséquence, cela nécessitera des frais beaucoup plus élevés que la transaction de taille médiane.</simpara>
<simpara>L&#39;application de portefeuille d&#39;Eugenia calculera les frais appropriés en mesurant la taille de la transaction et en la multipliant par les frais par kilo-octet. De nombreux portefeuilles surpayeront les frais pour les transactions plus importantes afin de s&#39;assurer que la transaction est traitée rapidement. Les frais plus élevés ne sont pas dus au fait qu&#39;Eugenia dépense plus d&#39;argent, mais au fait que sa transaction est plus complexe et plus volumineuse - les frais sont indépendants de la valeur en bitcoins de la transaction.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Tout06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Tout06&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="tx_script" role="pagebreak-before less_space_h1">
<title>Scripts de transaction et langage de script</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;scripts et langage de script&quot;</secondary><tertiary>id=&quot;Tsript06&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;scripts et langage de script&quot;</primary><secondary>id=&quot;Tsript06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Tsript06&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;transactions et&quot;</secondary><tertiary>id=&quot;Stransact06&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;transactions et&quot;</primary><secondary>id=&quot;Stransact06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Stransact06&quot;</primary>
</indexterm>Le langage de script de transaction bitcoin, appelé <emphasis>Script</emphasis> , est un langage d&#39;exécution basé sur une pile de notation polonaise inversée (RPN) de type Forth. Si cela ressemble à du charabia, vous n&#39;avez probablement pas étudié les langages de programmation des années 1960, mais ce n&#39;est pas grave, nous vous expliquerons tout dans ce chapitre. Le script de verrouillage placé sur un UTXO et le script de déverrouillage sont écrits dans ce langage de script. Lorsqu&#39;une transaction est validée, le script de déverrouillage de chaque entrée est exécuté parallèlement au script de verrouillage correspondant pour voir s&#39;il satisfait à la condition de dépense.</simpara>
<simpara>Script est un langage très simple qui a été conçu pour être limité dans sa portée et être exécutable sur une gamme de matériel et peut être aussi simple qu&#39;un périphérique intégré. Il nécessite un traitement minimal et ne peut pas faire la plupart des choses fantaisistes que les langages de programmation modernes peuvent faire. Pour son utilisation dans la validation de monnaie programmable, il s&#39;agit d&#39;une fonction de sécurité délibérée.</simpara>
<simpara><indexterm>
  <primary>&quot;Pay-to-Public-Key-Hash (P2PKH)&quot;</primary>
</indexterm>Aujourd&#39;hui, la plupart des transactions traitées via le réseau Bitcoin ont la forme &quot;Paiement à l&#39;adresse Bitcoin de Bob&quot; et sont basées sur un script appelé Pay-to-Script Public-Key-Hash. Cependant, les transactions bitcoin ne se limitent pas au script &quot;Paiement à l&#39;adresse Bitcoin de Bob&quot;. En fait, les scripts de verrouillage peuvent être écrits pour exprimer une grande variété de conditions complexes. Afin de comprendre ces scripts plus complexes, nous devons d&#39;abord comprendre les bases des scripts de transaction et du langage de script.</simpara>
<simpara>Dans cette section, nous démontrerons les composants de base du langage de script de transaction bitcoin et montrerons comment il peut être utilisé pour exprimer des conditions simples de dépenses et comment ces conditions peuvent être satisfaites en déverrouillant des scripts.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;argent programmable&quot;</primary>
</indexterm>La validation des transactions Bitcoin n&#39;est pas basée sur un modèle statique, mais est plutôt obtenue grâce à l&#39;exécution d&#39;un langage de script. Ce langage permet d&#39;exprimer une variété presque infinie de conditions. C&#39;est ainsi que le bitcoin obtient le pouvoir de &quot;l&#39;argent programmable&quot;.</simpara>
</tip>
<section id="_incomplétude_de_turing">
<title>Incomplétude de Turing</title>
<simpara><indexterm>
  <primary>&quot;Turing incomplétude&quot;</primary>
</indexterm>Le langage de script de transaction bitcoin contient de nombreux opérateurs, mais est délibérément limité d&#39;une manière importante : il n&#39;y a pas de boucles ou de capacités de contrôle de flux complexes autres que le contrôle de flux conditionnel. Cela garantit que le langage n&#39;est pas <emphasis>Turing complet</emphasis>, ce qui signifie que les scripts ont une complexité limitée et des temps d&#39;exécution prévisibles. Le script n&#39;est pas un langage universel. <indexterm>
  <primary>&quot;attaques par déni de service&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;attaques par déni de service&quot;</primary><secondary>see=&quot;aussi sécurité&quot;</secondary>
</indexterm>
<indexterm>
  <primary>see=&quot;aussi sécurité&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sécurité&quot;</primary><secondary>&quot;attaques par déni de service&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;attaques par déni de service&quot;</primary>
</indexterm>Ces limitations garantissent que le langage ne peut pas être utilisé pour créer une boucle infinie ou une autre forme de &quot;bombe logique&quot; qui pourrait être intégrée dans une transaction de manière à provoquer une attaque par déni de service contre le réseau Bitcoin. N&#39;oubliez pas que chaque transaction est validée par chaque nœud complet du réseau Bitcoin. Un langage limité empêche le mécanisme de validation des transactions d&#39;être utilisé comme une vulnérabilité.</simpara>
</section>
<section id="_vérification_sans_état">
<title>Vérification sans état</title>
<simpara><indexterm>
  <primary>&quot;vérification sans état&quot;</primary>
</indexterm>Le langage de script de transaction bitcoin est sans état, en ce sens qu&#39;il n&#39;y a pas d&#39;état avant l&#39;exécution du script, ou d&#39;état enregistré après l&#39;exécution du script. Par conséquent, toutes les informations nécessaires à l&#39;exécution d&#39;un script sont contenues dans le script. Un script s&#39;exécutera de manière prévisible de la même manière sur n&#39;importe quel système. Si votre système vérifie un script, vous pouvez être sûr que tous les autres systèmes du réseau Bitcoin vérifieront également le script, ce qui signifie qu&#39;une transaction valide est valide pour tout le monde et tout le monde le sait. Cette prévisibilité des résultats est un avantage essentiel du système Bitcoin.</simpara>
</section>
<section id="tx_lock_unlock">
<title>Construction du script (Verrouiller + Déverrouiller)</title>
<simpara>Le moteur de validation des transactions de Bitcoin s&#39;appuie sur deux types de scripts pour valider les transactions : un script de verrouillage et un script de déverrouillage.</simpara>
<simpara><indexterm>
  <primary>&quot;scripts de verouillage&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripts de déverouillage&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;scripts de déverouillage&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de déverouillage&quot;</primary>
</indexterm>Un script de verrouillage est une condition de dépense placée sur une sortie : il spécifie les conditions qui doivent être remplies pour dépenser la production à l&#39;avenir. <indexterm>
  <primary>&quot;scriptPubKey&quot;</primary>
</indexterm>Historiquement, le script de verrouillage était appelé <emphasis>scriptPubKey</emphasis>, car il contenait généralement une clé publique ou une adresse Bitcoin (hachage de clé publique). Dans ce livre, nous l&#39;appelons un &quot;script de verrouillage&quot; pour reconnaître l&#39;éventail de possibilités beaucoup plus large de cette technologie de script. Dans la plupart des applications bitcoin, ce que nous appelons un script de verrouillage apparaîtra dans le code source sous la forme <literal>scriptPubKey</literal>. <indexterm>
  <primary>&quot;témoins&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;énigmes cryptographiques&quot;</primary>
</indexterm>Vous verrez également le script de verrouillage appelé <emphasis>script de témoin</emphasis> (voir <xref linkend="segwit"/>) ou plus généralement comme un <emphasis>casse-tête cryptographique</emphasis>. Ces termes signifient tous la même chose, à différents niveaux d&#39;abstraction.</simpara>
<simpara>Un script de déverrouillage est un script qui « résout », ou satisfait, les conditions placées sur une sortie par un script de verrouillage et permet à la sortie d&#39;être dépensée. Les scripts de déverrouillage font partie de chaque entrée de transaction. Ils contiennent la plupart du temps une signature numérique produite par le portefeuille de l&#39;utilisateur à partir de sa clé privée. <indexterm>
  <primary>&quot;scriptSig&quot;</primary>
</indexterm>Historiquement, le script de déverrouillage s&#39;appelait <emphasis>scriptSig</emphasis>, car il contenait généralement une signature numérique. Dans la plupart des applications bitcoin, le code source fait référence au script de déverrouillage sous la forme <literal>scriptSig</literal>. Vous verrez également le script de déverrouillage appelé <emphasis>témoin</emphasis> (voir <xref linkend="segwit"/>). Dans ce livre, nous l&#39;appelons un &quot;script de déverrouillage&quot; pour reconnaître la gamme beaucoup plus large d&#39;exigences de script de verrouillage, car ce n&#8217;est pas tous les scripts de déverrouillage qui doivent contenir des signatures.</simpara>
<simpara>Chaque nœud de validation Bitcoin validera les transactions en exécutant les scripts de verrouillage et de déverrouillage ensemble. Chaque entrée contient un script de déverrouillage et fait référence à un UTXO existant précédemment. Le logiciel de validation copiera le script de déverrouillage, récupérera l&#39;UTXO référencé par l&#39;entrée et copiera le script de verrouillage à partir de cet UTXO. Les scripts de déverrouillage et de verrouillage sont ensuite exécutés en séquence. L&#39;entrée est valide si le script de déverrouillage satisfait les conditions du script de verrouillage (voir <xref linkend="script_exec"/>). Toutes les entrées sont validées indépendamment, dans le cadre de la validation globale de la transaction.</simpara>
<simpara>Notez que l&#39;UTXO est enregistré en permanence dans la blockchain, et est donc invariable et n&#39;est pas affecté par les tentatives infructueuses de le dépenser par référence dans une nouvelle transaction. Seule une transaction valide qui satisfait correctement les conditions de la sortie entraîne que la sortie est considérée comme &quot;dépensée&quot; et retirée de l&#39;ensemble des sorties de transaction non dépensées (ensemble UTXO).</simpara>
<simpara><xref linkend="scriptSig_and_scriptPubKey"/> est un exemple des scripts de déverrouillage et de verrouillage pour le type de transaction bitcoin le plus courant (un paiement à un hachage de clé publique), montrant le script combiné résultant de la concaténation des scripts de déverrouillage et de verrouillage avant la validation du script.</simpara>
<figure id="scriptSig_and_scriptPubKey"><title>Combiner scriptSig et scriptPubKey pour évaluer un script de transaction</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0603.png"/>
  </imageobject>
  <textobject><phrase>&quot;scriptSig_and_scriptPubKey&quot;</phrase></textobject>
</mediaobject>
</figure>
<section id="_la_pile_d_39_exécution_de_script">
<title>La pile d&#39;exécution de script</title>
<simpara>Le langage de script de Bitcoin est appelé un langage basé sur la pile car il utilise une structure de données appelée <emphasis>pile</emphasis>. Une pile est une structure de données très simple qui peut être visualisée comme une pile de cartes. Une pile permet deux opérations : push et pop. Push ajoute un élément au sommet de la pile. Pop supprime l&#39;élément du haut de la pile. Les opérations sur une pile ne peuvent agir que sur l&#39;élément le plus haut de la pile. Une structure de données de pile est également appelée file d&#39;attente Last-In-First-Out (dernier entré, premier sorti), ou &quot;LIFO&quot;.</simpara>
<simpara>Le langage de script exécute le script en traitant chaque élément de gauche à droite. Les nombres (constantes de données) sont poussés sur la pile. Les opérateurs poussent ou sortent un ou plusieurs paramètres de la pile, agissent sur eux et peuvent pousser un résultat sur la pile. Par exemple, <literal>OP_ADD</literal> fera sortir deux éléments de la pile, les ajoutera et poussera la somme résultante sur la pile.</simpara>
<simpara>Les opérateurs conditionnels évaluent une condition, produisant un résultat booléen VRAI (TRUE) ou FAUX (FALSE). Par exemple, <literal>OP_EQUAL</literal> dépile deux éléments de la pile et pousse TRUE (TRUE est représenté par le nombre 1) s&#39;ils sont égaux ou FALSE (représenté par zéro) s&#39;ils ne sont pas égaux. Les scripts de transaction Bitcoin contiennent généralement un opérateur conditionnel, afin qu&#39;ils puissent produire le résultat VRAI qui signifie une transaction valide.</simpara>
</section>
<section id="_un_script_simple">
<title>Un script simple</title>
<simpara>Appliquons maintenant ce que nous avons appris sur les scripts et les piles à quelques exemples simples.</simpara>
<simpara>Dans <xref linkend="simplemath_script"/>, le script <literal>2 3 OP_ADD 5 OP_EQUAL</literal> démontre l&#39;opérateur d&#39;addition arithmétique <literal>OP_ADD</literal>, additionnant deux nombres et mettant le résultat sur la pile, suivi de l&#39;opérateur conditionnel <literal>OP_EQUAL</literal>, qui vérifie que la somme résultante est égale à <literal>5</literal>. Par souci de brièveté, le préfixe <literal>OP_</literal> est omis dans l&#39;exemple étape par étape. Pour plus de détails sur les opérateurs de script et les fonctions disponibles, voir <xref linkend="tx_script_ops"/>.</simpara>
<simpara>Bien que la plupart des scripts de verrouillage se réfèrent à un hachage de clé publique (essentiellement, une adresse Bitcoin), nécessitant ainsi une preuve de propriété pour dépenser les fonds, le script n&#39;a pas besoin d&#39;être aussi complexe. Toute combinaison de scripts de verrouillage et de déverrouillage donnant une valeur TRUE est valide. L&#39;arithmétique simple que nous avons utilisée comme exemple de langage de script est également un script de verrouillage valide qui peut être utilisé pour verrouiller une sortie de transaction.</simpara>
<simpara>Utilisez une partie de l&#39;exemple de script arithmétique comme script de verrouillage :</simpara>
<screen>3 OP_ADD 5 OP_EQUAL</screen>
<simpara>qui peut être satisfaite par une transaction contenant une entrée avec le script de déverrouillage :</simpara>
<screen>2</screen>
<simpara>Le logiciel de validation combine les scripts de verrouillage et de déverrouillage et le script résultant est :</simpara>
<screen>2 3 OP_ADD 5 OP_EQUAL</screen>
<simpara>Comme nous l&#39;avons vu dans l&#39;exemple étape par étape dans <xref linkend="simplemath_script"/>, lorsque ce script est exécuté, le résultat est <literal>OP_TRUE</literal>, rendant la transaction valide. Non seulement il s&#39;agit d&#39;un script de verrouillage de sortie de transaction valide, mais l&#39;UTXO résultant pourrait être dépensé par toute personne ayant les compétences en arithmétique pour savoir que le nombre 2 satisfait le script.</simpara>
<tip>
<simpara></simpara>
</tip>
<figure id="simplemath_script"><title>La validation du script Bitcoin en calculs simples</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0604.png"/>
  </imageobject>
  <textobject><phrase>&quot;TxScriptSimpleMathExample&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">Ce qui suit est un script légèrement plus complexe, qui calcule <literal>2 + 7 - 3 + 1</literal>. Notez que lorsque le script contient plusieurs opérateurs à la suite, la pile permet aux résultats d&#39;un opérateur d&#39;être appliqués par l&#39;opérateur suivant :</simpara>
<screen>2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL</screen>
<simpara>Essayez de valider vous-même le script précédent à l&#39;aide d&#39;un crayon et de papier. Lorsque l&#39;exécution du script se termine, vous devriez vous retrouver avec la valeur <literal>TRUE</literal> sur la pile.</simpara>
</section>
<section id="script_exec">
<title>Exécution séparée des scripts de déverrouillage et de verrouillage</title>
<simpara><indexterm>
  <primary>&quot;sécurité&quot;</primary><secondary>&quot;scripts de verrouillage et de déverrouillage&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de verrouillage et de déverrouillage&quot;</primary>
</indexterm>Dans le client Bitcoin d&#39;origine, les scripts de déverrouillage et de verrouillage étaient concaténés et exécutés en séquence. Pour des raisons de sécurité, cela a été modifié en 2010, en raison d&#39;une vulnérabilité qui permettait à un script de déverrouillage malformé de pousser des données sur la pile et de corrompre le script de verrouillage. Dans l&#39;implémentation actuelle, les scripts sont exécutés séparément avec la pile transférée entre les deux exécutions, comme décrit ci-après.</simpara>
<simpara>Tout d&#39;abord, le script de déverrouillage est exécuté à l&#39;aide du moteur d&#39;exécution de la pile. Si le script de déverrouillage est exécuté sans erreur (par exemple, s&#39;il ne reste plus de pointeurs &quot; pendants&quot;), la pile principale est copiée et le script de verrouillage est exécuté. Si le résultat de l&#39;exécution du script de verrouillage avec les données de la pile copiées à partir du script de déverrouillage est &quot;TRUE&quot;, le script de déverrouillage a réussi à résoudre les conditions imposées par le script de verrouillage et, par conséquent, l&#39;entrée est une autorisation valide de dépenser l&#39;UTXO. S&#39;il reste un résultat autre que &quot;TRUE&quot; après l&#39;exécution du script combiné, l&#39;entrée est invalide car elle n&#39;a pas satisfait aux conditions de dépenses placées sur l&#39;UTXO.</simpara>
</section>
</section>
<section id="p2pkh">
<title>Pay-to-Public-Key-Hash (P2PKH)</title>
<simpara><indexterm>
  <primary>&quot;Pay-to-Public-Key-Hash (P2PKH)&quot;</primary>
</indexterm>La grande majorité des transactions traitées sur le réseau Bitcoin dépensent des sorties verrouillées avec un script Pay-to-Public-Key-Hash ou &quot;P2PKH&quot;. Ces sorties contiennent un script de verrouillage qui verrouille la sortie sur un hachage de clé publique, plus communément appelé adresse Bitcoin. Une sortie verrouillée par un script P2PKH peut être déverrouillée (passée) en présentant une clé publique et une signature numérique créée par la clé privée correspondante (voir <xref linkend="digital_sigs"/>).</simpara>
<simpara><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;acheter du café&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;acheter du café&quot;</primary>
</indexterm>Par exemple, regardons à nouveau le paiement d&#39;Alice au comptoir à café de Bob. Alice a effectué un paiement de 0,015 bitcoin à l&#39;adresse Bitcoin du comptoir. Cette sortie de transaction aurait un script de verrouillage de la forme :</simpara>
<screen>OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</screen>
<simpara>Le <literal>Cafe Public Key Hash</literal> équivaut à l&#39;adresse Bitcoin du café, sans l&#39;encodage Base58Check. La plupart des applications afficheraient le <emphasis>hachage de la clé publique</emphasis> en codage hexadécimal et non le format familier de l&#39;adresse Bitcoin Base58Check qui commence par un &quot;1&quot;.</simpara>
<simpara>Le script de verrouillage précédent peut se contenter d&#39;un script de déverrouillage de la forme :</simpara>
<screen>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;</screen>
<simpara>Les deux scripts ensemble formeraient le script de validation combiné suivant :</simpara>
<screen>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt; OP_DUP OP_HASH160
&lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</screen>
<simpara>Lorsqu&#39;il est exécuté, ce script combiné sera évalué à TRUE si, et seulement si, le script de déverrouillage correspond aux conditions définies par le script de verrouillage. En d&#39;autres termes, le résultat sera VRAI si le script de déverrouillage a une signature valide de la clé privée du comptoir qui correspond au hachage de la clé publique défini comme encombrement.</simpara>
<simpara>Les figures <a data-type="xref" href="#P2PubKHash1" data-xrefstyle="select: labelnumber">#P2PubKHash1</a> et <a data-type="xref" href="#P2PubKHash2" data-xrefstyle="select: labelnumber">#P2PubKHash2</a> montrent (en deux parties) une exécution pas à pas du script combiné, qui prouvera qu&#39;il s&#39;agit d&#39;une transaction valide.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot; Tsript06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot; Tsript06&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Stransact06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Stransact06&quot;</primary>
</indexterm></simpara>
<figure id="P2PubKHash1"><title>Évaluer un script pour une transaction P2PKH (partie 1 sur 2)</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0605.png"/>
  </imageobject>
  <textobject><phrase>Tx_Script_P2PubKeyHash_1</phrase></textobject>
</mediaobject>
</figure>
<figure id="P2PubKHash2"><title>Évaluer un script pour une transaction P2PKH (partie 2 sur 2)</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0606.png"/>
  </imageobject>
  <textobject><phrase>Tx_Script_P2PubKeyHash_2</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="digital_sigs">
<title>Signatures numériques (ECDSA)</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;signatures numériques et&quot;</secondary><tertiary>id=&quot;Tdigsig06&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;signatures numériques et&quot;</primary><secondary>id=&quot;Tdigsig06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Tdigsig06&quot;</primary>
</indexterm>Jusqu&#39;à présent, nous n&#39;avons approfondi aucun détail sur les &quot;signatures numériques&quot;. Dans cette section, nous examinons le fonctionnement des signatures numériques et comment elles peuvent présenter la preuve de la propriété d&#39;une clé privée sans révéler cette clé privée.</simpara>
<simpara><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;algorithme utilisés&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;algorithme utilisés&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Elliptic Curve Digital Signature Algorithm (ECDSA)&quot;</primary>
</indexterm>L&#39;algorithme de signature numérique utilisé dans le bitcoin est l&#39;_Elliptic Curve Digital Signature Algorithm_, ou <emphasis>ECDSA</emphasis>. ECDSA est l&#39;algorithme utilisé pour les signatures numériques basées sur des paires de clés privées/publiques à courbe elliptique, comme décrit dans <xref linkend="elliptic_curve"/>. ECDSA est utilisé par les fonctions de script <literal>OP_CHECKSIG</literal>, <literal>OP_CHECKSIGVERIFY</literal>, <literal>OP_CHECKMULTISIG</literal> et <literal>OP_CHECKMULTISIGVERIFY</literal>. Chaque fois que vous les voyez dans un script de verrouillage, le script de déverrouillage doit contenir une signature ECDSA.</simpara>
<simpara><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;objectifs de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;objectifs de&quot;</primary>
</indexterm> Une signature numérique a trois objectifs en bitcoin. Premièrement, la signature prouve que le propriétaire de la clé privée, qui est implicitement le propriétaire des fonds, a <emphasis>autorisé</emphasis> la dépense de ces fonds. Deuxièmement, la preuve de l&#39;autorisation est <emphasis>indéniable</emphasis> (non-répudiable). Troisièmement, la signature prouve que la transaction (ou des parties spécifiques de la transaction) n&#39;a pas et <emphasis>ne peut pas être modifiée</emphasis> par qui que ce soit après avoir été signée.</simpara>
<simpara>Notez que chaque entrée de transaction est signée indépendamment. Ceci est essentiel, car ni les signatures ni les entrées ne doivent appartenir ou être appliquées par les mêmes &quot;propriétaires&quot;. En fait, un schéma de transaction spécifique appelé &quot;CoinJoin&quot; utilise ce fait pour créer des transactions multipartites pour la confidentialité.</simpara>
<note>
<simpara>Chaque entrée de transaction et toute signature qu&#39;elle peut contenir est <emphasis>complètement</emphasis> indépendante de toute autre entrée ou signature. Plusieurs parties peuvent collaborer pour construire des transactions et signer une seule entrée chacune.</simpara>
</note>
<sidebar id="digital_signature_definition">
<title>Définition de Wikipedia d&#39;une &quot;signature numérique&quot;</title>
<simpara><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;défini&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défini&quot;</primary>
</indexterm>Une signature numérique est un schéma mathématique permettant de démontrer l&#39;authenticité d&#39;un message ou de documents numériques. Une signature numérique valide donne au destinataire des raisons de croire que le message a été créé par un expéditeur connu (authentification), que l&#39;expéditeur ne peut pas nier avoir envoyé le message (non-répudiable) et que le message n&#39;a pas été altéré en transit (intégrité).</simpara>
<simpara><emphasis>Source: <ulink url="https://en.wikipedia.org/wiki/Digital_signature">https://en.wikipedia.org/wiki/Digital_signature</ulink></emphasis></simpara>
</sidebar>
<section id="_comment_fonctionnent_les_signatures_numériques">
<title>Comment fonctionnent les signatures numériques</title>
<simpara><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;comment elles fonctionnent&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;comment elles fonctionnent&quot;</primary>
</indexterm>Une signature numérique est un <emphasis>schéma mathématique</emphasis> qui se compose de deux parties. La première partie est un algorithme de création d&#39;une signature, à l&#39;aide d&#39;une clé privée (la clé de signature), à partir d&#39;un message (la transaction). La deuxième partie est un algorithme qui permet à quiconque de vérifier la signature, étant donné également le message et une clé publique.</simpara>
<section id="_création_d_39_une_signature_numérique">
<title>Création d&#39;une signature numérique</title>
<simpara>Dans l&#39;implémentation de l&#39;algorithme ECDSA par bitcoin, le &quot;message&quot; signé est la transaction, ou plus précisément un hachage d&#39;un sous-ensemble spécifique des données de la transaction (voir <xref linkend="sighash_types"/>). La clé de signature est la clé privée de l&#39;utilisateur. Le résultat est la signature :</simpara>
<simpara><inlineequation>
<alt><![CDATA[$\(Sig = F_{sig}(F_{hash}(m), dA)\)$]]></alt>
<inlinemediaobject><textobject><phrase></phrase></textobject></inlinemediaobject>
</inlineequation></simpara>
<simpara>où:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>dA</emphasis> est la clé privée de signature
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>m</emphasis> est la transaction (ou une partie de celle-ci)
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>F</emphasis><subscript><emphasis>hash</emphasis></subscript> est la fonction de hachage
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>F</emphasis><subscript><emphasis>sig</emphasis></subscript> est l&#39;algorithme de signature
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Sig</emphasis> est la signature résultante
</simpara>
</listitem>
</itemizedlist>
<simpara>Plus de détails sur les mathématiques d&#39;ECDSA peuvent être trouvés dans <xref linkend="ecdsa_math"/>.</simpara>
<simpara>La fonction <emphasis>F</emphasis><subscript><emphasis>sig</emphasis></subscript> produit une signature <literal>Sig</literal> composée de deux valeurs, communément appelées <literal>R</literal> et <literal>S</literal> :</simpara>
<screen>Sig = (R, S)</screen>
<simpara><indexterm>
  <primary>&quot;Distinguished Encoding Rules (DER)&quot;</primary>
</indexterm> Maintenant que les deux valeurs <literal>R</literal> et <literal>S</literal> ont été calculées, elles sont sérialisées en un flux d&#39;octets à l&#39;aide d&#39;un schéma de codage standard international appelé <emphasis>Distinguished Encoding Rules</emphasis>, ou <emphasis>DER</emphasis> (ou règles d&#8217;encodage distingués).</simpara>
</section>
<section id="seralization_of_signatures_der">
<title>Sérialisation des signatures (DER)</title>
<simpara>Regardons la transaction Alice <indexterm>
  <primary>&quot;cas d&#8217;utilisation&quot;</primary><secondary>&quot;achat d&#8217;un café&quot;</secondary><tertiary>id=&quot;alicesixtwo&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;achat d&#8217;un café&quot;</primary><secondary>id=&quot;alicesixtwo&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;alicesixtwo&quot;</primary>
</indexterm>créée à nouveau. Dans l&#39;entrée de transaction, il y a un script de déverrouillage qui contient la signature encodée DER suivante du portefeuille d&#39;Alice :</simpara>
<screen>3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e38133</screen>
<simpara>Cette signature est un flux d&#39;octets sérialisé des valeurs <literal>R</literal> et <literal>S</literal> produites par le portefeuille d&#39;Alice pour prouver qu&#39;elle possède la clé privée autorisée à dépenser cette sortie. Le format de sérialisation se compose de neuf éléments comme suit :</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>0x30</literal>—indiquant le début d&#39;une séquence DER
</simpara>
</listitem>
<listitem>
<simpara>
<literal>0x45</literal>—la longueur de la séquence (69 octets)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>0x02</literal>—une valeur entière suit
</simpara>
</listitem>
<listitem>
<simpara>
<literal>0x21</literal>—la longueur de l&#39;entier (33 octets)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>R</literal>—<literal>00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>0x02</literal>—un autre entier suit
</simpara>
</listitem>
<listitem>
<simpara>
<literal>0x20</literal>—la longueur de l&#39;entier (32 octets)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>S</literal>—<literal>4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</literal>
</simpara>
</listitem>
<listitem>
<simpara>
Un suffixe (<literal>0x01</literal>) indiquant le type de hachage utilisé (<literal>SIGHASH_ALL</literal>)
</simpara>
</listitem>
</itemizedlist>
<simpara>Voyez si vous pouvez décoder la signature sérialisée (encodée en DER) d&#39;Alice en utilisant cette liste. Les nombres importants sont <literal>R</literal> et <literal>S</literal> ; le reste des données fait partie du schéma de codage DER.</simpara>
</section>
</section>
<section id="_vérification_de_la_signature">
<title>Vérification de la signature</title>
<simpara><indexterm>
  <primary>&quot;digital signatures&quot;</primary><secondary>&quot;verifying&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;verifying&quot;</primary>
</indexterm>Pour vérifier la signature, il faut avoir la signature (<literal>R</literal> et <literal>S</literal>), la transaction sérialisée, et la clé publique (qui correspond à la clé privée utilisée pour créer la signature). Essentiellement, la vérification d&#39;une signature signifie &quot;Seul le propriétaire de la clé privée qui a généré cette clé publique pourrait avoir produit cette signature sur cette transaction.&quot;</simpara>
<simpara>L&#39;algorithme de vérification de signature prend le message (un hachage de la transaction ou de parties de celui-ci), la clé publique du signataire et la signature (+ valeurs R+ et <literal>S</literal>), et renvoie TRUE si la signature est valide pour ce message et cette clé publique.</simpara>
</section>
<section id="sighash_types">
<title>Types de hachage de signature (SIGHASH)</title>
<simpara><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;signature hash types&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;signature hash types&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;commitment&quot;</primary>
</indexterm>Les signatures numériques sont appliquées aux messages, qui dans le cas du bitcoin, sont les transactions elles-mêmes. La signature implique un <emphasis>engagement</emphasis> du signataire sur des données de transaction spécifiques. Dans sa forme la plus simple, la signature s&#39;applique à l&#39;ensemble de la transaction, engageant ainsi toutes les entrées, sorties et autres champs de transaction. Cependant, une signature ne peut s&#39;engager que sur un sous-ensemble des données d&#39;une transaction, ce qui est utile pour un certain nombre de scénarios, comme nous le verrons dans cette section.</simpara>
<simpara><indexterm>
  <primary>&quot;drapeau SIGHASH&quot;</primary>
</indexterm>Les signatures Bitcoin ont un moyen d&#39;indiquer quelle partie des données d&#39;une transaction est incluse dans le hachage signé par la clé privée à l&#39;aide d&#39;un drapeau <literal>SIGHASH</literal>. Le drapeau <literal>SIGHASH</literal> est un octet unique ajouté à la signature. Chaque signature a un drapeau <literal>SIGHASH</literal> et le drapeau peut être différent d&#39;une entrée à l&#39;autre. Une transaction avec trois entrées signées peut avoir trois signatures avec des drapeaux <literal>SIGHASH</literal> différents, chaque signature signant (committant) différentes parties de la transaction.</simpara>
<simpara>N&#39;oubliez pas que chaque entrée peut contenir une signature dans son script de déverrouillage. Par conséquent, une transaction qui contient plusieurs entrées peut avoir des signatures avec différents indicateurs <literal>SIGHASH</literal> qui valident différentes parties de la transaction dans chacune des entrées. Notez également que les transactions bitcoin peuvent contenir des entrées de différents &quot;propriétaires&quot;, qui ne peuvent signer qu&#39;une seule entrée dans une transaction partiellement construite (et invalide), collaborant avec d&#39;autres pour rassembler toutes les signatures nécessaires pour effectuer une transaction valide. De nombreux types d&#39;indicateurs <literal>SIGHASH</literal> n&#39;ont de sens que si vous pensez à plusieurs participants collaborant en dehors du réseau Bitcoin et mettant à jour une transaction partiellement signée.</simpara>
<simpara role="pagebreak-before">Il existe trois indicateurs <literal>SIGHASH</literal> : <literal>ALL</literal>, <literal>NONE</literal> et <literal>SINGLE</literal>, comme indiqué dans <xref linkend="sighash_types_and_their"/>.</simpara>
<table id="sighash_types_and_their"
frame="all"
rowsep="1" colsep="1"
>
<title>Types SIGHASH et leurs significations</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Drapeau <literal>SIGHASH</literal></entry>
<entry align="left" valign="top"> Valeur </entry>
<entry align="left" valign="top"> Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>TOUS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>0x01</simpara></entry>
<entry align="left" valign="top"><simpara>La signature s&#39;applique à toutes les entrées et sorties</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AUCUN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>0x02</simpara></entry>
<entry align="left" valign="top"><simpara>La signature s&#39;applique à toutes les entrées, aucune des sorties</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SIMPLE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>0x03</simpara></entry>
<entry align="left" valign="top"><simpara>La signature s&#39;applique à toutes les entrées mais uniquement à la sortie avec le même numéro d&#39;index que l&#39;entrée signée</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>De plus, il existe un drapeau modificateur <literal>SIGHASH_ANYONECANPAY</literal>, qui peut être combiné avec chacun des drapeaux précédents. Lorsque <literal>ANYONECANPAY</literal> est défini, une seule entrée est signée, laissant le reste (et leurs numéros de séquence) ouverts pour modification. Le <literal>ANYONECANPAY</literal> a la valeur <literal>0x80</literal> et est appliqué par OR au niveau du bit, ce qui donne les drapeaux combinés comme indiqué dans <xref linkend="sighash_types_with_modifiers"/>.</simpara>
<table id="sighash_types_with_modifiers"
frame="all"
rowsep="1" colsep="1"
>
<title>Types SIGHASH avec modificateurs et leurs significations</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Drapeau SIGHASH</entry>
<entry align="left" valign="top"> Valeur </entry>
<entry align="left" valign="top"> Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ALL|ANYONECANPAY</simpara></entry>
<entry align="left" valign="top"><simpara>0x81</simpara></entry>
<entry align="left" valign="top"><simpara>La signature s&#39;applique à une entrée et à toutes les sorties</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NONE|ANYONECANPAY</simpara></entry>
<entry align="left" valign="top"><simpara>0x82</simpara></entry>
<entry align="left" valign="top"><simpara>La signature s&#39;applique à une entrée, aucune des sorties</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SINGLE|ANYONECANPAY</simpara></entry>
<entry align="left" valign="top"><simpara>0x83</simpara></entry>
<entry align="left" valign="top"><simpara>La signature s&#39;applique à une entrée et à la sortie avec le même numéro d&#39;index</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Ces combinaisons de drapeaux sont résumées dans <xref linkend="sighash_combinations"/>.</simpara>
<figure id="sighash_combinations"><title>Résumé des différentes combinaisons de sighash</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/sighash_combinations.png"/>
  </imageobject>
  <textobject><phrase>&quot;Résumé des différentes combinaisons de drapeaux SIGHASH&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara>La façon dont les drapeaux <literal>SIGHASH</literal> sont appliqués lors de la signature et de la vérification est qu&#39;une copie de la transaction est faite et que certains champs à l&#39;intérieur sont tronqués (mis à zéro et vidés). La transaction résultante est sérialisée. Le drapeau <literal>SIGHASH</literal> est ajouté à la fin de la transaction sérialisée et le résultat est haché. Le hachage lui-même est le &quot;message&quot; qui est signé. Selon l&#39;indicateur <literal>SIGHASH</literal> utilisé, différentes parties de la transaction sont tronquées. Le hachage résultant dépend de différents sous-ensembles de données dans la transaction. En incluant le <literal>SIGHASH</literal> comme dernière étape avant le hachage, la signature valide également le type <literal>SIGHASH</literal>, de sorte qu&#39;il ne peut pas être modifié (par exemple, par un mineur).</simpara>
<note>
<simpara>Tous les types <literal>SIGHASH</literal> signent le champ <literal>nLocktime</literal> de la transaction (voir <xref linkend="transaction_locktime_nlocktime"/>). De plus, le type <literal>SIGHASH</literal> lui-même est ajouté à la transaction avant sa signature, de sorte qu&#39;il ne peut pas être modifié une fois signé.</simpara>
</note>
<simpara>Dans l&#39;exemple de la transaction d&#39;Alice (voir la liste dans <xref linkend="seralization_of_signatures_der"/>), nous avons vu que la dernière partie de la signature codée en DER était <literal>01</literal>, qui est le drapeau <literal>SIGHASH_ALL</literal>. Cela verrouille les données de transaction, de sorte que la signature d&#39;Alice valide l&#39;état de toutes les entrées et sorties. C&#39;est la forme de signature la plus courante.</simpara>
<simpara>Examinons quelques-uns des autres types de <literal>SIGHASH</literal> et comment ils peuvent être utilisés dans la pratique :</simpara>
<variablelist>
<varlistentry>
<term>
<literal>ALL|ANYONECANPAY</literal> 
</term>
<listitem>
<simpara>
<indexterm>
  <primary>&quot;dons caritatifs&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;cas d&#8217;utilisation&quot;</primary><secondary>&quot;dons caritatifs&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;dons caritatifs&quot;</primary>
</indexterm>Cette construction peut être utilisée pour effectuer une transaction de type &quot;financement participatif&quot;. les fonds peuvent construire une transaction avec une seule sortie. La sortie unique paie le montant &quot;objectif&quot; à la collecte de fonds. Une telle transaction n&#39;est évidemment pas valide, car elle n&#39;a pas d&#39;entrées. Cependant, d&#39;autres peuvent maintenant la modifier en ajoutant une entrée de leur propre, en tant que don. Ils signent leur propre entrée avec <literal>ALL|ANYONECANPAY</literal>. À moins que suffisamment d&#39;entrées ne soient rassemblées pour atteindre la valeur de la sortie, la transaction n&#39;est pas valide. Chaque don est un &quot;engagement&quot;, qui ne peut pas être collecté par le collecteur de fonds jusqu&#39;à ce que le montant total de l&#39;objectif soit atteint.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>NONE</literal> 
</term>
<listitem>
<simpara>
Cette construction peut être utilisée pour créer un &quot;chèque au porteur&quot; ou un &quot;chèque en blanc&quot; d&#39;un montant spécifique. Il s&#39;engage sur l&#39;entrée, mais permet de modifier le script de verrouillage de sortie. N&#39;importe qui peut écrire sa propre adresse Bitcoin dans le script de verrouillage de sortie et racheter la transaction. Cependant, la valeur de sortie elle-même est verrouillée par la signature.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>NONE|ANYONECANPAY</literal> 
</term>
<listitem>
<simpara>
Cette construction peut être utilisée pour construire un &quot;collecteur de poussière&quot;. Les utilisateurs qui ont de minuscules UTXO dans leur portefeuille ne peuvent pas les dépenser car le coût des frais dépasse la valeur de la poussière. Avec ce type de signature, la poussière UTXO peut être donnée à quiconque pour l&#39;agréger et la dépenser quand il le souhaite.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><indexterm>
  <primary>&quot;Bitmask Sighash Modes&quot;</primary>
</indexterm> Il y a quelques propositions pour modifier ou étendre le système <literal>SIGHASH</literal>. L&#39;une de ces propositions est <emphasis>Bitmask Sighash Modes</emphasis> de Glenn Willen de Blockstream, dans le cadre du projet Elements. Cela vise à créer un remplacement flexible pour les types <literal>SIGHASH</literal> qui permet &quot;des masques de bits arbitraires et réinscriptibles par des mineurs d&#39;entrées et de sorties&quot; qui peuvent exprimer &quot;des schémas de pré-engagement contractuels plus complexes, tels que des offres signées avec changement dans un échange d&#39;actifs distribué&quot;.</simpara>
<note>
<simpara>Vous ne verrez pas les drapeaux <literal>SIGHASH</literal> présentés comme une option dans l&#39;application de portefeuille d&#39;un utilisateur. À quelques exceptions près, les portefeuilles construisent des scripts P2PKH et signent avec les drapeaux <literal>SIGHASH_ALL</literal>. Pour utiliser un indicateur <literal>SIGHASH</literal> différent, vous devrez écrire un logiciel pour construire et signer des transactions. Plus important encore, les drapeaux <literal>SIGHASH</literal> peuvent être utilisés par des applications bitcoin à usage spécial qui permettent de nouvelles utilisations.</simpara>
</note>
</section>
<section id="ecdsa_math">
<title>Mathématiques ECDSA</title>
<simpara><indexterm>
  <primary>&quot;Elliptic Curve Digital Signature Algorithm (ECDSA)&quot;</primary>
</indexterm>Comme mentionné précédemment, les signatures sont créées par une fonction mathématique <emphasis>F</emphasis><subscript><emphasis>sig</emphasis></subscript> qui produit une signature composée de deux valeurs <emphasis>R</emphasis> et <emphasis>S</emphasis>. Dans cette section, nous examinons la fonction <emphasis>F</emphasis><subscript><emphasis>sig</emphasis></subscript> plus en détail.</simpara>
<simpara><indexterm>
  <primary>&quot;clés publiques et privées&quot;</primary><secondary>&quot;paires de clés&quot;</secondary><tertiary>&quot;éphémère&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;paires de clés&quot;</primary><secondary>&quot;éphémère&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;éphémère&quot;</primary>
</indexterm>L&#39;algorithme de signature génère d&#39;abord une paire de clés publiques privées <emphasis>éphémères</emphasis> (temporaires). Cette paire de clés temporaire est utilisée dans le calcul des valeurs <emphasis>R</emphasis> et <emphasis>S</emphasis>, après une transformation impliquant la clé privée de signature et le hachage de la transaction.</simpara>
<simpara>La paire de clés temporaire est basée sur un nombre aléatoire <emphasis>k</emphasis>, qui est utilisé comme clé privée temporaire. À partir de <emphasis>k</emphasis>, nous générons la clé publique temporaire correspondante <emphasis>P</emphasis> (calculée comme <emphasis>P = k*G</emphasis>, de la même manière que les clés publiques bitcoin sont dérivées ; voir <xref linkend="pubkey"/>). La valeur <emphasis>R</emphasis> de la signature numérique est alors la coordonnée x de la clé publique éphémère <emphasis>P</emphasis>.</simpara>
<simpara>A partir de là, l&#39;algorithme calcule la valeur <emphasis>S</emphasis> de la signature, telle que :</simpara>
<simpara><emphasis>S</emphasis> = <emphasis>k</emphasis><superscript>-1</superscript> (<emphasis>Hash</emphasis>(<emphasis>m</emphasis>) + <emphasis>dA</emphasis> * <emphasis>R</emphasis>) <emphasis>mod n</emphasis></simpara>
<simpara>où:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>k</emphasis> est la clé privée éphémère
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>R</emphasis> est la coordonnée x de la clé publique éphémère
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>dA</emphasis> est la clé privée de signature
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>m</emphasis> est les données de transaction
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>n</emphasis> est l&#39;ordre premier de la courbe elliptique
</simpara>
</listitem>
</itemizedlist>
<simpara>La vérification est l&#39;inverse de la fonction de génération de signature, utilisant les valeurs <emphasis>R</emphasis>, <emphasis>S</emphasis> et la clé publique pour calculer une valeur <emphasis>P</emphasis>, qui est un point sur la courbe elliptique (la clé publique éphémère utilisée dans la création de signature) :</simpara>
<simpara><emphasis>P</emphasis> = <emphasis>S</emphasis><superscript>-1</superscript> * <emphasis>Hash</emphasis>(<emphasis>m</emphasis>) * <emphasis>G</emphasis> + <emphasis>S</emphasis><superscript>-1</superscript> * <emphasis>R</emphasis> * <emphasis>Qa</emphasis></simpara>
<simpara>où:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>R</emphasis> et <emphasis>S</emphasis> sont les valeurs de signature
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Qa</emphasis> est la clé publique d&#39;Alice
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>m</emphasis> est les données de transaction qui ont été signées
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>G</emphasis> est le point générateur de la courbe elliptique
</simpara>
</listitem>
</itemizedlist>
<simpara>Si la coordonnée x du point calculé <emphasis>P</emphasis> est égale à <emphasis>R</emphasis>, alors le vérificateur peut conclure que la signature est valide.</simpara>
<simpara>Notez qu&#39;en vérifiant la signature, la clé privée n&#39;est ni connue ni révélée.</simpara>
<tip>
<simpara>ECDSA est nécessairement un calcul assez compliqué; une explication complète est au-delà de la portée de ce livre. Un certain nombre d&#39;excellents guides en ligne vous guident étape par étape : recherchez &quot;ECDSA expliqué&quot; ou essayez celui-ci : <ulink url="https://bit.ly/2r0HhGB">https://bit.ly/2r0HhGB</ulink>.</simpara>
</tip>
</section>
<section id="_l_39_importance_du_caractère_aléatoire_dans_les_signatures">
<title>L&#39;importance du caractère aléatoire dans les signatures</title>
<simpara><indexterm>
  <primary>&quot;signatures numériques&quot;</primary><secondary>&quot;caractère aléatoire&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;caractère aléatoire&quot;</primary>
</indexterm>Comme nous l&#39;avons vu dans <xref linkend="ecdsa_math"/>, l&#39;algorithme de génération de signature utilise une clé aléatoire <emphasis>k</emphasis>, comme base d&#39;un couple clé privée/publique éphémère. La valeur de <emphasis>k</emphasis> n&#39;est pas importante, <emphasis>tant qu&#39;elle est aléatoire</emphasis>. Si la même valeur <emphasis>k</emphasis> est utilisée pour produire deux signatures sur différents messages (transactions), alors la signature <emphasis>clé privée</emphasis> peut être calculée par n&#39;importe qui. La réutilisation de la même valeur pour <emphasis>k</emphasis> dans un algorithme de signature conduit à l&#39;exposition de la clé privée !</simpara>
<warning>
<simpara><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;signatures numériques&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;signatures numériques&quot;</primary>
</indexterm>Si la même valeur <emphasis>k</emphasis> est utilisée dans l&#39;algorithme de signature sur deux transactions différentes, la clé privée peut être calculée et exposée au monde !</simpara>
</warning>
<simpara>Ce n&#39;est pas seulement une possibilité théorique. Nous avons vu ce problème conduire à l&#39;exposition de clés privées dans quelques implémentations différentes d&#39;algorithmes de signature de transaction en bitcoin. Des personnes se sont fait voler des fonds en raison de la réutilisation par inadvertance d&#39;une valeur <emphasis>k</emphasis>. La raison la plus courante de réutilisation d&#39;une valeur <emphasis>k</emphasis> est un générateur de nombres aléatoires mal initialisé.</simpara>
<simpara><indexterm>
  <primary>&quot;nombres aléatoires&quot;</primary><secondary>&quot;génération de nombres aléatoires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de nombres aléatoires&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;entropie&quot;</primary><secondary>&quot;génération de nombres aléatoires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;génération de nombres aléatoires&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;initialisation déterministe&quot;</primary>
</indexterm>Pour éviter cette vulnérabilité, la meilleure pratique de l&#39;industrie est de ne pas générer <emphasis>k</emphasis> avec un générateur de nombres aléatoires semé d&#39;entropie, mais plutôt d&#39;utiliser un processus déterministe-aléatoire semé avec les données de transaction elles-mêmes. Cela garantit que chaque transaction produit un <emphasis>k</emphasis> différent. L&#39;algorithme standard de l&#39;industrie pour l&#39;initialisation déterministe de <emphasis>k</emphasis> est défini dans <ulink url="https://tools.ietf.org/html/rfc6979">RFC 6979</ulink>, publié par l&#39;Internet Engineering Task Force.</simpara>
<simpara>Si vous implémentez un algorithme pour signer des transactions en bitcoin, vous <emphasis>devez</emphasis> utiliser la RFC 6979 ou un algorithme déterministe-aléatoire similaire pour vous assurer de générer un <emphasis>k</emphasis> différent pour chaque transaction.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Tdigsig06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Tdigsig06&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="_adresses_bitcoin_soldes_et_autres_abstractions">
<title>Adresses Bitcoin, soldes et autres abstractions</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;abstractions de niveau supérieur&quot;</secondary><tertiary>id=&quot;Thigher06&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;abstractions de niveau supérieur&quot;</primary><secondary>id=&quot;Thigher06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Thigher06&quot;</primary>
</indexterm>Nous avons commencé ce chapitre avec la découverte que les transactions sont très différentes &quot;dans les coulisses&quot; de la façon dont elles sont présentées dans les portefeuilles, les explorateurs de chaîne de blocs, et d&#39;autres applications destinées aux utilisateurs. De nombreux concepts simplistes et familiers des chapitres précédents, tels que les adresses et les soldes Bitcoin, semblent être absents de la structure de transaction. Nous avons vu que les transactions ne contiennent pas d&#39;adresses Bitcoin en soi, mais fonctionnent plutôt via des scripts qui verrouillent et déverrouillent des valeurs discrètes de bitcoin. Les soldes ne sont présents nulle part dans ce système et pourtant, chaque application de portefeuille affiche bien en évidence le solde du portefeuille de l&#39;utilisateur.</simpara>
<simpara>Maintenant que nous avons exploré ce qui est réellement inclus dans une transaction bitcoin, nous pouvons examiner comment les abstractions de niveau supérieur sont dérivées des composants apparemment primitifs de la transaction.</simpara>
<simpara>Regardons à nouveau comment la transaction d&#39;Alice a été présentée sur un explorateur de blocs populaire (<xref linkend="alice_transaction_to_bobs_cafe"/>).</simpara>
<figure id="alice_transaction_to_bobs_cafe"><title>Transaction d&#39;Alice au Bob&#39;s Café</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0208.png"/>
  </imageobject>
  <textobject><phrase>Alice Coffee Transaction</phrase></textobject>
</mediaobject>
</figure>
<simpara>Sur le côté gauche de la transaction, l&#39;explorateur de explorateur de chaîne de blocs affiche l&#39;adresse Bitcoin d&#39;Alice comme &quot;expéditeur&quot;. En fait, cette information n&#39;est pas dans la transaction elle-même. Lorsque l&#39;explorateur de blockchain fait référence à la transaction, il fait également référence à la transaction précédente associée à l&#39;entrée et extrait la première sortie de cette transaction plus ancienne. Dans cette sortie se trouve un script de verrouillage qui verrouille l&#39;UTXO sur le hachage de la clé publique d&#39;Alice (un script P2PKH). L&#39;explorateur de blockchain a extrait le hachage de la clé publique et l&#39;a encodé à l&#39;aide de l&#39;encodage Base58Check pour produire et afficher l&#39;adresse Bitcoin qui représente cette clé publique.</simpara>
<simpara>De même, sur le côté droit, l&#39;explorateur de blockchain affiche les deux sorties ; le premier à l&#39;adresse Bitcoin de Bob et le second à l&#39;adresse Bitcoin d&#39;Alice (comme change). Encore une fois, pour créer ces adresses Bitcoin, l&#39;explorateur de blockchain a extrait le script de verrouillage de chaque sortie, l&#39;a reconnu comme un script P2PKH et a extrait le hachage de clé publique de l&#39;intérieur. Enfin, l&#39;explorateur de blockchain a réencodé chaque hachage de clé publique avec Base58Check pour produire et afficher les adresses Bitcoin.</simpara>
<simpara>Si vous deviez cliquer sur l&#39;adresse Bitcoin de Bob, l&#39;explorateur de blockchain vous montrerait la vue dans <xref linkend="the_balance_of_bobs_bitcoin_address"/>.</simpara>
<figure id="the_balance_of_bobs_bitcoin_address"><title>Le solde de l&#39;adresse Bitcoin de Bob</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mbc2_0608.png"/>
  </imageobject>
  <textobject><phrase>&quot;Le solde de l&#39;adresse Bitcoin de Bob&quot;</phrase></textobject>
</mediaobject>
</figure>
<simpara>L&#39;explorateur de la chaîne de blocs affiche le solde de l&#39;adresse Bitcoin de Bob. Mais nulle part dans le système Bitcoin il n&#39;y a un concept de &quot;solde&quot;. Au lieu de cela, les valeurs affichées ici sont construites par l&#39;explorateur de explorateur de chaîne de blocs comme suit.</simpara>
<simpara>Pour construire le montant &quot;Total reçu&quot;, l&#39;explorateur de explorateur de la chaîne de blocs décodera d&#39;abord l&#39;encodage Base58Check de l&#39;adresse Bitcoin pour récupérer le hachage 160 bits de la clé publique de Bob qui est encodé dans l&#39;adresse. Ensuite, l&#39;explorateur de blockchain recherchera dans la base de données des transactions, à la recherche de sorties avec des scripts de verrouillage P2PKH contenant le hachage de la clé publique de Bob. En additionnant la valeur de toutes les sorties, l&#39;explorateur de la chaîne de blocs peut produire la valeur totale reçue.</simpara>
<simpara>Construire le solde actuel (affiché comme &quot;Solde final&quot;) nécessite un peu plus de travail. L&#39;explorateur de la chaîne de blocs conserve une base de données distincte des sorties actuellement non dépensées, l&#39;ensemble UTXO. Pour maintenir cette base de données, l&#39;explorateur de la chaîne de blocs doit surveiller le réseau Bitcoin, ajouter les UTXO nouvellement créés et supprimer les UTXO dépensés, en temps réel, tels qu&#39;ils apparaissent dans les transactions non confirmées. Il s&#39;agit d&#39;un processus compliqué qui dépend du suivi des transactions au fur et à mesure qu&#39;elles se propagent, ainsi que du maintien d&#39;un consensus avec le réseau Bitcoin pour s&#39;assurer que la chaîne correcte est suivie. Parfois, l&#39;explorateur de la chaîne de blocs est désynchronisé et sa perspective de l&#39;ensemble UTXO est incomplète ou incorrecte.</simpara>
<simpara>À partir de l&#39;ensemble UTXO, l&#39;explorateur de la chaîne de blocs résume la valeur de toutes les sorties non dépensées faisant référence au hachage de la clé publique de Bob et produit le numéro &quot;Solde final&quot; affiché à l&#39;utilisateur.</simpara>
<simpara>Afin de produire cette image unique, avec ces deux &quot;soldes&quot;, l&#39;explorateur de la chaîne de blocs doit indexer et rechercher parmi des dizaines, des centaines, voire des centaines de milliers de transactions.</simpara>
<simpara>En résumé, les informations présentées aux utilisateurs via les applications de portefeuille, les explorateurs de chaînes de blocs et d&#39;autres interfaces utilisateur Bitcoin sont souvent composées d&#39;abstractions de niveau supérieur qui sont dérivées en recherchant de nombreuses transactions différentes, en inspectant leur contenu et en manipulant les données qu&#39;elles contiennent. En présentant cette vision simpliste des transactions bitcoin qui ressemblent à des chèques bancaires d&#39;un expéditeur à un destinataire, ces applications doivent extraire de nombreux détails sous-jacents. Ils se concentrent principalement sur les types de transactions courants : P2PKH avec des signatures SIGHASH_ALL sur chaque entrée. Ainsi, alors que les applications bitcoin peuvent présenter plus de 80% de toutes les transactions de manière facile à lire, elles sont parfois bloquées par des transactions qui s&#39;écartent de la norme. Les transactions qui contiennent des scripts de verrouillage plus complexes, ou différents indicateurs SIGHASH, ou de nombreuses entrées et sorties, démontrent la simplicité et la faiblesse de ces abstractions.</simpara>
<simpara>Chaque jour, des centaines de transactions qui ne contiennent pas de sorties P2PKH sont confirmées sur la chaîne de blocs. Les explorateurs de chaîne de blocs les présentent souvent avec des messages d&#39;avertissement rouges indiquant qu&#39;ils ne peuvent pas décoder une adresse.</simpara>
<simpara>Comme nous le verrons au chapitre suivant, il ne s&#39;agit pas nécessairement de transactions étranges. Ce sont des transactions qui contiennent des scripts de verrouillage plus complexes que le P2PKH commun. Nous apprendrons ensuite à décoder et à comprendre des scripts plus complexes et les applications qu&#39;ils prennent en charge.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Thigher06&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Thigher06&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;alicesixtwo&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;alicesixtwo&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="adv_transactions">
<title>Transactions et scripts avancés</title>
<section id="ch07_intro">
<title>Présentation</title>
<simpara>Dans le chapitre précédent, nous avons présenté les éléments de base des transactions bitcoin et examiné le type de script de transaction le plus courant, le script P2PKH. Dans ce chapitre, nous examinerons des scripts plus avancés et comment nous pouvons les utiliser pour créer des transactions avec des conditions complexes.</simpara>
<simpara>Tout d&#39;abord, nous examinerons les scripts <emphasis>multisignature</emphasis>. Ensuite, nous examinerons le deuxième script de transaction le plus courant, <emphasis>Pay-to-Script-Hash</emphasis>, qui ouvre tout un monde de scripts complexes. Ensuite, nous examinerons de nouveaux opérateurs de script qui ajoutent une dimension temporelle au bitcoin, via les <emphasis>timelocks</emphasis> (verrouillage horaire). Enfin, nous examinerons les <emphasis>Segregated Witness</emphasis> (témoins séparés), une modification architecturale de la structure des transactions.</simpara>
</section>
<section id="multisig">
<title>Multisignature</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>&quot;scripts multisignatures&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>&quot;scripts multisignatures&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts multisignatures&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>id=&quot;Tadv07&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>id=&quot;Tadv07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Tadv07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripts&quot;</primary><secondary>&quot;scripts multisignatures&quot;</secondary><tertiary>id=&quot;Smulti07&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;scripts multisignatures&quot;</primary><secondary>id=&quot;Smulti07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Smulti07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripts multisignatures&quot;</primary>
</indexterm>Les scripts multisignatures définissent une condition dans laquelle N clés publiques sont enregistrées dans le script et au moins M d&#39;entre elles doivent fournir des signatures pour débloquer les fonds. Ceci est également connu sous le nom de schéma M-sur-N, où N est le nombre total de clés et M est le seuil de signatures requises pour la validation. Par exemple, une multisignature 2 sur 3 est celle où trois clés publiques sont répertoriées comme signataires potentiels et au moins deux d&#39;entre elles doivent être utilisées pour créer des signatures pour une transaction valide afin de dépenser les fonds.</simpara>
<simpara>À l&#39;heure actuelle, les scripts multisignatures <emphasis>standard</emphasis> sont limités à un maximum de 3 clés publiques répertoriées, ce qui signifie que vous pouvez faire n&#39;importe quoi d&#39;une multisignature 1 sur 1 jusqu&#8217;à 3 sur 3 ou toute combinaison dans cette plage. La limitation à 3 clés répertoriées pourrait être levée au moment de la publication de ce livre, alors vérifiez la fonction <literal>IsStandard()</literal> pour voir ce qui est actuellement accepté par le réseau. Notez que la limite de 3 clés s&#39;applique uniquement aux scripts multisignatures standard (également appelés &quot;nus (bare en anglais)&quot;), et non aux scripts multisignatures enveloppés dans un script Pay-to-Script-Hash (P2SH). Les scripts multisignatures P2SH sont limités à 15 clés, permettant jusqu&#39;à 15 multisignatures sur 15. Cette limitation est également imposée par la fonction <literal>IsStandard()</literal>. Nous en apprendrons davantage sur P2SH dans <xref linkend="p2sh"/>.</simpara>
<simpara>La forme générale d&#39;un script de verrouillage définissant une condition multisignature M-de-N est :</simpara>
<screen>M &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key N&gt; N CHECKMULTISIG</screen>
<simpara>où N est le nombre total de clés publiques répertoriées et M est le seuil de signatures requises pour dépenser la sortie.</simpara>
<simpara>Un script de verrouillage définissant une condition multisignature 2 sur 3 ressemble à ceci :</simpara>
<screen>2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</screen>
<simpara>Le script de verrouillage précédent peut se contenter d&#39;un script de déverrouillage contenant n&#39;importe quelle combinaison de deux signatures issues des clés privées correspondant aux trois clés publiques listées :</simpara>
<screen>&lt;Signature B&gt; &lt;Signature C&gt;</screen>
<simpara>Les deux scripts ensemble formeraient le script de validation combiné :</simpara>
<screen>&lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</screen>
<simpara>Lorsqu&#39;il est exécuté, ce script combiné sera évalué à TRUE si, et seulement si, le script de déverrouillage correspond aux conditions définies par le script de verrouillage. Dans ce cas, la condition est de savoir si le script de déverrouillage possède une signature valide à partir des deux clés privées qui correspondent à deux des trois clés publiques définies comme une charge.</simpara>
<section id="multisig_bug">
<title>Un bogue dans l&#39;exécution de CHECKMULTISIG</title>
<simpara><indexterm>
  <primary>&quot;scripting&quot;</primary><secondary>&quot;multisignature scripts&quot;</secondary><tertiary>&quot;CHECKMULTISIG bug&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;multisignature scripts&quot;</primary><secondary>&quot;CHECKMULTISIG bug&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;CHECKMULTISIG bug&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;CHECKMULTISIG bug workaround&quot;</primary>
</indexterm>Il y a un bug dans l&#39;exécution de <literal>CHECKMULTISIG</literal> qui nécessite une légère solution de contournement. Lorsque <literal>CHECKMULTISIG</literal> s&#39;exécute, il doit consommer M+N+2 éléments sur la pile en tant que paramètres. Cependant, en raison du bogue, <literal>CHECKMULTISIG</literal> affichera une valeur supplémentaire ou une valeur de plus que prévu.</simpara>
<simpara>Examinons cela plus en détail à l&#39;aide de l&#39;exemple de validation précédent :</simpara>
<screen>&lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</screen>
<simpara>Tout d&#39;abord, <literal>CHECKMULTISIG</literal> affiche l&#39;élément supérieur, qui est <literal>N</literal> (dans cet exemple &quot;3&quot;). Ensuite, il affiche <literal>N</literal> éléments, qui sont les clés publiques pouvant signer. Dans cet exemple, les clés publiques A, B et C. Ensuite, un élément apparaît, qui est <literal>M</literal>, le quorum (combien de signatures sont nécessaires). Ici M = 2. À ce stade, <literal>CHECKMULTISIG</literal> devrait faire apparaître les éléments finaux <literal>M</literal>, qui sont les signatures, et voir s&#39;ils sont valides. Cependant, malheureusement, un bogue dans l&#39;implémentation fait que <literal>CHECKMULTISIG</literal> affiche un élément de plus (M+1 total) qu&#39;il ne le devrait. L&#39;élément supplémentaire n&#39;est pas pris en compte lors de la vérification des signatures, il n&#39;a donc aucun effet direct sur <literal>CHECKMULTISIG</literal> lui-même. Cependant, une valeur supplémentaire doit être présente car si elle n&#39;est pas présente, lorsque <literal>CHECKMULTISIG</literal> tente d&#39;apparaître sur une pile vide, cela provoquera une erreur de pile et un échec du script (marquant la transaction comme invalide). Comme l&#39;élément supplémentaire n&#39;est pas pris en compte, il peut s&#39;agir de n&#39;importe quoi, mais habituellement <literal>0</literal> est utilisé.</simpara>
<simpara>Parce que ce bogue est devenu une partie des règles de consensus, il doit maintenant être répliqué pour toujours. Par conséquent, la validation correcte du script ressemblerait à ceci :</simpara>
<screen>0 &lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</screen>
<simpara>Ainsi le script de déverrouillage réellement utilisé en multisig n&#39;est pas :</simpara>
<screen>&lt;Signature B&gt; &lt;Signature C&gt;</screen>
<simpara>mais à la place c&#39;est :</simpara>
<screen>0 &lt;Signature B&gt; &lt;Signature C&gt;</screen>
<simpara>À partir de maintenant, si vous voyez un script de déverrouillage multisig, vous devriez vous attendre à voir un <literal>0</literal> supplémentaire au début, dont le seul but est de contourner un bogue qui est accidentellement devenu une règle de consensus.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Smulti07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Smulti07&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="p2sh">
<title>Pay-to-Script-Hash (P2SH)</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>&quot;Pay-to-Script-Hash&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>&quot;Pay-to-Script-Hash&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Pay-to-Script-Hash&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripting&quot;</primary><secondary>&quot;Pay-to-Script-Hash&quot;</secondary><tertiary>id=&quot;Spay07&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Pay-to-Script-Hash&quot;</primary><secondary>id=&quot;Spay07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Spay07&quot;</primary>
</indexterm>Pay- to-Script-Hash (P2SH) a été introduit en 2012 en tant que nouveau type de transaction puissant qui simplifie grandement l&#39;utilisation de scripts de transaction complexes. Pour expliquer le besoin de P2SH, regardons un exemple pratique.</simpara>
<simpara><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;import/export&quot;</secondary><tertiary>id=&quot;mohamseven&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;import/export&quot;</primary><secondary>id=&quot;mohamseven&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;mohamseven&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripting&quot;</primary><secondary>&quot;Pay-to-Script-Hash&quot;</secondary><tertiary>&quot;exemple d&#8217;import/export&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Pay-to-Script-Hash&quot;</primary><secondary>&quot;exemple d&#8217;import/export&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exemple d&#8217;import/export&quot;</primary>
</indexterm>(( (&quot;Pay-to-Script-Hash (P2SH)&quot;, &quot;exemple d&#39;import/export&quot;)))Dans <xref linkend="ch01_intro_what_is_bitcoin"/> nous avons présenté Mohammed, un importateur d&#39;électronique basé à Dubaï. La société de Mohammed utilise largement la fonction multisignature de Bitcoin pour ses comptes d&#39;entreprise. Les scripts multisignatures sont l&#39;une des utilisations les plus courantes des capacités de script avancées de Bitcoin et constituent une fonctionnalité très puissante. <indexterm>
  <primary>&quot;comptes recevables&quot;</primary>
</indexterm>La société de Mohammed utilise un script multisignature pour tous les paiements des clients, connu en termes comptables sous le nom de &quot;comptes débiteurs ou recevables&quot;. Avec le schéma multisignature, tous les paiements effectués par les clients sont verrouillés de telle manière qu&#39;ils nécessitent au moins deux signatures pour être libérés, de Mohammed et de l&#39;un de ses partenaires ou de son avocat qui dispose d&#39;une clé de secours. Un système multisignature comme celui-ci offre des contrôles de gouvernance d&#39;entreprise et protège contre le vol, le détournement de fonds ou la perte.</simpara>
<simpara>Le script résultant est assez long et ressemble à ceci :</simpara>
<screen>2 &lt;Clé publique de Mohammed&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 CHECKMULTISIG</screen>
<simpara>Bien que les scripts multisignatures soient une fonctionnalité puissante, ils sont lourds à utiliser. Compte tenu du script précédent, Mohammed devrait communiquer ce script à chaque client avant le paiement. Chaque client devrait utiliser un logiciel spécial de portefeuille bitcoin avec la possibilité de créer des scripts de transaction personnalisés, et chaque client devrait comprendre comment créer une transaction à l&#39;aide de scripts personnalisés. De plus, la transaction résultante serait environ cinq fois plus importante qu&#39;une simple transaction de paiement, car ce script contient des clés publiques très longues. Le fardeau de cette transaction extra-large serait supporté par le client sous la forme de frais. Enfin, un gros script de transaction comme celui-ci serait transporté dans l&#39;UTXO défini dans la RAM de chaque nœud complet, jusqu&#39;à ce qu&#39;il soit dépensé. Tous ces problèmes rendent difficile l&#39;utilisation de scripts de verrouillage complexes dans la pratique.</simpara>
<simpara>P2SH a été développé pour résoudre ces difficultés pratiques et rendre l&#39;utilisation de scripts complexes aussi simple qu&#39;un paiement à une adresse Bitcoin. Avec les paiements P2SH, le script de verrouillage complexe est remplacé par son empreinte numérique, un hachage cryptographique. Lorsqu&#39;une transaction tentant de dépenser l&#39;UTXO est présentée ultérieurement, elle doit contenir le script correspondant au hachage, en plus du script de déverrouillage. En termes simples, P2SH signifie &quot;payer à un script correspondant à ce hachage, un script qui sera présenté plus tard lorsque cette sortie sera dépensée&quot;.</simpara>
<simpara><indexterm>
  <primary>&quot;scripts de rachat&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;scripts de rachat&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de rachat&quot;</primary>
</indexterm>Dans les transactions P2SH, le script de verrouillage qui est remplacé par un hachage est appelé <emphasis>redeem script</emphasis> ou <emphasis>script de rachat</emphasis> car il est présenté au système au moment du rachat plutôt que comme un script de verrouillage. <xref linkend="without_p2sh"/> affiche le script sans P2SH et <xref linkend="with_p2sh"/> montre le même script encodé avec P2SH.</simpara>
<table id="without_p2sh"
frame="all"
rowsep="1" colsep="1"
>
<title>Script complexe sans P2SH</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Script de verrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Script de déverrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>0 Sig1 Sig2</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="with_p2sh"
frame="all"
rowsep="1" colsep="1"
>
<title>Script complexe comme P2SH</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Script de rachat</simpara></entry>
<entry align="left" valign="top"><simpara>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Script de verrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>HASH160 &lt;20-byte hash of redeem script&gt; EQUAL</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Script de déverrouillage</simpara></entry>
<entry align="left" valign="top"><simpara>0 Sig1 Sig2 &lt;redeem script&gt;</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Comme vous pouvez le voir dans les tableaux, avec P2SH, le script complexe qui détaille les conditions de dépense de la sortie (script de rachat) n&#39;est pas présenté dans le script de verrouillage. Au lieu de cela, seul un hachage de celui-ci se trouve dans le script de verrouillage et le script de rachat lui-même est présenté plus tard, dans le cadre du script de déverrouillage lorsque la sortie est dépensée. Cela déplace le fardeau des frais et de la complexité de l&#39;expéditeur (qui crée la transaction) vers le destinataire (qui déverrouille et dépense la transaction).</simpara>
<simpara>Examinons la société de Mohammed, le script multisignature complexe et les scripts P2SH qui en résultent.</simpara>
<simpara>Tout d&#39;abord, le script multisignature que la société de Mohammed utilise pour tous les paiements entrants des clients :</simpara>
<screen>2 &lt;Clé publique de Mohammed&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 CHECKMULTISIG</screen>
<simpara>Si les espaces réservés sont remplacés par des clés publiques réelles (affichées ici sous forme de nombres de 520 bits commençant par 04), vous pouvez voir que ce script devient très long :</simpara>
<screen>2
04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800 5 CHECKMULTISIG</screen>
<simpara>Ce script entier peut à la place être représenté par un hachage cryptographique de 20 octets, en appliquant d&#39;abord l&#39;algorithme de hachage SHA256, puis en appliquant l&#39;algorithme RIPEMD160 sur le résultat.</simpara>
<simpara>Nous utilisons <literal>libbitcoin-explorer</literal> (<literal>bx</literal>) sur la ligne de commande pour produire le hachage du script, comme suit :</simpara>
<screen>echo \
2 \
[04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \
[04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \
[047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \
[0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \
[043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \
5 CHECKMULTISIG \
| bx script-encode | bx sha256 | bx ripemd160
54c557e07dde5bb6cb791c7a540e0a4796f5e97e</screen>
<simpara>La série de commandes ci-dessus encode d&#39;abord le script de rachat multisig de Mohammed en tant que script bitcoin sérialisé encodé en hexadécimal. La commande <literal>bx</literal> suivante calcule le hachage SHA256 de cela. La prochaine commande <literal>bx</literal> hache à nouveau avec RIPEMD160, produisant le hachage de script final :</simpara>
<simpara>Le hachage de 20 octets du script de rachat de Mohammed est :</simpara>
<screen>54c557e07dde5bb6cb791c7a540e0a4796f5e97e</screen>
<simpara>Une transaction P2SH verrouille la sortie sur ce hachage au lieu du script de rachat plus long, en utilisant le script de verrouillage :</simpara>
<screen>HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL</screen>
<simpara>qui, comme vous pouvez le voir, est beaucoup plus courte. Au lieu de &quot;payer à ce script multisignature à 5 clés&quot;, la transaction équivalente à P2SH est &quot;payer à un script avec ce hachage&quot;. Un client effectuant un paiement à la société de Mohammed n&#39;a qu&#39;à inclure ce script de verrouillage beaucoup plus court dans son paiement. Lorsque Mohammed et ses partenaires veulent dépenser cet UTXO, ils doivent présenter le script de rachat original (celui dont le hachage a verrouillé l&#39;UTXO) et les signatures nécessaires pour le déverrouiller, comme ceci :</simpara>
<screen>&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG&gt;</screen>
<simpara>Les deux scripts sont combinés en deux étapes. Tout d&#39;abord, le script de rachat est vérifié par rapport au script de verrouillage pour s&#39;assurer que le hachage correspond :</simpara>
<screen>&lt;2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG&gt; HASH160 &lt;redeem scriptHash&gt; EQUAL</screen>
<simpara>Si le hachage du script de rachat correspond, le script de déverrouillage est exécuté de lui-même pour déverrouiller le script de rachat :</simpara>
<screen>&lt;Sig1&gt; &lt;Sig2&gt; 2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG</screen>
<simpara>Presque tous les scripts décrits dans ce chapitre ne peuvent être implémentés qu&#39;en tant que scripts P2SH. Par exemple, un script de verrouillage multisignature standard 2 sur 5 ne peut pas être utilisé directement dans le script de verrouillage d&#39;un UTXO, car <literal>IsStandard()</literal> invaliderait la transaction. Pour se conformer, un script de verrouillage P2SH peut être utilisé à la place, comme vu ci-dessus. Une transaction qui comprend alors un script de déverrouillage P2SH peut être utilisée pour racheter cet UTXO et sera valide tant qu&#39;elle ne contient pas plus de 15 clés publiques. <indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;mohamseven&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;mohamseven&quot;</primary>
</indexterm></simpara>
<tip>
<simpara>N&#39;oubliez pas qu&#39;en raison de la politique définie par la fonction <literal>IsStandard()</literal> au moment de la rédaction de cet article, les scripts multisignatures standard sont limités à 3 clés publiques répertoriées au maximum, tandis que les scripts P2SH sont limités à 15 clés publiques répertoriées au maximum. Les scripts multisignatures standard peuvent invalider les transactions au moyen de leur script de verrouillage <emphasis>ou</emphasis> de déverrouillage, tandis que les scripts P2SH peuvent invalider les transactions au moyen de leur script de déverrouillage <emphasis>uniquement</emphasis>. En effet, <literal>IsStandard()</literal> n&#39;a aucun moyen de savoir si un hachage d&#39;un script de rachat dans un script de verrouillage inclut plus de signatures que la limite de taille actuellement imposée, il ne peut donc observer que les scripts de déverrouillage dans les entrées de transaction.</simpara>
</tip>
<section id="_adresses_p2sh">
<title>Adresses P2SH</title>
<simpara><indexterm>
  <primary>&quot;script&quot;</primary><secondary>&quot;Pay-to-Script-Hash&quot;</secondary><tertiary>&quot;adresses&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Pay-to-Script-Hash&quot;</primary><secondary>&quot;adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;adresses&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Pay-to-Script-Hash (P2SH)&quot;</primary><secondary>&quot;adresses&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;adresses&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;bitcoin propositions d&#39;amélioration&quot;</primary><secondary>&quot;Format d&#39;adresse pour P2SH (BIP-13)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Format d&#39;adresse pour P2SH (BIP-13)&quot;</primary>
</indexterm>Une autre partie importante de la fonctionnalité P2SH est la possibilité d&#39;encoder un hachage de script en tant qu&#39;adresse, comme défini dans BIP-13. Les adresses P2SH sont des encodages Base58Check du hachage de 20 octets d&#39;un script, tout comme les adresses Bitcoin sont des encodages Base58Check du hachage de 20 octets d&#39;une clé publique. Les adresses P2SH utilisent le préfixe de version &quot;5&quot;, ce qui donne des adresses encodées en Base58Check qui commencent par un &quot;3&quot;.</simpara>
<simpara>Par exemple, le script complexe de Mohammed, haché et encodé en Base58Check comme une adresse P2SH, devient <literal>39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</literal>. Nous pouvons le confirmer avec la commande <literal>bx</literal> :</simpara>
<screen>echo \
'54c557e07dde5bb6cb791c7a540e0a4796f5e97e'\
 | bx address-encode -v 5
39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</screen>
<simpara>Maintenant, Mohammed peut donner cette &quot;adresse&quot; à ses clients et ils peuvent utiliser presque n&#39;importe quel portefeuille bitcoin pour effectuer un paiement simple, comme s&#39;il s&#39;agissait d&#39;une adresse Bitcoin. Le préfixe 3 leur donne un indice qu&#39;il s&#39;agit d&#39;un type d&#39;adresse spécial, celui correspondant à un script au lieu d&#39;une clé publique, mais sinon cela fonctionne exactement de la même manière qu&#39;un paiement à une adresse Bitcoin.</simpara>
<simpara>Les adresses P2SH cachent toute la complexité, de sorte que la personne effectuant un paiement ne voit pas le script.</simpara>
</section>
<section id="_avantages_du_p2sh">
<title>Avantages du P2SH</title>
<simpara><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;Pay-to-Script-Hash&quot;</secondary><tertiary>&quot;benefices de&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Pay-to-Script-Hash&quot;</primary><secondary>&quot;benefices de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;benefices de&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Pay-to-Script-Hash (P2SH)&quot;</primary><secondary>&quot;benefices de&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;benefices de&quot;</primary>
</indexterm>La fonction P2SH offre les avantages suivants par rapport à l&#39;utilisation directe de scripts complexes dans le verrouillage des sorties :</simpara>
<itemizedlist>
<listitem>
<simpara>
Les scripts complexes sont remplacés par des empreintes digitales plus courtes dans la sortie de la transaction, ce qui réduit la taille de la transaction.
</simpara>
</listitem>
<listitem>
<simpara>
Les scripts peuvent être codés comme une adresse, de sorte que l&#39;expéditeur et le portefeuille de l&#39;expéditeur n&#39;ont pas besoin d&#39;ingénierie complexe pour implémenter P2SH.
</simpara>
</listitem>
<listitem>
<simpara>
P2SH transfère le fardeau de la construction du script au destinataire, pas à l&#39;expéditeur.
</simpara>
</listitem>
<listitem>
<simpara>
P2SH déplace la charge de stockage des données pour le script long de la sortie (qui en plus d&#39;être stockée sur la chaîne de blocs est dans l&#39;ensemble UTXO) vers l&#39;entrée (uniquement stockée sur la chaîne de blocs).
</simpara>
</listitem>
<listitem>
<simpara>
P2SH déplace la charge de stockage des données pour le script long du moment présent (paiement) à un moment futur (lorsqu&#39;il est dépensé).
</simpara>
</listitem>
<listitem>
<simpara>
P2SH transfère les frais de transaction plus élevés d&#39;un long script de l&#39;expéditeur au destinataire, qui doit inclure le long script d&#39;échange pour le dépenser.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_utiliser_le_script_et_la_validation">
<title>Utiliser le script et la validation</title>
<simpara><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;Pay-to-Script-Hash&quot;</secondary><tertiary>&quot;scripts de rachat et validation&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;Pay-to-Script-Hash&quot;</primary><secondary>&quot;scripts de rachat et validation&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de rachat et validation&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Pay-to-Script-Hash (P2SH)&quot;</primary><secondary>&quot;scripts de rachat et validation&quot;)) )(((&quot;scripts de rachat&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de rachat et validation&quot;)) )(((&quot;scripts de rachat&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;validation&quot;</primary>
</indexterm>Avant la version 0.9.2 du client Bitcoin Core, Pay-to-Script-Hash était limité aux types standard de scripts de transaction bitcoin, par la fonction <literal>IsStandard()</literal>. Cela signifie que le script d&#39;échange présenté dans la transaction de dépenses ne peut être que l&#39;un des types standard : P2PK, P2PKH ou multisig.</simpara>
<simpara>Depuis la version 0.9.2 du client Bitcoin Core, les transactions P2SH peuvent contenir n&#39;importe quel script valide, ce qui rend la norme P2SH beaucoup plus flexible et permet d&#39;expérimenter de nombreux types de transactions nouveaux et complexes.</simpara>
<simpara>Vous ne pouvez pas mettre un P2SH dans un script de rachat P2SH, car la spécification P2SH n&#39;est pas récursive. Aussi, bien qu&#39;il soit techniquement possible d&#39;inclure <literal>RETURN</literal> (voir <xref linkend="op_return"/>) dans un script de rachat, comme rien dans les règles ne vous empêche de le faire, cela n&#39;a aucune utilité pratique car l&#39;exécution de <literal>RETURN</literal> lors de la validation entraînera le marquage de la transaction comme invalide.</simpara>
<simpara>Notez que, comme le script de rachat n&#39;est pas présenté au réseau tant que vous n&#39;essayez pas de dépenser une sortie P2SH, si vous verrouillez une sortie avec le hachage d&#39;un script de rachat invalide, elle sera traitée malgré tout. L&#39;UTXO sera verrouillé avec succès. Cependant, vous ne pourrez pas le dépenser car la transaction de dépense, qui inclut le script d&#39;échange, ne sera pas acceptée car il s&#39;agit d&#39;un script invalide. Cela crée un risque, car vous pouvez verrouiller des bitcoins dans un P2SH qui ne pourra pas être dépensé plus tard. Le réseau acceptera le script de verrouillage P2SH même s&#39;il correspond à un script de rachat invalide, car le hachage du script ne donne aucune indication sur le script qu&#39;il représente.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Spay07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Spay07&quot;</primary>
</indexterm></simpara>
<warning>
<simpara><indexterm>
  <primary>&quot;avertissements et mises en garde&quot;</primary><secondary>&quot;verrouillage accidentel de bitcoin&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;verrouillage accidentel de bitcoin&quot;</primary>
</indexterm>Les scripts de verrouillage P2SH contiennent le hachage d&#39;un script de rachat, qui ne donne aucun indice quant au contenu du script de rachat lui-même. La transaction P2SH sera considérée comme valide et acceptée même si le script de rachat est invalide. Vous pourriez accidentellement verrouiller le bitcoin de telle sorte qu&#39;il ne puisse plus être dépensé.</simpara>
</warning>
</section>
</section>
<section id="op_return">
<title>Sortie d&#39;enregistrement de données (RETURN)</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>&quot;sortie d&#39;enregistrement de données&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>&quot;sortie d&#39;enregistrement de données&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sortie d&#39;enregistrement de données&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;script&quot;</primary><secondary>&quot;sortie d&#39;enregistrement de données&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;sortie d&#39;enregistrement de données&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Opérateur RETURN&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;enregistrement de données (données de non-paiement)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;données de non-paiement&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;chaîne de blocs (la)&quot;</primary><secondary>&quot;enregistrement de données de non-paiement&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;enregistrement de données de non-paiement&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;services de notaire numérique&quot;</primary>
</indexterm>Les bitcoins sont distribués et Le grand livre horodaté, la chaîne de blocs, a des utilisations potentielles bien au-delà des paiements. De nombreux développeurs ont essayé d&#39;utiliser le langage de script de transaction pour tirer parti de la sécurité et de la résilience du système pour des applications telles que les services de notaire numérique, les certificats d&#39;actions et les contrats intelligents. Les premières tentatives d&#39;utilisation du langage de script de bitcoin à ces fins impliquaient la création de sorties de transaction qui enregistraient des données sur la chaîne de blocs; par exemple, pour enregistrer une empreinte digitale d&#39;un fichier de manière à ce que n&#39;importe qui puisse établir la preuve de l&#39;existence de ce fichier à une date précise par référence à cette transaction.</simpara>
<simpara><indexterm>
  <primary>&quot;gonflement de la chaîne de blocs&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;gonflement&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sorties de transaction non dépensées (UTXO)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;UTXO sets&quot;</primary>
</indexterm>L&#39;utilisation de la chaîne de blocs de Bitcoin pour stocker les données non liées aux paiements en bitcoins sont un sujet controversé. De nombreux développeurs considèrent cette utilisation abusive et veulent la décourager. D&#39;autres y voient une démonstration des puissantes capacités de la technologie chaîne de blocs et souhaitent encourager une telle expérimentation. Ceux qui s&#39;opposent à l&#39;inclusion de données de non-paiement soutiennent que cela provoque un &quot;gonflement de la chaîne de blocs&quot;, ce qui impose à ceux qui exécutent des nœuds Bitcoin complets de supporter le coût du stockage sur disque pour les données que la chaîne de blocs n&#39;était pas destinée à transporter. De plus, de telles transactions créent des UTXO qui ne peuvent pas être dépensés, en utilisant l&#39;adresse Bitcoin de destination comme un champ libre de 20 octets. Parce que l&#39;adresse est utilisée pour les données, elle ne correspond pas à une clé privée et l&#39;UTXO résultant ne peut <emphasis>jamais</emphasis> être dépensé ; c&#39;est un faux paiement. Ces transactions qui ne peuvent jamais être dépensées ne sont donc jamais supprimées de l&#39;ensemble UTXO et entraînent une augmentation permanente de la taille de la base de données UTXO, ou un &quot;gonflement&quot;.</simpara>
<simpara>Dans la version 0.9 du client Bitcoin Core, un compromis a été trouvé avec l&#39;introduction de l&#39;opérateur <literal>RETURN</literal>. <literal>RETURN</literal> permet aux développeurs d&#39;ajouter 80 octets de données de non-paiement à une sortie de transaction. Cependant, contrairement à l&#39;utilisation de &quot;faux&quot; UTXO, l&#39;opérateur <literal>RETURN</literal> crée une sortie explicitement et <emphasis>manifestement indépensable</emphasis>, qui n&#39;a pas besoin d&#39;être stockée dans l&#39;ensemble UTXO. Les sorties <literal>RETURN</literal> sont enregistrées sur la chaîne de blocs, elles consomment donc de l&#39;espace disque et contribuent à l&#39;augmentation de la taille de la chaîne de blocs, mais elles ne sont pas stockées dans l&#39;ensemble UTXO et ne gonflent donc pas le bassin de mémoire UTXO et ne surchargent pas les nœuds complets avec plus de dépenses en RAM.</simpara>
<simpara>Les scripts <literal>RETURN</literal> ressemblent à ceci :</simpara>
<screen>RETURN &lt;data&gt;</screen>
<simpara><indexterm>
  <primary>&quot;Preuve d&#39;existence&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Préfixe DOCPROOF&quot;</primary>
</indexterm>La portion de données est limitée à 80 octets et représente le plus souvent un hachage, comme la sortie de l&#39;algorithme SHA256 (32 octets). De nombreuses applications mettent un préfixe devant les données pour aider à identifier l&#39;application. Par exemple, le service de notarisation numérique <ulink url="https://proofofexistence.com">Preuve d&#39;existence</ulink> utilise le préfixe de 8 octets <literal>DOCPROOF</literal>, qui est encodé en ASCII sous la forme <literal>44 4f 43 50 52 4f 4f 46</literal> en hexadécimal.</simpara>
<simpara>Gardez à l&#39;esprit qu&#39;il n&#39;y a pas de &quot;script de déverrouillage&quot; correspondant à <literal>RETURN</literal> qui pourrait éventuellement être utilisé pour &quot;passer&quot; une sortie <literal>RETURN</literal>. L&#39;intérêt de <literal>RETURN</literal> est que vous ne pouvez pas dépenser l&#39;argent bloqué dans cette sortie, et donc il n&#39;a pas besoin d&#39;être conservé dans l&#39;ensemble UTXO comme potentiellement dépensable - <literal>RETURN</literal> est <emphasis>manifestement indépensable</emphasis>. <literal>RETURN</literal> est généralement une sortie avec un montant de zéro bitcoin, car tout bitcoin attribué à une telle sortie est effectivement perdu à jamais. Si un <literal>RETURN</literal> est référencé comme entrée dans une transaction, le moteur de validation de script arrêtera l&#39;exécution du script de validation et marquera la transaction comme invalide. L&#39;exécution de <literal>RETURN</literal> provoque essentiellement le script &quot;RETURN&quot; avec un <literal>FALSE</literal> et s&#39;arrête. Ainsi, si vous référencez accidentellement une sortie <literal>RETURN</literal> comme entrée dans une transaction, cette transaction n&#39;est pas valide.</simpara>
<simpara>Une transaction standard (c&#39;est-à-dire conforme aux vérifications <literal>IsStandard()</literal>) ne peut avoir qu&#39;une seule sortie <literal>RETURN</literal>. Cependant, une seule sortie <literal>RETURN</literal> peut être combinée dans une transaction avec des sorties de tout autre type.</simpara>
<simpara>Deux nouvelles options de ligne de commande ont été ajoutées dans Bitcoin Core à partir de la version 0.10. L&#39;option <literal>datacarrier</literal> contrôle le relais et l&#39;exploration des transactions <literal>RETURN</literal>, avec la valeur par défaut définie à &quot;1&quot; pour les autoriser. L&#39;option <literal>datacarriersize</literal> prend un argument numérique spécifiant la taille maximale en octets du script <literal>RETURN</literal>, 83 octets par défaut, ce qui permet un maximum de 80 octets de données <literal>RETURN</literal> plus un octet d&#39;opcode <literal>RETURN</literal> et deux octets de <literal>Opcode PUSHDATA</literal>.</simpara>
<note>
<simpara><literal>RETURN</literal> a été initialement proposé avec une limite de 80 octets, mais la limite a été réduite à 40 octets lorsque la fonctionnalité a été publiée. En février 2015, dans la version 0.10 de Bitcoin Core, la limite a été relevée à 80 octets. Les nœuds peuvent choisir de ne pas relayer ou exploiter <literal>RETURN</literal>, ou uniquement de relayer et d&#39;exploiter <literal>RETURN</literal> contenant moins de 80 octets de données.</simpara>
</note>
</section>
<section id="_verrous_horaires">
<title>Verrous horaires</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>&quot;verrous horaires&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>&quot;verrous horaires&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;verrous horaires&quot;</secondary><tertiary>id=&quot;Stimelock07&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>id=&quot;Stimelock07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Stimelock07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;champ nLocktime&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;verrous horaires&quot;</secondary><tertiary>&quot;utilisation pour&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>&quot;utilisation pour&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;utilisation pour&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>&quot;utilisation pour&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;utilisation pour&quot;</primary>
</indexterm>Les verrous horaires (ou timelocks) sont des restrictions sur les transactions ou les sorties qui ne permettent de dépenser qu&#39;après un certain temps. Bitcoin a eu une fonction de verrouillage du temps au niveau de la transaction depuis le début. Il est implémenté par le champ <literal>nLocktime</literal> dans une transaction. Deux nouvelles fonctionnalités de verrou horaire ont été introduites fin 2015 et mi-2016 qui offrent des verrous horaires de niveau UTXO. Ce sont <literal>CHECKLOCKTIMEVERIFY</literal> et <literal>CHECKSEQUENCEVERIFY</literal>.</simpara>
<simpara>Les verrous horaires sont utiles pour postdater les transactions et verrouiller les fonds à une date future. Plus important encore, les verrous horaires étendent les scripts bitcoin dans la dimension du temps, ouvrant la porte à des contrats intelligents complexes en plusieurs étapes.</simpara>
<section id="transaction_locktime_nlocktime">
<title>Temps de verrouillage des transactions (nLocktime)</title>
<simpara><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;verrous horaires&quot;</secondary><tertiary>&quot;nLocktime&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>&quot;nLocktime&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;nLocktime&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>&quot;nLocktime&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;nLocktime&quot;</primary>
</indexterm>Depuis le début, Bitcoin a eu une fonction de timelock au niveau de la transaction. L&#39;heure de verrouillage de la transaction est un paramètre au niveau de la transaction (un champ dans la structure des données de la transaction) qui définit la première heure à laquelle une transaction est valide et peut être relayée sur le réseau ou ajoutée à la chaîne de blocs. Le verrou horaire est également connu sous le nom de <literal>nLocktime</literal> à partir du nom de variable utilisé dans la base de code Bitcoin Core. Il est défini sur zéro dans la plupart des transactions pour indiquer une propagation et une exécution immédiates. Si <literal>nLocktime</literal> est différent de zéro et inférieur à 500 millions, il est interprété comme une hauteur de bloc, ce qui signifie que la transaction n&#39;est pas valide et n&#39;est pas relayée ou incluse dans la blockchain avant la hauteur de bloc spécifiée. S&#39;il est supérieur ou égal à 500 millions, il est interprété comme un horodatage Unix Epoch (secondes depuis le 1er janvier 1970) et la transaction n&#39;est pas valide avant l&#39;heure spécifiée. Les transactions avec <literal>nLocktime</literal> spécifiant un bloc ou une heure future doivent être conservées par le système d&#39;origine et transmises au réseau Bitcoin uniquement après leur validité. Si une transaction est transmise au réseau avant le <literal>nLocktime</literal> spécifié, la transaction sera rejetée par le premier nœud comme invalide et ne sera pas relayée vers les autres nœuds. L&#39;utilisation de <literal>nLocktime</literal> équivaut à postdater un chèque papier.</simpara>
<section id="locktime_limitations">
<title>Limitations du temps de verrouillage des transactions</title>
<simpara><literal>nLocktime</literal> a la limitation que s&#39;il permet de dépenser certaines sorties dans le futur, il ne rend pas impossible de les dépenser jusqu&#39;à ce moment-là. Expliquons cela avec l&#39;exemple suivant.</simpara>
<simpara><indexterm>
  <primary>&quot;cas d&#8217;utilisation&quot;</primary><secondary>&quot;acheter un café&quot;</secondary><tertiary>id=&quot;aliceseven&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;acheter un café&quot;</primary><secondary>id=&quot;aliceseven&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;aliceseven&quot;</primary>
</indexterm>Alice signe une transaction en dépensant l&#39;une de ses sorties à l&#39;adresse de Bob, et fixe la transaction <literal>nLocktime</literal> à 3 mois dans le futur. Alice envoie cette transaction à Bob pour la conserver. Avec cette transaction, Alice et Bob savent que :</simpara>
<itemizedlist>
<listitem>
<simpara>
Bob ne peut pas transmettre la transaction pour racheter les fonds avant que 3 mois ne se soient écoulés.
</simpara>
</listitem>
<listitem>
<simpara>
Bob peut transmettre la transaction après 3 mois.
</simpara>
</listitem>
</itemizedlist>
<simpara>Toutefois:</simpara>
<itemizedlist>
<listitem>
<simpara>
Alice peut créer une autre transaction, en dépensant deux fois les mêmes entrées sans temps de verrouillage. Ainsi, Alice peut passer le même UTXO avant que les 3 mois ne se soient écoulés.
</simpara>
</listitem>
<listitem>
<simpara>
Bob n&#39;a aucune garantie qu&#39;Alice ne le fera pas.
</simpara>
</listitem>
</itemizedlist>
<simpara>Il est important de comprendre les limites de la transaction <literal>nLocktime</literal>. La seule garantie est que Bob ne pourra pas l&#39;échanger avant que 3 mois ne se soient écoulés. Il n&#39;y a aucune garantie que Bob obtiendra les fonds. Pour obtenir une telle garantie, la restriction de verrouillage temporel doit être placée sur l&#39;UTXO lui-même et faire partie du script de verrouillage, plutôt que sur la transaction. Ceci est réalisé par la forme suivante de timelock, appelée Check Lock Time Verify.</simpara>
</section>
</section>
<section id="_vérifier_l_39_heure_de_verrouillage_cltv">
<title>Vérifier l&#39;heure de verrouillage (CLTV)</title>
<simpara><indexterm>
  <primary>&quot;Vérification de l&#39;heure de verrouillage (CLTV)&quot;</primary><secondary>id=&quot;cltv07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;cltv07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;timelocks&quot;</primary><secondary>&quot;Vérification de l&#39;heure de verrouillage (CLTV)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Vérification de l&#39;heure de verrouillage (CLTV)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;timelocks&quot;</secondary><tertiary>&quot;Check Lock Time Verify (CLTV)&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;timelocks&quot;</primary><secondary>&quot;Check Lock Time Verify (CLTV)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Check Lock Time Verify (CLTV)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;propositions d&#39;amélioration du bitcoin&quot;</primary><secondary>&quot;CHECKLOCKTIMEVERIFY (BIP-65)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;CHECKLOCKTIMEVERIFY (BIP-65)&quot;</primary>
</indexterm>En décembre 2015, une nouvelle forme de verrou horaire a été introduite dans le bitcoin en tant qu&#8217;embranchement convergent (soft fork) amélioré. Basé sur une spécification dans BIP-65, le nouvel opérateur de script appelé <emphasis>CHECKLOCKTIMEVERIFY</emphasis> (<emphasis>CLTV</emphasis>) a été ajouté au langage de script. <literal>CLTV</literal> et est un verrou horaire par sortie, plutôt qu&#39;un verrou horaire par transaction comme c&#39;est le cas avec <literal>nLocktime</literal>. Cela permet une plus grande flexibilité dans la manière dont les verrous horaires sont appliqués.</simpara>
<simpara>En termes simples, en ajoutant l&#39;opcode <literal>CLTV</literal> dans le script de rachat d&#39;une sortie, cela restreint la sortie, de sorte qu&#39;elle ne peut être dépensée qu&#39;une fois le temps spécifié écoulé.</simpara>
<tip>
<simpara>Alors que <literal>nLocktime</literal> est un timelock au niveau de la transaction, <literal>CLTV</literal> est un timelock basé sur la sortie.</simpara>
</tip>
<simpara><literal>CLTV</literal> ne remplace pas <literal>nLocktime</literal>, mais restreint plutôt des UTXO spécifiques de sorte qu&#39;ils ne peuvent être dépensés que dans une future transaction avec <literal>nLocktime</literal> défini sur une valeur supérieure ou égale.</simpara>
<simpara>L&#39;opcode <literal>CLTV</literal> prend un paramètre en entrée, exprimé sous la forme d&#39;un nombre au même format que <literal>nLocktime</literal> (soit une hauteur de bloc, soit un temps d&#39;époque Unix). Comme indiqué par le suffixe <literal>VERIFY</literal>, <literal>CLTV</literal> est le type d&#39;opcode qui arrête l&#39;exécution du script si le résultat est <literal>FALSE</literal>. Si le résultat est TRUE, l&#39;exécution continue.</simpara>
<simpara>Pour verrouiller une sortie avec <literal>CLTV</literal>, vous l&#39;insérez dans le script de rachat de la sortie dans la transaction qui crée la sortie. Par exemple, si Alice paie l&#39;adresse de Bob, la sortie contiendra normalement un script P2PKH comme celui-ci :</simpara>
<screen>DUP HASH160 &amp;lt;Hachage clé publique de Bob&amp;gt; EQUALVERIFY CHECKSIG</screen>
<simpara>Pour le verrouiller à un moment, disons dans 3 mois, la transaction serait une transaction P2SH avec un script de rachat comme celui-ci :</simpara>
<screen>&lt;now + 3 months&gt;CHECKLOCKTIMEVERIFY DROP DUP HASH160&lt;Bob's Public Key Hash&gt; EQUALVERIFIER CHECKSIG</screen>
<simpara>où <literal>&lt;now &#43; 3 months&gt; + est une hauteur de bloc ou une valeur temporelle estimée à 3 mois à partir du moment où la transaction est extraite : hauteur de bloc actuelle &#43; 12 960 (blocs) ou heure d&#39;époque Unix actuelle &#43; 7 760 000 (secondes). Pour l&#39;instant, ne vous inquiétez pas de l&#39;opcode +DROP</literal> qui suit <literal>CHECKLOCKTIMEVERIFY</literal> ; cela sera expliqué sous peu.</simpara>
<simpara>Lorsque Bob essaie de dépenser cet UTXO, il construit une transaction qui fait référence à l&#39;UTXO comme entrée. Il utilise sa signature et sa clé publique dans le script de déverrouillage de cette entrée et définit la transaction <literal>nLocktime</literal> pour qu&#39;elle soit égale ou supérieure au verrouillage temporel dans l&#39;ensemble <literal>CHECKLOCKTIMEVERIFY</literal> Alice. Bob diffuse ensuite la transaction sur le réseau Bitcoin.</simpara>
<simpara>La transaction de Bob est évaluée comme suit. Si le paramètre <literal>CHECKLOCKTIMEVERIFY</literal> défini par Alice est inférieur ou égal au <literal>nLocktime</literal> de la transaction dépensière, l&#39;exécution du script continue (agit comme si un opcode &quot;no operation&quot; ou NOP était exécuté). Sinon, l&#39;exécution du script s&#39;arrête et la transaction est considérée comme invalide.</simpara>
<simpara>Plus précisément, <literal>CHECKLOCKTIMEVERIFY</literal> échoue et arrête l&#39;exécution, marquant la transaction invalide si (source : BIP-65) :</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
la pile est vide ; ou
</simpara>
</listitem>
<listitem>
<simpara>
l&#39;élément du haut de la pile est inférieur à 0 ; ou
</simpara>
</listitem>
<listitem>
<simpara>
le type de verrou horaire (hauteur versus horodatage) de l&#39;élément de la pile supérieure et le champ <literal>nLocktime</literal> ne sont pas les mêmes ; ou
</simpara>
</listitem>
<listitem>
<simpara>
l&#39;élément supérieur de la pile est supérieur au champ <literal>nLocktime</literal> de la transaction ; ou
</simpara>
</listitem>
<listitem>
<simpara>
le champ <literal>nSequence</literal> de l&#39;entrée est 0xffffffff.
</simpara>
</listitem>
</orderedlist>
<note>
<simpara><literal>CLTV</literal> et <literal>nLocktime</literal> utilisent le même format pour décrire les verrous horaires, soit une hauteur de bloc, soit le temps écoulé en secondes depuis l&#39;époque Unix. De manière critique, lorsqu&#39;ils sont utilisés ensemble, le format de <literal>nLocktime</literal> doit correspondre à celui de <literal>CLTV</literal> dans les sorties - ils doivent tous deux référencer soit la hauteur de bloc, soit le temps en secondes.</simpara>
</note>
<simpara>Après l&#39;exécution, si <literal>CLTV</literal> est satisfait, le paramètre de temps qui l&#39;a précédé reste l&#39;élément supérieur de la pile et peut devoir être supprimé, avec <literal>DROP</literal>, pour une exécution correcte des opcodes de script suivants. Vous verrez souvent <literal>CHECKLOCKTIMEVERIFY</literal> suivi de <literal>DROP</literal> dans les scripts pour cette raison.</simpara>
<simpara>En utilisant <literal>nLocktime</literal> conjointement avec <literal>CLTV</literal>, le scénario décrit dans <xref linkend="locktime_limitations"/> changements. Alice ne peut plus dépenser l&#39;argent (car il est verrouillé avec la clé de Bob) et Bob ne peut pas le dépenser avant l&#39;expiration du temps de verrouillage de 3 mois.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;alicesseven&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;alicesseven&quot;</primary>
</indexterm></simpara>
<simpara>En introduisant la fonctionnalité timelock directement dans le langage de script, <literal>CLTV</literal> nous permet de développer des scripts complexes très intéressants.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;cltv07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;cltv07&quot;</primary>
</indexterm></simpara>
<simpara>La norme est définie dans <ulink url="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP-65 (CHECKLOCKTIMEVERIFY)</ulink>.</simpara>
</section>
<section id="_verrous_horaires_relatifs">
<title>Verrous horaires relatifs</title>
<simpara><literal>nLocktime</literal> et <literal>CLTV</literal> sont <indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>&quot;verrous horaires relatifs&quot;</secondary><tertiary>id=&quot;Trelative07&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires relatifs&quot;</primary><secondary>id=&quot;Trelative07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Trelative07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;verrous horaires&quot;</secondary><tertiary>&quot;rverrous horaires relatifs&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>&quot;rverrous horaires relatifs&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;rverrous horaires relatifs&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;verrous horaires relatifs&quot;</primary><secondary>id=&quot;relativetime07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;relativetime07&quot;</primary>
</indexterm>les deux <emphasis>verrous horaires absolus</emphasis> en ce sens qu&#39;ils spécifient un point absolu dans le temps. Les deux prochaines fonctionnalités de verrou horaire que nous examinerons sont des <emphasis>verrous horaires relatifs</emphasis> en ce sens qu&#39;elles spécifient, comme condition de dépense d&#39;une sortie, un temps écoulé depuis la confirmation de la sortie dans la chaîne de blocs.</simpara>
<simpara>Les verrous temporels relatifs sont utiles car ils permettent de bloquer une chaîne de deux transactions interdépendantes ou plus, tout en imposant une contrainte de temps sur une transaction qui dépend du temps écoulé depuis la confirmation d&#39;une transaction précédente. En d&#39;autres termes, l&#39;horloge ne commence pas à compter tant que l&#39;UTXO n&#39;est pas enregistré sur la chaîne de blocs. Cette fonctionnalité est particulièrement utile dans les canaux d&#39;état bidirectionnels et les réseaux Lightning, comme nous le verrons dans <xref linkend="state_channels"/>.</simpara>
<simpara>Les verrous horaires relatifs, comme les verrous horaires absolus, sont implémentés à la fois avec une fonctionnalité au niveau de la transaction et un opcode au niveau du script. Le verrouillage temporel relatif au niveau de la transaction est implémenté comme une règle de consensus sur la valeur de <literal>nSequence</literal>, un champ de transaction qui est défini dans chaque entrée de transaction. Les verrous horaires relatifs au niveau du script sont implémentés avec l&#39;opcode <literal>CHECKSEQUENCEVERIFY</literal> (CSV).</simpara>
<simpara><indexterm>
  <primary>&quot;Propositions d&#39;amélioration de bitcoin&quot;</primary><secondary>&quot;Temps de verrouillage relatif utilisant des numéros de séquence imposés par consensus (BIP-68)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;Temps de verrouillage relatif utilisant des numéros de séquence imposés par consensus (BIP-68)&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;Propositions d&#39;amélioration de bitcoin&quot;</primary><secondary>&quot;CHECKSEQUENCEVERIFY (BIP-112)&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;CHECKSEQUENCEVERIFY (BIP-112)&quot;</primary>
</indexterm>Les verrous horaires relatifs sont implémentés conformément aux spécifications de <ulink url="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP-68, Relative lock-time using consensus-enforced sequence numbers</ulink> et https:// github.com/bitcoin/bips/blob/master/bip-0112.mediawiki[BIP-112, CHECKSEQUENCEVERIFY].</simpara>
<simpara>BIP-68 et BIP-112 ont été activés en mai 2016 en tant que mise à niveau soft fork des règles de consensus.</simpara>
</section>
<section id="_verrous_horaires_relatifs_avec_nsequence">
<title>Verrous horaires relatifs avec nSequence</title>
<simpara><indexterm>
  <primary>&quot;champ nSequence&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripting&quot;</primary><secondary>&quot;verrous horaires&quot;</secondary><tertiary>&quot;verrous horaires relatifs avec nSequence&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires&quot;</primary><secondary>&quot;verrous horaires relatifs avec nSequence&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;verrous horaires relatifs avec nSequence&quot;</primary>
</indexterm>Des verrous horaires relatifs peuvent être définis sur chaque entrée d&#39;une transaction, en définissant le champ <literal>nSequence</literal> dans chaque contribution.</simpara>
<section id="_signification_originale_de_nsequence">
<title>Signification originale de nSequence</title>
<simpara>Le champ <literal>nSequence</literal> était à l&#39;origine destiné (mais jamais correctement implémenté) à permettre la modification des transactions dans le mempool. Dans cette utilisation, une transaction contenant des entrées avec une valeur <literal>nSequence</literal> inférieure à 2<superscript>32</superscript> - 1 (0xFFFFFFFF) indiquait une transaction qui n&#39;était pas encore &quot;finalisée&quot;. Une telle transaction serait conservée dans le mempool jusqu&#39;à ce qu&#39;elle soit remplacée par une autre transaction dépensant les mêmes entrées avec une valeur <literal>nSequence</literal> plus élevée. Une fois qu&#39;une transaction a été reçue dont les entrées avaient une valeur <literal>nSequence</literal> de 0xFFFFFFFF, elle serait considérée comme &quot;finalisée&quot; et minée.</simpara>
<simpara>La signification originale de <literal>nSequence</literal> n&#39;a jamais été correctement implémentée et la valeur de <literal>nSequence</literal> est habituellement définie sur 0xFFFFFFFF dans les transactions qui n&#39;utilisent pas de verrous horaires. Pour les transactions avec <literal>nLocktime</literal> ou <literal>CHECKLOCKTIMEVERIFY</literal>, la valeur <literal>nSequence</literal> doit être inférieure à 2<superscript>31</superscript> pour que les gardes de verrou horaire aient un effet, comme expliqué ci-dessous.</simpara>
</section>
<section id="_nsequence_comme_un_verrou_horaire_relatif_imposé_par_consensus">
<title>nSequence comme un verrou horaire relatif imposé par consensus</title>
<simpara>Depuis l&#39;activation de BIP-68, de nouvelles règles de consensus s&#39;appliquent pour toute transaction contenant une entrée dont la valeur <literal>nSequence</literal> est inférieure à 2<superscript>31</superscript> (le bit 1&lt;&lt;31 n&#39;est pas défini). Par programmation, cela signifie que si le bit le plus significatif (bit 1&lt;&lt;31) n&#39;est pas défini, c&#39;est un indicateur qui signifie &quot;temps de verrouillage relatif&quot;. Sinon (bit 1&lt;&lt;31 défini), la valeur <literal>nSequence</literal> est réservée à d&#39;autres utilisations telles que l&#39;activation de <literal>CHECKLOCKTIMEVERIFY</literal>, <literal>nLocktime</literal>, Opt-In-Replace-By-Fee et d&#39;autres développements futurs.</simpara>
<simpara>Les entrées de transaction avec des valeurs <literal>nSequence</literal> inférieures à 2<superscript>31</superscript> sont interprétées comme ayant un verrou horaire relatif. Une telle transaction n&#39;est valide qu&#39;une fois que l&#39;entrée a vieilli du montant relatif du verrou horaire. Par exemple, une transaction avec une entrée et un verrou horaire relatif <literal>nSequence</literal> de 30 blocs n&#39;est valide que lorsqu&#39;au moins 30 blocs se sont écoulés depuis le moment où l&#39;UTXO référencé dans l&#39;entrée a été extrait. Étant donné que <literal>nSequence</literal> est un champ par entrée, une transaction peut contenir n&#39;importe quel nombre d&#39;entrées verrouillées dans le temps, qui doivent toutes avoir suffisamment vieilli pour que la transaction soit valide. Une transaction peut inclure à la fois des entrées à verrouillage temporel (<literal>nSequence</literal> &lt; 2<superscript>31</superscript>) et des entrées sans verrouillage temporel relatif (<literal>nSequence</literal> &gt;= 2<superscript>31</superscript>).</simpara>
<simpara>La valeur <literal>nSequence</literal> est spécifiée en blocs ou en secondes, mais dans un format légèrement différent de celui que nous avons vu utilisé dans <literal>nLocktime</literal>. Un indicateur de type est utilisé pour différencier les valeurs comptant les blocs et les valeurs comptant le temps en secondes. Le drapeau de type est défini dans le 23e bit le moins significatif (c&#39;est-à-dire la valeur 1&lt;&lt;22). Si le type-flag est défini, alors la valeur <literal>nSequence</literal> est interprétée comme un multiple de 512 secondes. Si le drapeau de type n&#39;est pas défini, la valeur <literal>nSequence</literal> est interprétée comme un nombre de blocs.</simpara>
<simpara>Lors de l&#39;interprétation de <literal>nSequence</literal> comme un timelock relatif, seuls les 16 bits les moins significatifs sont pris en compte. Une fois que les drapeaux (bits 32 et 23) sont évalués, la valeur <literal>nSequence</literal> est généralement &quot;masquée&quot; avec un masque de 16 bits (par exemple, <literal>nSequence</literal> &amp; 0x0000FFFF).</simpara>
<simpara><xref linkend="bip_68_def_of_nseq"/> montre la disposition binaire de la valeur <literal>nSequence</literal>, telle que définie par BIP-68.</simpara>
<simpara id="bip_68_def_of_nseq">Définition .BIP-68 du codage nSequence (Source : BIP-68)
<inlinemediaobject>
  <imageobject>
  <imagedata fileref=":images/mbc2_0701.png"/>
  </imageobject>
  <textobject><phrase>&quot;Définition BIP-68 du codage nSequence&quot;</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>Les verrous temporels relatifs basés sur l&#39;application consensuelle de la valeur <literal>nSequence</literal> sont définis dans BIP-68.</simpara>
<simpara>La norme est définie dans <ulink url="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP-68, Relative lock-time using consensus-enforced sequence numbers</ulink>.</simpara>
</section>
</section>
<section id="_verrous_horaires_relatifs_avec_csv">
<title>Verrous horaires relatifs avec CSV</title>
<simpara><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;verrous temporels&quot;</secondary><tertiary>&quot;verrous temporels relatifs avec CHECKSEQUENCEVERIFY&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous temporels&quot;</primary><secondary>&quot;verrous temporels relatifs avec CHECKSEQUENCEVERIFY&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;verrous temporels relatifs avec CHECKSEQUENCEVERIFY&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;CHECKSEQUENCEVERIFY (CSV)&quot;</primary>
</indexterm>Tout comme CLTV et <literal>nLocktime</literal>, il existe un opcode de script pour les verrous temporels relatifs qui exploite le Valeur <literal>nSequence</literal> dans les scripts. Cet opcode est <literal>CHECKSEQUENCEVERIFY</literal>, communément appelé <literal>CSV</literal> en abrégé.</simpara>
<simpara>L&#39;opcode <literal>CSV</literal>, lorsqu&#39;il est évalué dans le script de remboursement d&#39;un UTXO, permet de dépenser uniquement dans une transaction dont la valeur d&#39;entrée <literal>nSequence</literal> est supérieure ou égale au paramètre <literal>CSV</literal>. Essentiellement, cela limite la dépense de l&#39;UTXO jusqu&#39;à ce qu&#39;un certain nombre de blocs ou de secondes se soient écoulés par rapport au moment où l&#39;UTXO a été miné.</simpara>
<simpara>Comme pour CLTV, la valeur dans <literal>CSV</literal> doit correspondre au format de la valeur <literal>nSequence</literal> correspondante. Si <literal>CSV</literal> est spécifié en termes de blocs, il doit en être de même pour <literal>nSequence</literal>. Si <literal>CSV</literal> est spécifié en termes de secondes, alors <literal>nSequence</literal> doit également l&#39;être.</simpara>
<simpara>Les timelocks relatifs avec <literal>CSV</literal> sont particulièrement utiles lorsque plusieurs transactions (chaînées) sont créées et signées, mais non propagées, lorsqu&#39;elles sont conservées &quot;hors chaîne&quot;. Une transaction enfant ne peut pas être utilisée tant que la transaction parent n&#39;a pas été propagée, extraite et vieillie au moment spécifié dans le timelock relatif. Une application de ce cas d&#39;utilisation peut être vue dans <xref linkend="state_channels"/> et <xref linkend="lightning_network"/>.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;relativetime07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;relativetime07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Trelative07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Trelative07&quot;</primary>
</indexterm></simpara>
<simpara><literal>CSV</literal> est défini en détail dans <ulink url="https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki">BIP-112, CHECKSEQUENCEVERIFY</ulink>.</simpara>
</section>
<section id="_temps_médian_passé">
<title>Temps médian passé</title>
<simpara><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;verrous temporels&quot;</secondary><tertiary>&quot;temps-médian-passé&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous temporels&quot;</primary><secondary>&quot;temps-médian-passé&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;temps-médian-passé&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;temps-médian-passé&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;verrous temporels&quot;</primary><secondary>&quot;temps-médian-passé&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;temps-médian-passé&quot;</primary>
</indexterm>Dans le cadre de l&#39;activation des verrous temporels relatifs, il y a également eu un changement dans la façon dont le &quot;temps&quot; est calculé pour les verrous temporels (à la fois absolus et relatifs). Dans le bitcoin, il existe une différence subtile, mais très significative, entre le temps du mur et le temps du consensus. Bitcoin est un réseau décentralisé, ce qui signifie que chaque participant a sa propre vision du temps. Les événements sur le réseau ne se produisent pas instantanément partout. La latence du réseau doit être prise en compte dans la perspective de chaque nœud. Finalement, tout est synchronisé pour créer un grand livre commun. Bitcoin atteint un consensus toutes les 10 minutes sur l&#39;état du grand livre tel qu&#39;il existait dans le passé.</simpara>
<simpara>Les horodatages définis dans les en-têtes de bloc sont définis par les mineurs. Il existe un certain degré de latitude autorisé par les règles de consensus pour tenir compte des différences de précision d&#39;horloge entre les nœuds décentralisés. Cependant, cela crée une incitation malheureuse pour les mineurs à mentir sur le temps passé dans un bloc afin de gagner des frais supplémentaires en incluant des transactions verrouillées dans le temps qui ne sont pas encore matures. Voir la section suivante pour plus d&#39;informations.</simpara>
<simpara>Pour supprimer l&#39;incitation au mensonge et renforcer la sécurité des verrous temporels, un BIP a été proposé et activé en même temps que les BIP des verrous temporels relatifs. Il s&#39;agit de BIP-113, qui définit une nouvelle mesure consensuelle du temps appelée <emphasis>Median-Time-Past</emphasis> (temps-médian-passé).</simpara>
<simpara>Le Median-Time-Past est calculé en prenant les horodatages des 11 derniers blocs et en trouvant la médiane. Ce temps médian devient alors le temps de consensus et est utilisé pour tous les calculs de verrou temporel. En prenant le point médian d&#39;environ deux heures dans le passé, l&#39;influence de l&#39;horodatage de n&#39;importe quel bloc est réduite. En incorporant 11 blocs, aucun mineur ne peut influencer les horodatages afin de gagner des frais sur les transactions avec un verrou temporel qui n&#39;est pas encore arrivé à échéance.</simpara>
<simpara>Median-Time-Past modifie l&#39;implémentation des calculs de temps pour <literal>nLocktime</literal>, <literal>CLTV</literal>, <literal>nSequence</literal> et <literal>CSV</literal>. L&#39;heure de consensus calculée par Median-Time-Past est toujours d&#39;environ une heure en retard sur l&#39;heure de l&#39;horloge murale. Si vous créez des transactions avec verrou temporel, vous devez en tenir compte lors de l&#39;estimation de la valeur souhaitée à encoder dans <literal>nLocktime</literal>, <literal>nSequence</literal>, <literal>CLTV</literal> et <literal>CSV</literal>.</simpara>
<simpara>Median-Time-Past est spécifié dans <ulink url="https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki">BIP-113</ulink>.</simpara>
</section>
<section id="fee_sniping">
<title>Défense contre le "sniping" avec un verrou temporel</title>
<simpara><indexterm>
  <primary>&quot;scripts&quot;</primary><secondary>&quot;verrous temporels&quot;</secondary><tertiary>&quot;défense contre le sniping&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;verrous temporels&quot;</primary><secondary>&quot;défense contre le sniping&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défense contre le sniping&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;verrous temporels&quot;</primary><secondary>&quot;défense contre le sniping&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défense contre le sniping&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;frais&quot;</primary><secondary>&quot;sniping&quot;) ))(((&quot;sécurité&quot;</secondary><tertiary>&quot;défense contre le sniping&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;sniping&quot;) ))(((&quot;sécurité&quot;</primary><secondary>&quot;défense contre le sniping&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;défense contre le sniping&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;sniping&quot;</primary>
</indexterm>Le "sniping" ou le "ciblage" est un scénario d&#39;attaque théorique, où les mineurs tentant de réécrire des blocs passés &quot;snipe&quot; ou "en ciblant" des frais plus élevés transactions des futurs blocs pour maximiser leur rentabilité.</simpara>
<simpara>Par exemple, disons que le bloc le plus élevé existant est le bloc #100 000. Si au lieu d&#39;essayer d&#39;exploiter le bloc #100 001 pour étendre la chaîne, certains mineurs tentent de réexploiter #100 000. Ces mineurs peuvent choisir d&#39;inclure toute transaction valide (qui n&#39;a pas encore été exploitée) dans leur bloc candidat #100 000. Ils n&#39;ont pas à reminer le bloc avec les mêmes transactions. En fait, ils sont incités à sélectionner les transactions les plus rentables (frais les plus élevés par Ko) à inclure dans leur bloc. Ils peuvent inclure toutes les transactions qui se trouvaient dans &quot;l&#39;ancien&quot; bloc #100 000, ainsi que toutes les transactions du mempool actuel. Essentiellement, ils ont la possibilité d&#39;extraire des transactions du &quot;présent&quot; vers le &quot;passé&quot; réécrit lorsqu&#39;ils recréent le bloc #100 000.</simpara>
<simpara>Aujourd&#39;hui, cette attaque n&#39;est pas très lucrative, car la récompense de bloc est bien supérieure au total des frais par bloc. Mais à un moment donné dans le futur, les frais de transaction représenteront la majorité de la récompense minière (ou même l&#39;intégralité de la récompense minière). A ce moment-là, ce scénario devient inévitable.</simpara>
<simpara>Pour éviter le &quot;ciblage de frais&quot;, lorsque Bitcoin Core crée des transactions, il utilise <literal>nLocktime</literal> pour les limiter au &quot;bloc suivant&quot;, par défaut. Dans notre scénario, Bitcoin Core définirait <literal>nLocktime</literal> sur 100 001 sur toute transaction créée. Dans des circonstances normales, ce <literal>nLocktime</literal> n&#39;a aucun effet - les transactions ne peuvent être incluses que dans le bloc #100 001 de toute façon ; c&#39;est le bloc suivant.</simpara>
<simpara>Mais dans le cadre d&#39;une attaque enfourchement de la chaîne de blocs/double dépense, les mineurs ne seraient pas en mesure d&#39;extraire des transactions à frais élevés du mempool, car toutes ces transactions seraient bloquées dans le temps pour bloquer #100 001. Ils ne peuvent reminer que #100 000 avec les transactions valides à ce moment-là, ne gagnant essentiellement aucun nouveau frais.</simpara>
<simpara>Pour ce faire, Bitcoin Core définit le <literal>nLocktime</literal> sur toutes les nouvelles transactions à &lt;current block # + 1&gt; et définit la <literal>nSequence</literal> sur toutes les entrées à 0xFFFFFFFE pour activer <literal>nLocktime</literal>.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Stimelock07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Stimelock07&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="_scripts_avec_contrôle_de_flux_clauses_conditionnelles">
<title>Scripts avec contrôle de flux (clauses conditionnelles)</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>&quot;scripts de contrôle de flux&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>&quot;scripts de contrôle de flux&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de contrôle de flux&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripts&quot;</primary><secondary>&quot;scripts de contrôle de flux&quot;</secondary><tertiary>id=&quot;Sflow07&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;scripts de contrôle de flux&quot;</primary><secondary>id=&quot;Sflow07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Sflow07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clauses conditionnelles&quot;</primary><secondary>id= &quot;condition07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id= &quot;condition07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;contrôle de flux&quot;</primary><secondary>id=&quot;flow07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;flow07&quot;</primary>
</indexterm>L&#39;une des fonctionnalités les plus puissantes de Bitcoin Script est le contrôle de flux, également connu sous le nom de clauses conditionnelles. Vous êtes probablement familiarisé avec le contrôle de flux dans divers langages de programmation qui utilisent la construction <literal>IF&#8230;THEN&#8230;ELSE</literal>. Les clauses conditionnelles Bitcoin semblent un peu différentes, mais sont essentiellement la même construction.</simpara>
<simpara>À un niveau de base, les opcodes conditionnels bitcoin nous permettent de construire un script de rachat qui a deux façons d&#39;être déverrouillé, en fonction d&#39;un résultat <literal>TRUE</literal>/<literal>FALSE</literal> d&#39;évaluation d&#39;une condition logique. Par exemple, si x est <literal>TRUE</literal>, le script de rachat est A et le script de rachat ELSE est B.</simpara>
<simpara>De plus, les expressions conditionnelles Bitcoin peuvent être &quot;imbriquées&quot; indéfiniment, ce qui signifie qu&#39;une clause conditionnelle peut en contenir une autre, qui en contient une autre, etc. Le contrôle de flux Bitcoin Script peut être utilisé pour construire des scripts très complexes avec des centaines voire des milliers de chemins d&#39;exécution possibles. . Il n&#39;y a pas de limite à l&#39;imbrication, mais les règles de consensus imposent une limite à la taille maximale, en octets, d&#39;un script.</simpara>
<simpara>Bitcoin implémente le contrôle de flux à l&#39;aide des opcodes <literal>IF</literal>, <literal>ELSE</literal>, <literal>ENDIF</literal> et <literal>NOTIF</literal>. De plus, les expressions conditionnelles peuvent contenir des opérateurs booléens tels que <literal>BOOLAND</literal>, <literal>BOOLOR</literal> et <literal>NOT</literal>.</simpara>
<simpara>À première vue, vous pouvez trouver les scripts de contrôle de flux du bitcoin déroutants. En effet, Bitcoin Script est un langage de pile. De la même manière que <literal>1 &#43; 1</literal> semble &quot;renversé&quot; lorsqu&#39;il est exprimé comme <literal>1 1 ADD</literal>, les clauses de contrôle de flux dans bitcoin semblent également &quot;renversés&quot;.</simpara>
<simpara>Dans la plupart des langages de programmation traditionnels (procéduraux), le contrôle de flux ressemble à ceci :</simpara>
<formalpara><title>Pseudocode de contrôle de flux dans la plupart des langages de programmation</title><para>
<screen>si (condition):
  code à exécuter lorsque la condition est vraie
autre:
  code à exécuter lorsque la condition est fausse
code à exécuter dans les deux cas</screen>
</para></formalpara>
<simpara>Dans un langage basé sur la pile comme Bitcoin Script, la condition logique vient avant le <literal>IF</literal>, ce qui le fait apparaître &quot;en arrière&quot;, comme ceci :</simpara>
<formalpara><title>Contrôle de flux Bitcoin Script</title><para>
<screen>condition
IF
  code à exécuter lorsque la condition est vraie
ELSE
  code à exécuter lorsque la condition est fausse
ENDIF
code à exécuter dans les deux cas</screen>
</para></formalpara>
<simpara>Lors de la lecture du script Bitcoin, rappelez-vous que la condition évaluée vient <emphasis>avant</emphasis> l&#39;opcode <literal>IF</literal>.</simpara>
<section id="_clauses_conditionnelles_avec_les_opcodes_verify">
<title>Clauses conditionnelles avec les opcodes VERIFY</title>
<simpara><indexterm>
  <primary>&quot;opcodes VERIFY&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;clauses IF&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;opcodes&quot;</primary><secondary>&quot;VERIFY&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;VERIFY&quot;</primary>
</indexterm>Une autre forme de conditionnel dans Bitcoin Script est tout opcode qui se termine par <literal>VERIFY</literal>. Le suffixe <literal>VERIFY</literal> signifie que si la condition évaluée n&#39;est pas <literal>TRUE</literal>, l&#39;exécution du script se termine immédiatement et la transaction est considérée comme invalide.</simpara>
<simpara><indexterm>
  <primary>&quot;clauses de garde&quot;</primary>
</indexterm>Contrairement à une clause <literal>IF</literal>, qui offre des chemins d&#39;exécution alternatifs, le suffixe <literal>VERIFY</literal> agit comme une <emphasis>clause de garde</emphasis>, ne continuant que si une condition préalable est remplie.</simpara>
<simpara>Par exemple, le script suivant nécessite la signature de Bob et une pré-image (secret) qui produit un hachage spécifique. Les deux conditions doivent être remplies pour le déverrouiller :</simpara>
<formalpara><title>Un script de rachat avec une clause de garde <literal>EQUALVERIFY</literal>.</title><para>
<screen>HASH160 &lt;expected hash&gt; EQUALVERIFY &lt;Bob's Pubkey&gt; CHECKSIG</screen>
</para></formalpara>
<simpara>Pour racheter cela, Bob doit construire un script de déverrouillage qui présente une pré-image valide et une signature :</simpara>
<formalpara><title>Un script de déverrouillage pour satisfaire le script de rachat ci-dessus</title><para>
<screen>&lt;Bob's Sig&gt; &lt;hash pre-image&gt;</screen>
</para></formalpara>
<simpara>Sans présenter la pré-image, Bob ne peut pas accéder à la partie du script qui vérifie sa signature.</simpara>
<simpara role="pagebreak-after">Ce script peut être écrit avec un <literal>IF</literal> à la place :</simpara>
<formalpara><title>Un script de rachat avec une clause de garde <literal>IF</literal></title><para>
<screen>HASH160 &lt;expected hash&gt; EQUAL
IF
   &lt;Bob's Pubkey&gt; CHECKSIG
ENDIF</screen>
</para></formalpara>
<simpara>Le script de déverrouillage de Bob est identique :</simpara>
<formalpara><title>Un script de déverrouillage pour satisfaire le script de rachat ci-dessus</title><para>
<screen>&lt;Bob's Sig&gt; &lt;hash pre-image&gt;</screen>
</para></formalpara>
<simpara>Le script avec <literal>IF</literal> fait la même chose que d&#39;utiliser un opcode avec un suffixe <literal>VERIFY</literal> ; elles fonctionnent toutes deux comme des clauses de garde. Cependant, la construction <literal>VERIFY</literal> est plus efficace, utilisant deux opcodes de moins.</simpara>
<simpara>Alors, quand utilisons-nous <literal>VERIFY</literal> et quand utilisons-nous <literal>IF</literal> ? Si tout ce que nous essayons de faire est d&#39;attacher une condition préalable (clause de garde), alors <literal>VERIFY</literal> est préférable. Si, toutefois, nous voulons avoir plus d&#39;un chemin d&#39;exécution (contrôle de flux), nous avons besoin d&#39;une clause de contrôle de flux <literal>IF&#8230;ELSE</literal>.</simpara>
<tip>
<simpara><indexterm>
  <primary>&quot;OPCODE EQUAL&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;opcodes&quot;</primary><secondary>&quot;EQUAL&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;EQUAL&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;OPCODE EQUALVERIFY&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;opcodes&quot;</primary><secondary>&quot;EQUALVERIFY&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;EQUALVERIFY&quot;</primary>
</indexterm>Un opcode tel que <literal>EQUAL</literal> poussera le résultat (<literal>TRUE</literal>/<literal>FALSE</literal>) sur la pile, le laissant là pour évaluation par les opcodes suivants. En revanche, le suffixe de l&#39;opcode <literal>EQUALVERIFY</literal> ne laisse rien sur la pile. Les opcodes qui se terminent par <literal>VERIFY</literal> ne laissent pas le résultat sur la pile.</simpara>
</tip>
</section>
<section id="_utilisation_du_contrôle_de_flux_dans_les_scripts">
<title>Utilisation du contrôle de flux dans les scripts</title>
<simpara>Une utilisation très courante du contrôle de flux dans Bitcoin Script consiste à construire un script de rachat qui offre plusieurs chemins d&#39;exécution, chacun une manière différente de racheter l&#39;UTXO.</simpara>
<simpara><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;acheter du café&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;acheter du café&quot;</primary>
</indexterm>Regardons un exemple simple, où nous avons deux signataires, Alice et Bob, et l&#39;un ou l&#39;autre est en mesure de racheter. Avec multisig, cela serait exprimé sous la forme d&#39;un script multisig 1 sur 2. Pour des raisons de démonstration, nous ferons la même chose avec une clause <literal>IF</literal> :</simpara>
<screen>IF
 &lt;Alice's Pubkey&gt; CHECKSIG
ELSE
 &lt;Bob's Pubkey&gt; CHECKSIG
ENDIF</screen>
<simpara>En regardant ce script de rachat, vous vous demandez peut-être : &quot;Où est la condition ? Il n&#39;y a rien qui précède la clause <literal>IF</literal> !&quot;</simpara>
<simpara>La condition ne fait pas partie du script de rachat. Au lieu de cela, la condition sera proposée dans le script de déverrouillage, permettant à Alice et Bob de &quot;choisir&quot; le chemin d&#39;exécution qu&#39;ils souhaitent.</simpara>
<simpara>Alice rachète cela avec le script de déverrouillage :</simpara>
<screen>&lt;Alice's Sig&gt; 1</screen>
<simpara>Le <literal>1</literal> à la fin sert de condition (<literal>TRUE</literal>) qui fera que la clause <literal>IF</literal> exécutera le premier chemin de rachat pour lequel Alice a une signature.</simpara>
<simpara>Pour que Bob puisse racheter cela, il devrait choisir le deuxième chemin d&#39;exécution en donnant une valeur <literal>FALSE</literal> à la clause <literal>IF</literal> :</simpara>
<screen>&lt;Bob's Sig&gt; 0</screen>
<simpara>Le script de déverrouillage de Bob place un <literal>0</literal> sur la pile, ce qui oblige la clause <literal>IF</literal> à exécuter le deuxième script (<literal>ELSE</literal>), qui nécessite la signature de Bob.</simpara>
<simpara>Puisque les clauses <literal>IF</literal> peuvent être imbriquées, nous pouvons créer un &quot;labyrinthe&quot; de chemins d&#39;exécution. Le script de déverrouillage peut fournir une &quot;carte&quot; sélectionnant le chemin d&#39;exécution réellement exécuté :</simpara>
<screen>IF
  script A
ELSE
  IF
    script B
  ELSE
    script C
  ENDIF
ENDIF</screen>
<simpara>Dans ce scénario, il existe trois chemins d&#39;exécution (<literal>script A</literal>, <literal>script B</literal> et <literal>script C</literal>). Le script de déverrouillage fournit un chemin sous la forme d&#39;une séquence de valeurs <literal>TRUE</literal> ou <literal>FALSE</literal>. Pour sélectionner le chemin <literal>script B</literal>, par exemple, le script de déverrouillage doit se terminer par <literal>1 0</literal> (<literal>TRUE</literal>, <literal>FALSE</literal>). Ces valeurs seront poussées sur la pile, de sorte que la deuxième valeur (<literal>FALSE</literal>) se retrouve en haut de la pile. La clause <literal>IF</literal> externe extrait la valeur <literal>FALSE</literal> et exécute la première clause <literal>ELSE</literal>. Ensuite, la valeur <literal>TRUE</literal> se déplace vers le haut de la pile et est évaluée par le <literal>IF</literal> interne (imbriqué), en sélectionnant le chemin d&#39;exécution <literal>B</literal>.</simpara>
<simpara>En utilisant cette construction, nous pouvons créer des scripts de rachat avec des dizaines ou des centaines de chemins d&#39;exécution, chacun offrant une manière différente de racheter l&#39;UTXO. Pour dépenser, nous construisons un script de déverrouillage qui navigue dans le chemin d&#39;exécution en plaçant les valeurs <literal>TRUE</literal> et <literal>FALSE</literal> appropriées sur la pile à chaque point de contrôle de flux.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Sflow07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Sflow07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot; &quot;</primary><secondary>startref=&quot;flux07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;flux07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;condition07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;condition07&quot;</primary>
</indexterm></simpara>
</section>
</section>
<section id="_exemple_de_script_complexe">
<title>Exemple de script complexe</title>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>&quot;exemple&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>&quot;exemple&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exemple&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scriptage&quot;</primary><secondary>&quot;exemple de script complexe&quot;</secondary><tertiary>id=&quot;Scomplex07&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;exemple de script complexe&quot;</primary><secondary>id=&quot;Scomplex07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Scomplex07&quot;</primary>
</indexterm>Dans cette section, nous combinons de nombreux concepts de ce chapitre en un seul exemple.</simpara>
<simpara><indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;import/export&quot;</secondary><tertiary>id=&quot;mohamseventwo&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;import/export&quot;</primary><secondary>id=&quot;mohamseventwo&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;mohamseventwo&quot;</primary>
</indexterm>Notre exemple utilise l&#39;histoire de Mohammed, le propriétaire d&#39;une entreprise à Dubaï qui exploite une entreprise d&#39;import/export.</simpara>
<simpara><indexterm>
  <primary>&quot;transactions&quot;</primary><secondary>&quot;avancé&quot;</secondary><tertiary>&quot;scripts multisignatures&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;avancé&quot;</primary><secondary>&quot;scripts multisignatures&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;scripts multisignatures&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripts&quot;</primary><secondary>&quot;scripts multisignatures&quot;</secondary><tertiary>&quot;exemple d&#39;import/export&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;scripts multisignatures&quot;</primary><secondary>&quot;exemple d&#39;import/export&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;exemple d&#39;import/export&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;scripts multisignatures&quot;</primary>
</indexterm>Dans cet exemple, Mohammed souhaite construire un compte de capital d&#39;entreprise avec des règles flexibles. Le schéma qu&#39;il crée nécessite différents niveaux d&#39;autorisation en fonction des verrous temporels. Les participants au programme multisig sont Mohammed, ses deux partenaires Saeed et Zaira, et leur avocat Abdul. Les trois partenaires prennent des décisions basées sur une règle de majorité, donc deux des trois doivent être d&#39;accord. Cependant, en cas de problème avec leurs clés, ils souhaitent que leur avocat puisse récupérer les fonds avec l&#39;une des trois signatures d&#39;associés. Enfin, si tous les associés sont indisponibles ou inaptes pendant un certain temps, ils souhaitent que l&#39;avocat puisse gérer directement le compte.</simpara>
<simpara>Voici le script de rachat que Mohammed conçoit pour y parvenir (préfixe de numéro de ligne en tant que XX) :</simpara>
<formalpara><title>Variable Multi-Signature avec verrou temporel</title><para>
<screen>01  IF
02    IF
03      2
04    ELSE
05      &lt;30 days&gt; CHECKSEQUENCEVERIFY DROP
06      &lt;Abdul the Lawyer's Pubkey&gt; CHECKSIGVERIFY
07      1
08    ENDIF
09    &lt;Mohammed's Pubkey&gt; &lt;Saeed's Pubkey&gt; &lt;Zaira's Pubkey&gt; 3 CHECKMULTISIG
10  ELSE
11    &lt;90 days&gt; CHECKSEQUENCEVERIFY DROP
12    &lt;Abdul the Lawyer's Pubkey&gt; CHECKSIG
13  ENDIF</screen>
</para></formalpara>
<simpara>Le script de Mohammed implémente trois chemins d&#39;exécution à l&#39;aide de clauses de contrôle de flux imbriquées <literal>IF&#8230;ELSE</literal>.</simpara>
<simpara>Dans le premier chemin d&#39;exécution, ce script fonctionne comme un simple multisig 2 sur 3 avec les trois partenaires. Ce chemin d&#39;exécution se compose des lignes 3 et 9. La ligne 3 définit le quorum du multisig à <literal>2</literal> (2-de-3). Ce chemin d&#39;exécution peut être sélectionné en mettant <literal>TRUE TRUE</literal> à la fin du script de déverrouillage :</simpara>
<formalpara><title>Script de déverrouillage pour le premier chemin d&#39;exécution (2-de-3 multisig)</title><para>
<screen>0 &lt;Mohammed's Sig&gt; &lt;Zaira's Sig&gt; TRUE TRUE</screen>
</para></formalpara>
<tip>
<simpara>Le <literal>0</literal> au début de ce script de déverrouillage est dû à un bogue dans <literal>CHECKMULTISIG</literal> qui extrait une valeur supplémentaire de la pile. La valeur supplémentaire est ignorée par le <literal>CHECKMULTISIG</literal>, mais elle doit être présente ou le script échoue. Pousser <literal>0</literal> (habituellement) est une solution de contournement au bogue, comme décrit dans <xref linkend="multisig_bug"/>.</simpara>
</tip>
<simpara>Le deuxième chemin d&#39;exécution ne peut être utilisé qu&#39;après 30 jours à compter de la création de l&#39;UTXO. À ce moment-là, il faut la signature d&#39;Abdul l&#39;avocat et de l&#39;un des trois partenaires (un multisig 1 sur 3). Ceci est réalisé par la ligne 7, qui fixe le quorum pour le multisig à <literal>1</literal>. Pour sélectionner ce chemin d&#39;exécution, le script de déverrouillage se terminerait par <literal>FALSE TRUE</literal> :</simpara>
<formalpara><title>Script de déverrouillage pour le deuxième chemin d&#39;exécution (Avocat + 1 sur 3)</title><para>
<screen>0 &lt;Abdul the Lawyer's Sig&gt; &lt;Saeed's Sig&gt; FALSE TRUE</screen>
</para></formalpara>
<tip>
<simpara>Pourquoi <literal>FAUX VRAI</literal> ? N&#39;est-ce pas à l&#39;envers ? Parce que les deux valeurs sont poussées sur la pile, avec <literal>FALSE</literal> poussé en premier, puis <literal>TRUE</literal> poussé en second. <literal>TRUE</literal> est donc dépilé <emphasis>premier</emphasis> par le premier opcode <literal>IF</literal>.</simpara>
</tip>
<simpara>Enfin, la troisième voie d&#39;exécution permet à Abdul l&#39;avocat de dépenser les fonds seul, mais seulement après 90 jours. Pour sélectionner ce chemin d&#39;exécution, le script de déverrouillage doit se terminer par <literal>FALSE</literal> :</simpara>
<formalpara><title>Script de déverrouillage pour le troisième chemin d&#39;exécution (avocat uniquement)</title><para>
<screen>&lt;Abdul the Lawyer's Sig&gt; FALSE</screen>
</para></formalpara>
<simpara>Essayez d&#39;exécuter le script sur papier pour voir comment il se comporte sur la pile.</simpara>
<simpara>Quelques éléments supplémentaires à prendre en compte lors de la lecture de cet exemple. Voyez si vous pouvez trouver les réponses :</simpara>
<itemizedlist>
<listitem>
<simpara>
Pourquoi l&#39;avocat ne peut-il pas racheter le troisième chemin d&#39;exécution à tout moment en le sélectionnant avec <literal>FALSE</literal> sur le script de déverrouillage ?
</simpara>
</listitem>
<listitem>
<simpara>
Combien de chemins d&#39;exécution peuvent être utilisés 5, 35 et 105 jours, respectivement, après le minage de l&#39;UTXO ?
</simpara>
</listitem>
<listitem>
<simpara>
Les fonds sont-ils perdus si l&#39;avocat perd sa clé ? Votre réponse change-t-elle si 91 jours se sont écoulés ?
</simpara>
</listitem>
<listitem>
<simpara>
Comment les associés « remettent-ils à zéro » l&#39;horloge tous les 29 ou 89 jours pour empêcher l&#39;avocat d&#39;accéder aux fonds ?
</simpara>
</listitem>
<listitem>
<simpara>
Pourquoi certains opcodes <literal>CHECKSIG</literal> dans ce script ont-ils le suffixe <literal>VERIFY</literal> alors que d&#39;autres non ?<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Scomplex07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Scomplex07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;mohamseventwo&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;mohamseventwo&quot;</primary>
</indexterm>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="segwit">
<title>Témoin séparé</title>
<simpara><indexterm>
  <primary>&quot;segwit (Témoin Séparé)&quot;</primary><secondary>id=&quot;Ssegwit07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;Ssegwit07&quot;</primary>
</indexterm>Le Segregated Witness (segwit) ou le "témoin séparé" est une mise à niveau des règles de consensus bitcoin et du protocole réseau, proposée et mise en œuvre en tant que embranchement convergent BIP-9 qui a été activé sur le réseau principal de bitcoin le 1er août 2017.</simpara>
<simpara>En cryptographie, le terme « témoin » est utilisé pour décrire une solution à un puzzle cryptographique. En termes de bitcoin, le témoin satisfait une condition cryptographique placée sur une sortie de transaction non dépensée (UTXO).</simpara>
<simpara>Dans le contexte du bitcoin, une signature numérique est <emphasis>un type de témoin</emphasis>, mais un témoin est plus largement toute solution qui peut satisfaire les conditions imposées à un UTXO et débloquer cet UTXO pour les dépenses. Le terme &quot;témoin&quot; est un terme plus général pour un &quot;script de déverrouillage&quot; ou &quot;scriptSig&quot;.</simpara>
<simpara>Avant l&#39;introduction de segwit, chaque entrée d&#39;une transaction était suivie des données témoins qui la déverrouillaient. Les données témoins ont été intégrées à la transaction dans le cadre de chaque entrée. Le terme <emphasis>témoin séparé</emphasis>, ou <emphasis>segwit</emphasis> en abrégé, signifie simplement séparer la signature ou le script de déverrouillage d&#39;une sortie spécifique. Pensez &quot;scriptSig séparé&quot; ou &quot;signature séparée&quot; dans sa forme la plus simple.</simpara>
<simpara>Le témoin séparé (Segregated Witness) est donc une modification architecturale du bitcoin qui vise à déplacer les données témoins du champ <literal>scriptSig</literal> (script de déverrouillage) d&#39;une transaction vers une structure de données <emphasis>témoin</emphasis> distincte qui accompagne une transaction. Les clients peuvent demander des données de transaction avec ou sans les données de témoin qui les accompagnent.</simpara>
<simpara>Dans cette section, nous examinerons certains des avantages du témoin séparé, décrirons le mécanisme utilisé pour déployer et mettre en œuvre ce changement d&#39;architecture et démontrerons l&#39;utilisation du témoin séparé dans les transactions et les adresses.</simpara>
<simpara>Le témoin séparé est défini par les BIP suivants :</simpara>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-141</ulink> 
</term>
<listitem>
<simpara>
La principale définition du témoin séparé.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP-143</ulink> 
</term>
<listitem>
<simpara>
Vérification de la signature des transactions pour le programme témoin de la version 0
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-144</ulink> 
</term>
<listitem>
<simpara>
Services à pair; Nouveaux messages réseau et formats de sérialisation
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki">BIP-145</ulink> 
</term>
<listitem>
<simpara>
Mises à jour de getblocktemplate pour le témoin séparé Segregated Witness (pour minage)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-173</ulink> 
</term>
<listitem>
<simpara>
Format d&#39;adresse Base32 pour les sorties témoins natives v0-16
</simpara>
</listitem>
</varlistentry>
</variablelist>
<section id="_pourquoi_un_témoin_séparé">
<title>Pourquoi un témoin séparé ?</title>
<simpara>Le témoin séparé est un changement architectural qui a plusieurs effets sur l&#39;évolutivité, la sécurité, les incitations économiques et les performances du bitcoin :</simpara>
<variablelist>
<varlistentry>
<term>
Malléabilité de transaction 
</term>
<listitem>
<simpara>
En déplaçant le témoin en dehors des données de transaction, le hachage de transaction utilisé comme identifiant n&#39;inclut plus les données de témoin. Étant donné que les données témoins sont la seule partie de la transaction qui peut être modifiée par un tiers (voir <xref linkend="segwit_txid"/>), sa suppression supprime également la possibilité d&#39;attaques de malléabilité des transactions. Avec le témoin séparé, les hachages de transaction deviennent immuables par toute personne autre que le créateur de la transaction, ce qui améliore considérablement la mise en œuvre de nombreux autres protocoles qui reposent sur la construction avancée de transactions bitcoin, tels que les canaux de paiement, les transactions chaînées et les réseaux Lightning.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Gestion des versions de script 
</term>
<listitem>
<simpara>
Avec l&#39;introduction des scripts Segregated Witness (témoin séparé), chaque script de verrouillage est précédé d&#39;un numéro de <emphasis>version de script</emphasis>, similaire à la façon dont les transactions et les blocs ont des numéros de version. L&#39;ajout d&#39;un numéro de version de script permet au langage de script d&#39;être mis à niveau de manière rétrocompatible (c&#39;est-à-dire en utilisant des mises à niveau d&#8217;embranchement convergent) pour introduire de nouvelles opérandes de script, syntaxe ou sémantique. La possibilité de mettre à niveau le langage de script de manière non perturbatrice accélérera considérablement le taux d&#39;innovation dans le bitcoin.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Mise à l&#39;échelle du réseau et du stockage 
</term>
<listitem>
<simpara>
Les données témoins contribuent souvent de manière importante à la taille totale d&#39;une transaction. Les scripts plus complexes tels que ceux utilisés pour les canaux multisig ou de paiement sont très volumineux. Dans certains cas, ces scripts représentent la majorité (plus de 75 %) des données d&#39;une transaction. En déplaçant les données témoins en dehors des données de transaction, le témoin séparé améliore l&#39;évolutivité de Bitcoin. Les nœuds peuvent élaguer les données témoins après avoir validé les signatures, ou les ignorer complètement lors de la vérification simplifiée des paiements. Les données témoins n&#39;ont pas besoin d&#39;être transmises à tous les nœuds et n&#39;ont pas besoin d&#39;être stockées sur disque par tous les nœuds.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Optimisation de la vérification de signature 
</term>
<listitem>
<simpara>
Le témoin séparé met à niveau les fonctions de signature (<literal>CHECKSIG</literal>, <literal>CHECKMULTISIG</literal>, etc.) pour réduire la complexité de calcul de l&#39;algorithme. Avant segwit, l&#39;algorithme utilisé pour produire une signature nécessitait un nombre d&#39;opérations de hachage proportionnel à la taille de la transaction. Les calculs de hachage de données ont augmenté en O(n<superscript>2</superscript>) par rapport au nombre d&#39;opérations de signature, introduisant une charge de calcul substantielle sur tous les nœuds vérifiant la signature. Avec segwit, l&#39;algorithme est modifié pour réduire la complexité à O(n).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Amélioration de la signature hors ligne 
</term>
<listitem>
<simpara>
Les signatures des témoins séparés incorporent la valeur (montant) référencée par chaque entrée dans le hachage qui est signé. Auparavant, un dispositif de signature hors ligne, tel qu&#39;un portefeuille matériel, devait vérifier le montant de chaque entrée avant de signer une transaction. Cela était généralement accompli en diffusant une grande quantité de données sur les transactions précédentes référencées en tant qu&#39;entrées. Étant donné que le montant fait désormais partie du hachage d&#39;engagement qui est signé, un appareil hors ligne n&#39;a pas besoin des transactions précédentes. Si les montants ne correspondent pas (sont mal représentés par un système en ligne compromis), la signature sera invalide.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_comment_fonctionne_le_témoignage_séparé">
<title>Comment fonctionne le témoignage séparé</title>
<simpara>À première vue, le témoignage séparé semble être un changement dans la façon dont les transactions sont construites et donc une fonctionnalité au niveau de la transaction, mais ce n&#39;est pas le cas. Au lieu de cela, le témoin séparé est un changement dans la façon dont les UTXO individuels sont dépensés et est donc une fonctionnalité par sortie.</simpara>
<simpara>Une transaction peut dépenser des sorties de témoin séparé ou des sorties traditionnelles (témoin en ligne) ou les deux. Par conséquent, cela n&#39;a pas beaucoup de sens de se référer à une transaction comme une &quot;transaction de témoin séparé&quot;. Nous devrions plutôt faire référence à des sorties de transaction spécifiques en tant que &quot;sorties de témoins séparés&quot;.</simpara>
<simpara>Lorsqu&#39;une transaction passe un UTXO, elle doit fournir un témoin. Dans un UTXO traditionnel, le script de verrouillage nécessite que les données témoins soient fournies <emphasis>en ligne</emphasis> dans la partie d&#39;entrée de la transaction qui dépense l&#39;UTXO. Un UTXO de témoin séparé, cependant, spécifie un script de verrouillage qui peut être satisfait avec des données de témoin en dehors de l&#39;entrée (séparées).</simpara>
</section>
<section id="_embranchement_convergent_rétrocompatibilité">
<title>Embranchement convergent (rétrocompatibilité)</title>
<simpara>Le témoin séparé est un changement significatif dans la manière dont les sorties et les transactions sont architecturées. Un tel changement nécessiterait normalement un changement simultané de chaque nœud et portefeuille Bitcoin pour modifier les règles de consensus, ce que l&#39;on appelle une fourche dure. Au lieu de cela, un témoin séparé est introduit avec un changement beaucoup moins perturbateur, qui est rétrocompatible, connu sous le nom d&#8217;embranchement convergent. Ce type de mise à niveau permet aux logiciels non mis à niveau d&#39;ignorer les modifications et de continuer à fonctionner sans aucune interruption.</simpara>
<simpara>Les sorties de témoins séparés sont construites de manière à ce que les systèmes plus anciens qui ne sont pas sensibles au segwit puissent toujours les valider. Pour un ancien portefeuille ou nœud, une sortie de témoin séparé ressemble à une sortie que <emphasis>n&#39;importe qui peut dépenser</emphasis>. De telles sorties peuvent être dépensées avec une signature vide, donc le fait qu&#39;il n&#39;y ait pas de signature à l&#39;intérieur de la transaction (elle est séparée) n&#39;invalide pas la transaction. Cependant, les portefeuilles et les nœuds de minage plus récents voient la sortie du témoin séparé et s&#39;attendent à trouver un témoin valide pour celle-ci dans les données de témoin de la transaction.</simpara>
<simpara>==== Exemples de témoins séparés et exemples de transactions</simpara>
<simpara>Examinons quelques-uns de nos exemples de transactions et voyons comment ils changeraient avec le témoin séparé. Nous verrons d&#39;abord comment un paiement Pay-to-Public-Key-Hash (P2PKH) est transformé avec le programme de témoignage séparé. Ensuite, nous examinerons l&#39;équivalent des témoins séparés pour les scripts Pay-to-Script-Hash (P2SH). Enfin, nous verrons comment les deux programmes de témoignage séparé précédents peuvent être intégrés dans un script P2SH.</simpara>
<section id="p2wpkh">
<title>Pay-to-Witness-Public-Key-Hash (P2WPKH)</title>
<simpara>Dans <xref linkend="cup_of_coffee"/>, <indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;acheter du café&quot;</secondary><tertiary>id=&quot;aliced&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;acheter du café&quot;</primary><secondary>id=&quot;aliced&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;aliced&quot;</primary>
</indexterm>Alice a créé une transaction pour payer Bob pour une tasse de café. Cette transaction a créé une sortie P2PKH d&#39;une valeur de 0,015 BTC pouvant être dépensée par Bob. Le script de sortie ressemble à ceci :</simpara>
<formalpara><title>Exemple de script de sortie P2PKH</title><para>
<screen>DUP HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 EQUALVERIFY CHECKSIG</screen>
</para></formalpara>
<simpara>Avec le témoin séparé, Alice créerait un script Pay-to-Witness-Public-Key-Hash (P2WPKH), qui ressemble à ceci :</simpara>
<formalpara><title>Exemple de script de sortie P2WPKH</title><para>
<screen>0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</screen>
</para></formalpara>
<simpara>Comme vous pouvez le voir, le script de verrouillage d&#39;une sortie de témoin séparé est beaucoup plus simple qu&#39;une sortie traditionnelle. Il se compose de deux valeurs qui sont transmises à la pile d&#39;évaluation du script. Pour un ancien client Bitcoin (non conscient de la technologie), les deux poussées ressembleraient à une sortie que n&#39;importe qui peut dépenser et ne nécessite pas de signature (ou plutôt, peut être dépensée avec une signature vide). Pour un client segwit plus récent, le premier chiffre (0) est interprété comme un numéro de version (la <emphasis>version témoin</emphasis>) et la seconde partie (20 octets) est l&#39;équivalent d&#39;un script de verrouillage connu sous le nom de <emphasis>programme témoin</emphasis>. Le programme témoin de 20 octets est simplement le hachage de la clé publique, comme dans un script P2PKH.</simpara>
<simpara>Examinons maintenant la transaction correspondante que Bob utilise pour dépenser cette sortie. Pour le script d&#39;origine (nonsegwit), la transaction de Bob devrait inclure une signature dans l&#39;entrée de transaction :</simpara>
<formalpara><title>Transaction décodée montrant une sortie P2PKH dépensée avec une signature</title><para>
<screen>[...]
“Vin” : [
"txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
"vout": 0,
         "scriptSig": “&lt;Bob’s scriptSig&gt;”,
]
[...]</screen>
</para></formalpara>
<simpara>Cependant, pour passer la sortie du témoin séparé, la transaction n&#39;a pas de signature dans la partie d&#39;entrée. Au lieu de cela, la transaction de Bob a un <literal>scriptSig</literal> vide dans les données de transaction (la première partie d&#39;une transaction, qui inclut la partie d&#39;entrée) et inclut sa signature dans les données témoins (la deuxième partie d&#39;une transaction, qui est séparée des données de transaction ):</simpara>
<formalpara><title>Transaction décodée montrant une sortie P2WPKH dépensée avec des données témoins séparées</title><para>
<screen>[...]
“Vin” : [
"txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
"vout": 0,
         "scriptSig": “”,
]
[...]
“witness”: “&lt;Bob’s witness data&gt;”
[...]</screen>
</para></formalpara>
</section>
<section id="_construction_de_portefeuille_de_p2wpkh">
<title>Construction de portefeuille de P2WPKH</title>
<simpara>Il est extrêmement important de noter que P2WPKH ne doit être créé que par le bénéficiaire (destinataire) et non converti par l&#39;expéditeur à partir d&#39;une clé publique connue, d&#39;un script P2PKH ou d&#39;une adresse. Le destinataire n&#39;a aucun moyen de savoir si le portefeuille de l&#39;expéditeur a la capacité de construire des transactions segwit et de dépenser les sorties P2WPKH.</simpara>
<simpara>De plus, les sorties P2WPKH doivent être construites à partir du hachage d&#39;une clé publique <emphasis>compressée</emphasis>. Les clés publiques non compressées ne sont pas standard dans segwit et peuvent être explicitement désactivées par un futur embranchement convergent. Si le hachage utilisé dans le P2WPKH provient d&#39;une clé publique non compressée, il peut être inutilisable et vous risquez de perdre des fonds. Les sorties P2WPKH doivent être créées par le portefeuille du bénéficiaire en dérivant une clé publique compressée à partir de sa clé privée.</simpara>
<warning>
<simpara>P2WPKH doit être construit par le bénéficiaire (destinataire) en convertissant une clé publique compressée en un hachage P2WPKH. Vous ne devez jamais transformer un script P2PKH, une adresse Bitcoin ou une clé publique non compressée en un script témoin P2WPKH.</simpara>
</warning>
</section>
<section id="p2wsh">
<title>Pay-to-Witness-Script-Hash (P2WSH)</title>
<simpara>Le <indexterm>
  <primary>&quot;cas d"utilisation&quot;</primary><secondary>&quot;import/export&quot;</secondary><tertiary>id=&quot;mohamappd&quot;</tertiary>
</indexterm>
<indexterm>
  <primary>&quot;import/export&quot;</primary><secondary>id=&quot;mohamappd&quot;</secondary>
</indexterm>
<indexterm>
  <primary>id=&quot;mohamappd&quot;</primary>
</indexterm>deuxième type de programme témoin correspond à un script Pay-to-Script-Hash (P2SH). Nous avons vu ce type de script dans <xref linkend="p2sh"/>. Dans cet exemple, P2SH a été utilisé par la société de Mohammed pour exprimer un script multisignature. Les paiements à l&#39;entreprise de Mohammed étaient encodés avec un script de verrouillage comme celui-ci :</simpara>
<formalpara><title>Exemple de script de sortie P2SH</title><para>
<screen>HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL</screen>
</para></formalpara>
<simpara>Ce script P2SH fait référence au hachage d&#39;un <emphasis>script d&#39;échange</emphasis> qui définit une exigence multisignature 2 sur 5 pour dépenser des fonds. Pour dépenser cette sortie, la société de Mohammed présenterait le script de rachat (dont le hachage correspond au hachage du script dans la sortie P2SH) et les signatures nécessaires pour satisfaire ce script de rachat, le tout dans l&#39;entrée de transaction :</simpara>
<formalpara><title>Transaction décodée montrant qu&#39;une sortie P2SH est dépensée</title><para>
<screen>[...]
“Vin” : [
"txid": "abcdef12345...",
"vout": 0,
         "scriptSig": “&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG&gt;”,
]</screen>
</para></formalpara>
<simpara>Maintenant, regardons comment cet exemple entier serait mis à niveau vers segwit. Si les clients de Mohammed utilisaient un portefeuille compatible segwit, ils effectueraient un paiement, créant une sortie Pay-to-Witness-Script-Hash (P2WSH) qui ressemblerait à ceci :</simpara>
<formalpara><title>Exemple de script de sortie P2WSH</title><para>
<screen>0 a9b7b38d972cabc7961dbfbcb841ad4508d133c47ba87457b4a0e8aae86dbb89</screen>
</para></formalpara>
<simpara>Encore une fois, comme dans l&#39;exemple de P2WPKH, vous pouvez voir que le script équivalent Segregated Witness est beaucoup plus simple et omet les différents opérandes de script que vous voyez dans les scripts P2SH. Au lieu de cela, le programme de témoignage séparé se compose de deux valeurs poussées vers la pile : une version témoin (0) et le hachage SHA256 de 32 octets du script de rachat.</simpara>
<simpara>La société de Mohammed peut dépenser la sortie P2WSH en présentant le bon script de rachat et suffisamment de signatures pour le satisfaire. Le script de rachat et les signatures seraient séparés <emphasis>en dehors</emphasis> des données de transaction de dépenses dans le cadre des données de témoin. Dans l&#39;entrée de transaction, le portefeuille de Mohammed <indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;mohamappd&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;mohamappd&quot;</primary>
</indexterm>mettrait un <literal>scriptSig</literal> vide :</simpara>
<formalpara><title>Transaction décodée montrant une sortie P2WSH dépensée avec des données témoins séparées</title><para>
<screen>[...]
“Vin” : [
"txid": "abcdef12345...",
"vout": 0,
         "scriptSig": “”,
]
[...]
“witness”: “&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG&gt;”
[...]</screen>
</para></formalpara>
<tip>
<simpara>Alors que P2SH utilise le hachage <literal>RIPEMD160(SHA256(script))</literal> de 20 octets, le programme témoin P2WSH utilise un hachage <literal>SHA256(script)</literal> de 32 octets. Cette différence dans le choix de l&#39;algorithme de hachage est délibérée et offre une sécurité renforcée à P2WSH (128 bits de sécurité dans P2WSH contre 80 bits de sécurité dans P2SH). Il est également utilisé pour différencier les deux types de programmes témoins (P2WPKH et P2WSH) en utilisant la longueur du hachage (voir ci-dessous).</simpara>
</tip>
</section>
<section id="_différenciation_entre_p2wpkh_et_p2wsh">
<title>Différenciation entre P2WPKH et P2WSH</title>
<simpara>Dans les deux sections précédentes, nous avons présenté deux types de programmes de témoins : <xref linkend="p2wpkh"/> et <xref linkend="p2wsh"/>. Les deux types de programmes témoins se composent d&#39;un numéro de version à un seul octet suivi d&#39;un hachage plus long. Ils se ressemblent beaucoup, mais sont interprétés très différemment : l&#39;un est interprété comme un hachage de clé publique, qui est satisfait par une signature et l&#39;autre comme un hachage de script, qui est satisfait par un script de rachat. La différence critique entre eux est la longueur du hachage :</simpara>
<itemizedlist>
<listitem>
<simpara>
Le hachage de clé publique dans P2WPKH est de 20 octets
</simpara>
</listitem>
<listitem>
<simpara>
Le hachage du script dans P2WSH est de 32 octets
</simpara>
</listitem>
</itemizedlist>
<simpara>C&#39;est la seule différence qui permet à un portefeuille de différencier les deux types de programmes de témoins. En examinant la longueur du hachage, un portefeuille peut déterminer de quel type de programme témoin il s&#39;agit, P2WPKH ou P2WSH.</simpara>
</section>
</section>
<section id="_mise_à_niveau_vers_un_témoin_séparé">
<title>Mise à niveau vers un témoin séparé</title>
<simpara>Comme nous pouvons le voir dans les exemples précédents, la mise à niveau vers les témoins séparés est un processus en deux étapes. Tout d&#39;abord, les portefeuilles doivent créer des sorties spéciales de type segwit. Ensuite, ces sorties peuvent être dépensées par des portefeuilles qui savent comment construire des transactions de témoin séparé. Dans les exemples, le portefeuille d&#39;Alice était sensible au segwit et capable de créer des sorties spéciales avec des scripts de témoignage séparés. Le portefeuille de Bob est également sensible au segwit et capable de dépenser ces sorties. Ce qui n&#39;est peut-être pas évident à partir de l&#39;exemple, c&#39;est qu&#39;en pratique, le portefeuille d&#39;Alice doit <emphasis>savoir</emphasis> que Bob utilise un portefeuille sensible au segwit et peut dépenser ces sorties. Sinon, si le portefeuille de Bob n&#39;est pas mis à niveau et qu&#39;Alice essaie d&#39;effectuer des paiements en segwit à Bob, le portefeuille de Bob ne pourra pas détecter ces paiements.</simpara>
<tip>
<simpara>Pour les types de paiement P2WPKH et P2WSH, les portefeuilles de l&#39;expéditeur et du destinataire doivent être mis à niveau pour pouvoir utiliser segwit. De plus, le portefeuille de l&#39;expéditeur doit savoir que le portefeuille du destinataire est sensible au segwit.</simpara>
</tip>
<simpara>Le témoin séparé ne sera pas mis en œuvre simultanément sur l&#39;ensemble du réseau. Au lieu de cela, Segregated Witness est implémenté comme une mise à niveau rétrocompatible, où <emphasis>les anciens et les nouveaux clients peuvent coexister</emphasis>. Les développeurs de portefeuille mettront indépendamment à niveau le logiciel de portefeuille pour ajouter des fonctionnalités segwit. Les types de paiement P2WPKH et P2WSH sont utilisés lorsque l&#39;expéditeur et le destinataire sont conscients de segwit. Les P2PKH et P2SH traditionnels continueront de fonctionner pour les portefeuilles non mis à niveau. Cela laisse deux scénarios importants, qui sont abordés dans la section suivante :</simpara>
<itemizedlist>
<listitem>
<simpara>
Capacité du portefeuille d&#39;un expéditeur qui n&#39;est pas conscient de segwit à effectuer un paiement sur le portefeuille d&#39;un destinataire qui peut traiter des transactions segwit
</simpara>
</listitem>
<listitem>
<simpara>
Capacité du portefeuille d&#39;un expéditeur qui est conscient de segwit à reconnaître et à distinguer les destinataires qui sont conscients de segwit et ceux qui ne le sont pas, par leurs <emphasis>adresses</emphasis>.
</simpara>
</listitem>
</itemizedlist>
<section id="_intégration_d_39_un_témoin_séparé_dans_p2sh">
<title>Intégration d&#39;un témoin séparé dans P2SH</title>
<simpara>Supposons, par exemple, que le portefeuille d&#39;Alice n&#39;est pas mis à niveau vers segwit, mais que le portefeuille de Bob est mis à niveau et peut gérer les transactions segwit. Alice et Bob peuvent utiliser les &quot;anciennes&quot; transactions non-segwit. Mais Bob voudrait probablement utiliser segwit pour réduire les frais de transaction, en profitant de la remise qui s&#39;applique aux données des témoins.</simpara>
<simpara>Dans ce cas, le portefeuille de Bob peut construire une adresse P2SH qui contient un script segwit à l&#39;intérieur. Le portefeuille d&#39;Alice considère cela comme une adresse P2SH &quot;normale&quot; et peut y effectuer des paiements sans aucune connaissance de segwit. Le portefeuille de Bob peut ensuite dépenser ce paiement avec une transaction segwit, tirant pleinement parti de segwit et réduisant les frais de transaction.</simpara>
<simpara>Les deux formes de scripts témoins, P2WPKH et P2WSH, peuvent être intégrées dans une adresse P2SH. Le premier est noté P2SH(P2WPKH) et le second est noté P2SH(P2WSH).</simpara>
</section>
<section id="_pay_to_witness_public_key_hash_dans_pay_to_script_hash">
<title>Pay-to-Witness-Public-Key-Hash dans Pay-to-Script-Hash</title>
<simpara>La première forme de script témoin que nous examinerons est P2SH(P2WPKH). Il s&#39;agit d&#39;un programme témoin Pay-to-Witness-Public-Key-Hash, intégré dans un script Pay-to-Script-Hash, afin qu&#39;il puisse être utilisé par un portefeuille qui n&#39;est pas conscient de segwit.</simpara>
<simpara>Le portefeuille de Bob construit un programme témoin P2WPKH avec la clé publique de Bob. Ce programme témoin est ensuite haché et le hachage résultant est encodé sous la forme d&#39;un script P2SH. Le script P2SH est converti en une adresse Bitcoin, celle qui commence par un &quot;3&quot;, comme nous l&#39;avons vu dans le <xref linkend="p2sh"/> rubrique.</simpara>
<simpara>Le portefeuille de Bob commence par le programme témoin P2WPKH que nous avons vu plus tôt :</simpara>
<formalpara><title>Programme de témoins P2WPKH de Bob</title><para>
<screen>0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</screen>
</para></formalpara>
<simpara>Le programme témoin P2WPKH se compose de la version témoin et du hachage de clé publique de 20 octets de Bob.</simpara>
<simpara>Le portefeuille de Bob hache ensuite le programme témoin précédent, d&#39;abord avec SHA256, puis avec RIPEMD160, produisant un autre hachage de 20 octets.</simpara>
<simpara>Utilisons <literal>bx</literal> sur la ligne de commande pour répliquer cela :</simpara>
<formalpara><title>HASH160 du programme témoin P2WPKH</title><para>
<screen>echo \
'0 [ab68025513c3dbd2f7b92a94e0581f5d50f654e7]'\
 | bx script-encode | bx sha256 | bx ripemd160
3e0547268b3b19288b3adef9719ec8659f4b2b0b</screen>
</para></formalpara>
<simpara>Ensuite, le hachage du script de rachat est converti en une adresse Bitcoin. Utilisons à nouveau <literal>bx</literal> sur la ligne de commande :</simpara>
<formalpara><title>Adresse P2SH</title><para>
<screen>echo \
'3e0547268b3b19288b3adef9719ec8659f4b2b0b' \
| bx address-encode -v 5
37Lx99uaGn5avKBxiW26HjedQE3LrDCZru</screen>
</para></formalpara>
<simpara>Maintenant, Bob peut afficher cette adresse pour que les clients paient leur café. Le portefeuille d&#39;Alice peut effectuer un paiement au <literal>37Lx99uaGn5avKBxiW26HjedQE3LrDCZru</literal>, comme il le ferait avec n&#39;importe quelle autre adresse Bitcoin.</simpara>
<simpara>Pour payer Bob, le portefeuille d&#39;Alice verrouillerait la sortie avec un script P2SH :</simpara>
<screen>HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL</screen>
<simpara>Même si le portefeuille d&#39;Alice ne prend pas en charge segwit, le paiement qu&#39;il crée peut être dépensé par Bob avec une transaction segwit.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;aliced&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;aliced&quot;</primary>
</indexterm></simpara>
</section>
<section id="_pay_to_witness_script_hash_dans_pay_to_script_hash">
<title>Pay-to-Witness-Script-Hash dans Pay-to-Script-Hash</title>
<simpara>De même, un programme témoin P2WSH pour un script multisig ou un autre script compliqué peut être intégré dans un script et une adresse P2SH, permettant à n&#39;importe quel portefeuille d&#39;effectuer des paiements compatibles avec segwit.</simpara>
<simpara>Comme nous l&#39;avons vu dans <xref linkend="p2wsh"/>, la société de Mohammed <indexterm>
  <primary>&quot;cas d&#39;utilisation&quot;</primary><secondary>&quot;import/export&quot;</secondary>
</indexterm>
<indexterm>
  <primary>&quot;import/export&quot;</primary>
</indexterm> utilise des paiements de témoins séparés avec des scripts multisignatures. Pour permettre à tout client de payer son entreprise, que ses portefeuilles soient ou non mis à niveau pour segwit, le portefeuille de Mohammed peut intégrer le programme témoin P2WSH dans un script P2SH.</simpara>
<simpara>Tout d&#39;abord, le portefeuille de Mohammed hache le script de rachat avec SHA256 (une seule fois). Utilisons <literal>bx</literal> pour faire cela sur la ligne de commande :</simpara>
<formalpara><title>Le portefeuille de Mohammed crée un programme témoin P2WSH</title><para>
<screen>echo \
2 \ [04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \
[04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \
[047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \
[0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \
[043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \
5 CHECKMULTISIG \
| bx script-encode | bx sha256
9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</screen>
</para></formalpara>
<simpara>Ensuite, le script de rachat haché est transformé en un programme témoin P2WSH :</simpara>
<screen>0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</screen>
<simpara>Ensuite, le programme témoin lui-même est haché avec SHA256 et RIPEMD160, produisant un nouveau hachage de 20 octets, tel qu&#39;utilisé dans le P2SH traditionnel. Utilisons <literal>bx</literal> sur la ligne de commande pour faire cela :</simpara>
<formalpara><title>Le HASH160 du programme témoin P2WSH</title><para>
<screen> echo \
'0 [9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73]'\
 | bx script-encode | bx sha256 | bx ripemd160
86762607e8fe87c0c37740cddee880988b9455b2</screen>
</para></formalpara>
<simpara>Ensuite, le portefeuille construit une adresse Bitcoin P2SH à partir de ce hachage. Encore une fois, nous utilisons <literal>bx</literal> pour calculer sur la ligne de commande :</simpara>
<formalpara><title>P2SH Adresse bitcoin</title><para>
<screen>echo \
'86762607e8fe87c0c37740cddee880988b9455b2'\
 | bx address-encode -v 5
3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG</screen>
</para></formalpara>
<simpara>Désormais, les clients de Mohammed peuvent effectuer des paiements à cette adresse sans avoir besoin de prendre en charge segwit. Pour envoyer un paiement à Mohammed, un portefeuille verrouillerait la sortie avec le script P2SH suivant :</simpara>
<formalpara><title>Script P2SH utilisé pour verrouiller les paiements sur le multisig de Mohammed</title><para>
<screen>HASH160 86762607e8fe87c0c37740cddee880988b9455b2 EQUAL</screen>
</para></formalpara>
<simpara>La société de Mohammed peut alors construire des transactions segwit pour dépenser ces paiements, en tirant parti des fonctionnalités segwit, notamment des frais de transaction moins élevés.</simpara>
</section>
<section id="_adresses_de_témoins_séparés">
<title>Adresses de témoins séparés</title>
<simpara>Même après l&#39;activation de segwit, il faudra un certain temps avant que la plupart des portefeuilles soient mis à niveau. Dans un premier temps, segwit sera intégré à P2SH, comme nous l&#39;avons vu dans la section précédente, pour faciliter la compatibilité entre les portefeuilles prenant en charge et ignorants de segwit.</simpara>
<simpara>Cependant, une fois que les portefeuilles prennent largement en charge segwit, il est logique d&#39;encoder les scripts témoins directement dans un format d&#39;adresse natif conçu pour segwit, plutôt que de l&#39;intégrer dans P2SH.</simpara>
<simpara>Le format d&#39;adresse segwit natif est défini dans BIP-173 :</simpara>
<variablelist>
<varlistentry>
<term>
<ulink url="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-173</ulink> 
</term>
<listitem>
<simpara>
Format d&#39;adresse Base32 pour les sorties témoins natives v0-16
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>BIP-173 encode uniquement les scripts témoins (P2WPKH et P2WSH). Il n&#39;est pas compatible avec les scripts P2PKH ou P2SH non-segwit. BIP-173 est un encodage Base32 à somme de contrôle, par rapport à l&#39;encodage Base58 d&#39;une adresse Bitcoin &quot;traditionnelle&quot;. Les adresses BIP-173 sont également appelées adresses <emphasis>bech32</emphasis>, prononcées &quot;beh-ch trente-deux&quot;, faisant allusion à l&#39;utilisation d&#39;un algorithme de détection d&#39;erreur &quot;BCH&quot; et d&#39;un ensemble de codage à 32 caractères.</simpara>
<simpara>Les adresses BIP-173 utilisent un jeu de 32 caractères alphanumériques en minuscules uniquement, soigneusement sélectionnés pour réduire les erreurs de lecture ou de frappe. En choisissant un jeu de caractères en minuscules uniquement, bech32 est plus facile à lire, à parler et 45 % plus efficace pour encoder dans les codes QR.</simpara>
<simpara>L&#39;algorithme de détection d&#39;erreurs BCH est une grande amélioration par rapport à l&#39;algorithme de somme de contrôle précédent (de Base58Check), permettant non seulement la détection mais aussi la <emphasis>correction</emphasis> des erreurs. Les interfaces de saisie d&#39;adresse (telles que les champs de texte dans les formulaires) peuvent détecter et mettre en évidence le caractère le plus susceptible d&#39;être mal saisi lorsqu&#39;elles détectent une erreur.</simpara>
<simpara>De la spécification BIP-173, voici quelques exemples d&#39;adresses bech32 :</simpara>
<variablelist>
<varlistentry>
<term>
Mainnet P2WPKH
</term>
<listitem>
<simpara>
bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Testnet P2WPKH
</term>
<listitem>
<simpara>
tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Mainnet P2WSH
</term>
<listitem>
<simpara>
bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Testnet P2WSH
</term>
<listitem>
<simpara>
tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Comme vous pouvez le voir dans ces exemples, une chaîne segwit bech32 contient jusqu&#39;à 90 caractères et se compose de trois parties :</simpara>
<variablelist>
<varlistentry>
<term>
La partie lisible par l&#39;homme
</term>
<listitem>
<simpara>
Ce préfixe &quot;bc&quot; ou &quot;tb&quot; identifiant mainnet ou testnet
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Le séparateur
</term>
<listitem>
<simpara>
Le chiffre &quot;1&quot;, qui ne fait pas partie du jeu de codage à 32 caractères et ne peut apparaître qu&#39;à cette position en tant que séparateur
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
La partie données
</term>
<listitem>
<simpara>
Un minimum de 6 caractères alphanumériques, le script témoin encodé par somme de contrôle
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>À l&#39;heure actuelle, seuls quelques portefeuilles acceptent ou produisent des adresses segwit bech32 natives, mais à mesure que l&#39;adoption de segwit augmente, vous les verrez de plus en plus souvent.</simpara>
<simpara><xref linkend="segwit_addresses"/> affiche les adresses bitcoin non-segwit (héritées) et segwit.</simpara>
<table id="segwit_addresses"
frame="all"
rowsep="1" colsep="1"
>
<title>Bitcoin non-segwit (hérité) et adresses segwit</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Encodage</simpara></entry>
<entry align="left" valign="top"><simpara>Préfixe</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse P2PKH héritée</simpara></entry>
<entry align="left" valign="top"><simpara>Base58</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ancienne adresse Testnet P2PKH</simpara></entry>
<entry align="left" valign="top"><simpara>Base58</simpara></entry>
<entry align="left" valign="top"><simpara>m ou n</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ancienne adresse P2SH</simpara></entry>
<entry align="left" valign="top"><simpara>Base58</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ancienne adresse Testnet P2SH</simpara></entry>
<entry align="left" valign="top"><simpara>Base58</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse Segwit P2SH(P2WPKH) imbriquée (intégrée)</simpara></entry>
<entry align="left" valign="top"><simpara>Base58</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse Segwit P2SH(P2WSH) imbriquée (intégrée)</simpara></entry>
<entry align="left" valign="top"><simpara>Base58</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse native Segwit P2WPKH</simpara></entry>
<entry align="left" valign="top"><simpara>Bech32</simpara></entry>
<entry align="left" valign="top"><simpara>bc1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse native Segwit Testnet P2WPKH</simpara></entry>
<entry align="left" valign="top"><simpara>Bech32</simpara></entry>
<entry align="left" valign="top"><simpara>tb1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse native Segwit P2WSH</simpara></entry>
<entry align="left" valign="top"><simpara>Bech32</simpara></entry>
<entry align="left" valign="top"><simpara>bc1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adresse native Segwit Testnet P2WSH</simpara></entry>
<entry align="left" valign="top"><simpara>Bech32</simpara></entry>
<entry align="left" valign="top"><simpara>tb1</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="segwit_txid">
<title>Identifiants de transaction</title>
<simpara><indexterm>
  <primary>&quot;identifiant de transaction (txid)&quot;</primary>
</indexterm>L&#39;un des plus grands avantages des témoin séparés est qu&#39;il élimine la malléabilité des transactions tierces.</simpara>
<simpara>Avant segwit, les transactions pouvaient voir leurs signatures subtilement modifiées par des tiers, changeant leur ID de transaction (hachage) sans changer aucune propriété fondamentale (entrées, sorties, montants). Cela a créé des opportunités d&#39;attaques par déni de service ainsi que des attaques contre des logiciels de portefeuille mal écrits qui supposaient que les hachages de transaction non confirmés étaient immuables.</simpara>
<simpara>Avec l&#39;introduction des témoins séparés, les transactions ont deux identifiants, <literal>txid</literal> et <literal>wtxid</literal>. L&#39;identifiant de transaction traditionnel <literal>txid</literal> est le hachage double SHA256 de la transaction sérialisée, sans les données témoins. Une transaction <literal>wtxid</literal> est le hachage double SHA256 du nouveau format de sérialisation de la transaction avec des données témoins.</simpara>
<simpara>Le <literal>txid</literal> traditionnel est calculé exactement de la même manière qu&#39;avec une transaction non segwit. Cependant, étant donné qu&#39;une transaction segwit pure (une transaction qui ne contient que des entrées segwit) a des <literal>scriptSig</literal> vides dans chaque entrée, aucune partie de la transaction ne peut être modifiée par un tiers. Par conséquent, dans une transaction segwit pure, le <literal>txid</literal> est immuable par un tiers, même lorsque la transaction n&#39;est pas confirmée.</simpara>
<simpara>Le <literal>wtxid</literal> est comme un identifiant &quot;étendu&quot;, en ce que le hachage incorpore également les données du témoin. Si une transaction est transmise sans données témoins, alors le <literal>wtxid</literal> et le <literal>txid</literal> sont identiques. Notez que puisque le <literal>wtxid</literal> inclut des données témoins (signatures) et que les données témoins peuvent être malléables, le <literal>wtxid</literal> doit être considéré comme malléable jusqu&#39;à ce que la transaction soit confirmée. Seul le <literal>txid</literal> d&#39;une pure transaction segwit peut être considéré comme immuable par des tiers.</simpara>
<tip>
<simpara>Les transactions de témoin séparé ont deux identifiants : <literal>txid</literal> et <literal>wtxid</literal>. Le <literal>txid</literal> est le hachage de la transaction sans les données témoins et le <literal>wtxid</literal> est le hachage incluant les données témoins. Seules les transactions segwit pures (transactions qui ne contiennent que des entrées segwit) ont un <literal>txid</literal> qui n&#39;est pas sensible à la malléabilité des transactions tierces.</simpara>
</tip>
</section>
</section>
<section id="_nouvel_algorithme_de_signature_des_témoins_séparés">
<title>Nouvel algorithme de signature des témoins séparés</title>
<simpara>Le témoin séparé modifie la sémantique des quatre fonctions de vérification de signature (<literal>CHECKSIG</literal>, <literal>CHECKSIGVERIFY</literal>, <literal>CHECKMULTISIG</literal> et <literal>CHECKMULTISIGVERIFY</literal>), changeant la façon dont un hachage d&#39;engagement de transaction est calculé.</simpara>
<simpara>Les signatures dans les transactions bitcoin sont appliquées sur un <emphasis>hachage d&#39;engagement</emphasis>, qui est calculé à partir des données de transaction, verrouillant des parties spécifiques des données indiquant l&#39;engagement du signataire envers ces valeurs. Par exemple, dans une signature de type <literal>SIGHASH_ALL</literal> simple, le hachage d&#39;engagement inclut toutes les entrées et sorties.</simpara>
<simpara>Malheureusement, la façon dont le hachage d&#39;engagement a été calculé a introduit la possibilité qu&#39;un nœud vérifiant la signature puisse être forcé d&#39;effectuer un nombre important de calculs de hachage. Plus précisément, les opérations de hachage augmentent en O(n<superscript>2</superscript>) par rapport au nombre d&#39;opérations de signature dans la transaction. Un attaquant pourrait donc créer une transaction avec un très grand nombre d&#39;opérations de signature, obligeant l&#39;ensemble du réseau Bitcoin à effectuer des centaines ou des milliers d&#39;opérations de hachage pour vérifier la transaction.</simpara>
<simpara>Segwit représentait une opportunité de résoudre ce problème en modifiant la façon dont le hachage d&#39;engagement est calculé. Pour les programmes témoins segwit version 0, la vérification de la signature se produit à l&#39;aide d&#39;un algorithme de hachage d&#39;engagement amélioré, comme spécifié dans BIP-143.</simpara>
<simpara>Le nouvel algorithme atteint deux objectifs importants. Premièrement, le nombre d&#39;opérations de hachage augmente d&#39;un O(n) beaucoup plus graduel au nombre d&#39;opérations de signature, réduisant la possibilité de créer des attaques par déni de service avec des transactions trop complexes. Deuxièmement, le hachage d&#39;engagement inclut désormais également la valeur (montants) de chaque entrée dans le cadre de l&#39;engagement. Cela signifie qu&#39;un signataire peut s&#39;engager sur une valeur d&#39;entrée spécifique sans avoir besoin de &quot;récupérer&quot; et de vérifier la transaction précédente référencée par l&#39;entrée. Dans le cas d&#39;appareils hors ligne, tels que les portefeuilles matériels, cela simplifie grandement la communication entre l&#39;hôte et le portefeuille matériel, supprimant la nécessité de diffuser les transactions précédentes pour validation. Un portefeuille matériel peut accepter la valeur d&#39;entrée &quot;telle qu&#39;elle est indiquée&quot; par un hôte non approuvé. Étant donné que la signature n&#39;est pas valide si cette valeur d&#39;entrée n&#39;est pas correcte, le portefeuille matériel n&#39;a pas besoin de valider la valeur avant de signer l&#39;entrée.</simpara>
</section>
<section id="_incitations_économiques_pour_les_témoins_isolés">
<title>Incitations économiques pour les témoins isolés</title>
<simpara>Les nœuds miniers Bitcoin et les nœuds complets entraînent des coûts pour les ressources utilisées pour prendre en charge le réseau Bitcoin et la chaîne de blocs. À mesure que le volume de transactions bitcoin augmente, le coût des ressources (CPU, bande passante réseau, espace disque, mémoire) augmente également. Les mineurs sont indemnisés pour ces coûts par des frais proportionnels à la taille (en octets) de chaque transaction. Les nœuds complets non miniers ne sont pas rémunérés, ils encourent donc ces coûts parce qu&#39;ils ont besoin d&#39;exécuter un nœud d&#39;index complet faisant autorité, peut-être parce qu&#39;ils utilisent le nœud pour exploiter une entreprise bitcoin.</simpara>
<simpara>Sans frais de transaction, la croissance des données bitcoin augmenterait sans doute de façon spectaculaire. Les frais sont destinés à aligner les besoins des utilisateurs de bitcoins sur le fardeau que leurs transactions imposent au réseau, grâce à un mécanisme de découverte des prix basé sur le marché.</simpara>
<simpara>Le calcul des frais en fonction de la taille de la transaction traite toutes les données de la transaction comme ayant un coût égal. Mais du point de vue des nœuds complets et des mineurs, certaines parties d&#39;une transaction entraînent des coûts beaucoup plus élevés. Chaque transaction ajoutée au réseau Bitcoin affecte la consommation de quatre ressources sur les nœuds :</simpara>
<variablelist>
<varlistentry>
<term>
Espace disque 
</term>
<listitem>
<simpara>
Chaque transaction est stockée dans la chaîne de blocs, ajoutant à la taille totale de la chaîne de blocs. La chaîne de blocs est stockée sur disque, mais le stockage peut être optimisé en « élaguant » (supprimant) les anciennes transactions.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
CPU 
</term>
<listitem>
<simpara>
Chaque transaction doit être validée, ce qui nécessite du temps CPU.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Bande passante 
</term>
<listitem>
<simpara>
Chaque transaction est transmise (par propagation d&#39;inondation) sur le réseau au moins une fois. Sans aucune optimisation du protocole de propagation de bloc, les transactions sont à nouveau transmises dans le cadre d&#39;un bloc, ce qui double l&#39;impact sur la capacité du réseau.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Mémoire 
</term>
<listitem>
<simpara>
Les nœuds qui valident les transactions conservent l&#39;index UTXO ou l&#39;intégralité de l&#39;ensemble UTXO en mémoire pour accélérer la validation. Étant donné que la mémoire est au moins un ordre de grandeur plus chère que le disque, la croissance de l&#39;ensemble UTXO contribue de manière disproportionnée au coût d&#39;exécution d&#39;un nœud.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Comme vous pouvez le voir dans la liste, toutes les parties d&#39;une transaction n&#39;ont pas le même impact sur le coût d&#39;exécution d&#39;un nœud ou sur la capacité du bitcoin à évoluer pour prendre en charge davantage de transactions. La partie la plus coûteuse d&#39;une transaction sont les sorties nouvellement créées, car elles sont ajoutées à l&#39;ensemble UTXO en mémoire. En comparaison, les signatures (c&#39;est-à-dire les données témoins) ajoutent le moins de charge au réseau et au coût d&#39;exécution d&#39;un nœud, car les données témoins ne sont validées qu&#39;une seule fois et ne sont jamais réutilisées. De plus, immédiatement après avoir reçu une nouvelle transaction et validé les données témoins, les nœuds peuvent supprimer ces données témoins. Si les frais sont calculés en fonction de la taille de la transaction, sans faire de distinction entre ces deux types de données, les incitations du marché en matière de frais ne sont pas alignées sur les coûts réels imposés par une transaction. En fait, la structure tarifaire actuelle encourage en fait le comportement inverse, car les données des témoins constituent la plus grande partie d&#39;une transaction.</simpara>
<simpara>Les incitations créées par les frais sont importantes car elles affectent le comportement des portefeuilles. Tous les portefeuilles doivent mettre en œuvre une stratégie pour assembler les transactions qui prend en considération un certain nombre de facteurs, tels que la confidentialité (réduction de la réutilisation des adresses), la fragmentation (faire beaucoup de monnaie) et les frais. Si les frais motivent massivement les portefeuilles à utiliser le moins d&#39;entrées possible dans les transactions, cela peut conduire à la sélection d&#39;UTXO et à la modification des stratégies d&#39;adresse qui gonflent par inadvertance l&#39;ensemble UTXO.</simpara>
<simpara>Les transactions consomment les UTXO dans leurs entrées et créent de nouveaux UTXO avec leurs sorties. Par conséquent, une transaction qui a plus d&#39;entrées que de sorties entraînera une diminution de l&#39;ensemble UTXO, tandis qu&#39;une transaction qui a plus de sorties que d&#39;entrées entraînera une augmentation de l&#39;ensemble UTXO. Considérons la <emphasis>difference</emphasis> entre les entrées et les sorties et appelons cela le &quot;Net-new-UTXO&quot;. Il s&#39;agit d&#39;une mesure importante, car elle nous indique l&#39;impact qu&#39;une transaction aura sur la ressource la plus chère à l&#39;échelle du réseau, l&#39;ensemble UTXO en mémoire. Une transaction avec Net-new-UTXO positif ajoute à ce fardeau. Une transaction avec un Net-new-UTXO négatif réduit la charge. Nous voudrions donc encourager les transactions qui sont soit Net-new-UTXO négatives, soit neutres avec zéro Net-new-UTXO.</simpara>
<simpara>Examinons un exemple des incitations créées par le calcul des frais de transaction, avec et sans témoin séparé. Nous examinerons deux transactions différentes. La transaction A est une transaction à 3 entrées et 2 sorties, qui a une métrique Net-new-UTXO de -1, ce qui signifie qu&#39;elle consomme un UTXO de plus qu&#39;elle n&#39;en crée, ce qui réduit l&#39;UTXO défini d&#39;un. La transaction B est une transaction à 2 entrées et 3 sorties, qui a une métrique Net-new-UTXO de 1, ce qui signifie qu&#39;elle ajoute un UTXO à l&#39;ensemble UTXO, imposant un coût supplémentaire à l&#39;ensemble du réseau Bitcoin. Les deux transactions utilisent des scripts multisignatures (2 sur 3) pour démontrer comment des scripts complexes augmentent l&#39;impact d&#39;un témoin séparé sur les frais. Supposons un taux de transaction de 30 satoshi par octet et une remise de 75 % sur les données des témoins :</simpara>
<dl>
<dt>Sans témoin séparé</dt>
<dd>
<p>Frais de transaction A : 28 590 satoshi</p>
<p>Frais de transaction B : 20 760 satoshi</p>
</dd>

<dt>Avec témoin séparé</dt>
<dd>
<p>Frais de transaction A : 12 255 satoshi</p>
<p>Frais de transaction B : 10 425 satoshi</p>
</dd>
</dl>
<simpara>Les deux transactions sont moins coûteuses lorsque le témoin séparé est mis en œuvre. En comparant les coûts entre les deux transactions, nous voyons qu&#39;avant le témoin séparé, la transaction avec le Net-new-UTXO positif permet de réaliser d&#39;importantes économies. Avec le témoin séparé, la différence de coût diminue considérablement en termes absolus et relatifs. Bien qu&#39;il faudrait que les intrants deviennent moins chers que les extrants pour inciter à la consolidation de l&#39;ensemble UTXO, cette remise réduit l&#39;incitation à créer de nouveaux UTXO afin d&#39;éviter d&#39;utiliser plus d&#39;intrants.</simpara>
<simpara>Segregated Witness a donc deux effets principaux sur les frais payés par les utilisateurs de bitcoin. Premièrement, segwit réduit le coût global des transactions en actualisant les données des témoins et en augmentant la capacité de la blockchain Bitcoin. Deuxièmement, la remise de segwit sur les données des témoins atténue partiellement un désalignement des incitations qui peut avoir créé par inadvertance plus de ballonnement dans l&#39;ensemble UTXO.<indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Tadv07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Tadv07&quot;</primary>
</indexterm><indexterm>
  <primary>&quot;&quot;</primary><secondary>startref=&quot;Ssegwit07&quot;</secondary>
</indexterm>
<indexterm>
  <primary>startref=&quot;Ssegwit07&quot;</primary>
</indexterm></simpara>
</section>
</section>
</section>
</article>
